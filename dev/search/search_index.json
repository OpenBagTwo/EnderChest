{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"EnderChest","text":"<p>Welcome to the documentation for EnderChest, a Python package for syncing and linking all your Minecraft instances.</p> <p>Use the nav bar on the side of the page to access tutorials, how-to guides or the full API docs.</p> <p>The source code for this project is freely available on GitHub.</p> <p>If you encounter a bug or have a suggestion, open an issue!</p> <p>Important!!</p> <p>EnderChest is based around the use of symbolic links.</p> <p>Starting with Minecraft 1.20, Mojang by default no longer allows worlds to load if they are or if they contain symbolic links. While it is true that an improper symlink could cause Minecraft to write data to a place it shouldn't, nothing in EnderChest will ever generate a symlink whose target is outside of your EnderChest folder unless you place a symbolic link in your EnderChest pointing to somewhere else (which you may want to do so that your screenshots, for example, point to your \"My Pictures\" folder).</p> <p>If you still have concerns about symlinks or questions about how they work, read through this guide or watch this explainer, and if you still have questions, feel free to open an issue.</p>"},{"location":"about/","title":"About EnderChest","text":"<p>With the arrival of my Steam Deck in 2022, I found myself with the very First World problem of having too many Minecraft installations across too many computers, and I really want to keep everything synced and backed up. This isn't as simple of a problem as just having a central repository on a NAS, as the machines I've got running Minecraft range from an Raspberry Pi, to an M1 Macbook to the controller-operated Steam Deck to an absolute beast of a desktop battlestation. Each machine needs its own settings, client mods and tweaks for optimal gameplay.</p> <p>Furthermore, since I make mods and datapacks and have content creation aspirations, several of my machines have multiple instance variants that are, for example, streamlined for development and testing or optimized for ReplayMod rendering, but for which I still want to share some mods, resourcepacks and worlds with other instances.</p> <p>And finally, there are some instances that I want to run on a server--either local or hosted--and keeping resource packs, mods and other assets synced between servers and clients is a giant pain.</p> <p>In short, there are three different levels of coordination that need to take place: 1. Selective sharing across different computers 1. Selective sharing across different instances on the same computer 1. Selective sharing across server and client installations</p>"},{"location":"about/#symlinks-to-the-rescue","title":"Symlinks to the Rescue!","text":"<p>The first and most important bit--making it so that changing a file in one place changes it everywhere else--is why MIT invented symbolic links, where each file is stored in exactly one location, and everywhere else that file is expected is basically just a forwarding address to that file.  Since I'm almost never going to be running two instances of Minecraft at once, there's no worrying about file locks or simultaneous writes, so making it so that there's only one true copy of every file on a file system is the ideal solution for keeping everything in sync.</p> <p>And if we're already talking about symlinking all the things, and we know we need to be able to sync files between filesystems, it makes sense to store all of those true copies in one centralized place. Hence, the EnderChest.</p>"},{"location":"about/#automagic-linking","title":"Automagic Linking","text":"<p>One could just stop there--designate a folder for all your Minecraft files, sync that folder between your computers, and then manually put links in each of your Minecraft instances pointing into the EnderChest. But dang it there are a lot of mods out there and having to create new links by hand every time you want to try out a new resource pack is very few people's idea of a fun time.</p> <p>And that's where the magic of scripting languages comes into play (and why is a Python package and not a \"how-to\" guide). With a few short terminal commands, you can set it up so that updating Sodium across all of your compatible Minecraft instances is a simple matter of dragging in the file and running the command <code>enderchest place</code>.</p>"},{"location":"about/#organizing-the-enderchest-monster-with-shulker-boxes","title":"Organizing the EnderChest Monster with Shulker Boxes","text":"<p>The original implementation of EnderChest was a giant mess, with every file for every instance just thrown into one of a small number of folders. After a few months of using it, I found myself absolutely dreading the process of creating a new Minecraft instance, knowing I'd have to update the configuration of every single file I'd want to link.</p> <p>The next iteration of this concept was probably obvious to anyone who's used an ender chest in the game after beating Jean: by grouping my files into purpose-specific \"Shulker Boxes,\" I could onboard a new Minecraft instance by editing just a handful of box-configs. Or even better--I could just tag the new instance in a way that it would get matched to the folders automatically.</p>"},{"location":"cli/","title":"Full Command-Line Interface Documentation","text":""},{"location":"cli/#summary","title":"Summary","text":"<pre><code>usage: enderchest [-h] [-v] action [arguments ...]\n\nv0.1.4-beta2+7.g2e5a94e\n\nsyncing and linking for all your Minecraft instances\n\npositional arguments:\n  action             The action to perform. Options are:\n                        craft\n                            to create and configure a new EnderChest installation\n                        craft shulker_box\n                            to create and configure a new shulker box\n                        place\n                            to link (or update the links) from your instances to your EnderChest\n                        gather instance\n                            to register (or update the registry of) a Minecraft installation\n                        gather enderchests\n                            to register (or update the registry of) a remote EnderChest\n                        inventory\n                            to list the shulker boxes inside your Enderchest\n                        inventory instances\n                            to list the minecraft instances registered with your Enderchest\n                        inventory instance\n                            to list the shulker boxes that the specified instance links into\n                        inventory shulker_box\n                            to list the minecraft instances that match the specified shulker box\n                        inventory enderchests\n                            to list the other EnderChest installations registered with this EnderChest\n                        open\n                            to pull changes from other EnderChests\n                        close\n                            to push changes to other EnderChests\n                        test\n                            to run the EnderChest test suite\n  arguments          Any additional arguments for the specific action. To learn more, try: enderchest {action} -h\n\noptions:\n  -h, --help         show this help message and exit\n  -v, -V, --version  show program's version number and exit\n</code></pre>"},{"location":"cli/#enderchest-craft","title":"<code>enderchest craft</code>","text":"<pre><code>usage: enderchest craft [-h] [--root ROOT_FLAG] [--verbose] [--quiet]\n                        [--from COPY_FROM] [-r REMOTES]\n                        [-i INSTANCE_SEARCH_PATHS] [--overwrite]\n                        [root]\n\ncreate and configure a new EnderChest installation\n\npositional arguments:\n  root                  Optionally specify your root minecraft directory. If\n                        no path is given, the current working directory will\n                        be used.\n\noptions:\n  -h, --help            show this help message and exit\n  --root ROOT_FLAG      specify your root minecraft directory\n  --verbose, -v         increase the amount of information that's printed\n  --quiet, -q           decrease the amount of information that's printed\n  --from COPY_FROM      provide the URI (e.g. rsync://deck@my-steam-\n                        deck/home/deck/) of a remote EnderChest installation\n                        that can be used to boostrap the creation of this one.\n  -r REMOTES, --remote REMOTES\n                        provide the URI (e.g. rsync://deck@my-steam-\n                        deck/home/deck/) of a remote EnderChest installation\n                        to register with this one\n  -i INSTANCE_SEARCH_PATHS, --instance INSTANCE_SEARCH_PATHS\n                        specify a folder to search for Minecraft installations\n                        in\n  --overwrite           if there's already an EnderChest installation in this\n                        location, overwrite its configuration\n</code></pre>"},{"location":"cli/#enderchest-craft-shulker_box","title":"<code>enderchest craft shulker_box</code>","text":"<pre><code>usage: enderchest craft shulker_box [-h] [--root ROOT_FLAG] [--verbose]\n                                    [--quiet] [--priority PRIORITY]\n                                    [-i INSTANCES] [-t TAGS] [-e HOSTS]\n                                    [-l LINK_FOLDERS] [--overwrite]\n                                    [root] name\n\ncreate and configure a new shulker box\n\npositional arguments:\n  root                  Optionally specify your root minecraft directory. If\n                        no path is given, the current working directory will\n                        be used.\n  name                  specify the name for this shulker box\n\noptions:\n  -h, --help            show this help message and exit\n  --root ROOT_FLAG      specify your root minecraft directory\n  --verbose, -v         increase the amount of information that's printed\n  --quiet, -q           decrease the amount of information that's printed\n  --priority PRIORITY, -p PRIORITY\n                        specify the link priority for this shulker box (higher\n                        = linked later)\n  -i INSTANCES, --instance INSTANCES\n                        only link instances with one of the provided names to\n                        this shulker box\n  -t TAGS, --tag TAGS   only link instances with one of the provided tags to\n                        this shulker box\n  -e HOSTS, --enderchest HOSTS\n                        only link instances registered to one of the provided\n                        EnderChest installations with this shulker box\n  -l LINK_FOLDERS, --folder LINK_FOLDERS\n                        specify the name of a folder inside this shulker box\n                        that should be linked completely\n  --overwrite           if there's already a shulker box with the specified\n                        name, overwrite its configuration\n</code></pre>"},{"location":"cli/#enderchest-place","title":"<code>enderchest place</code>","text":"<pre><code>usage: enderchest place [-h] [--root ROOT_FLAG] [--verbose] [--quiet]\n                        [--keep-broken-links] [--keep-stale-links] [-k]\n                        [--stop-at-first-failure | --ignore-errors | --errors {prompt,ignore,skip,skip-instance,skip-shulker-box,abort}]\n                        [--absolute | --relative]\n                        [root]\n\nlink (or update the links) from your instances to your EnderChest\n\npositional arguments:\n  root                  Optionally specify your root minecraft directory. If\n                        no path is given, the current working directory will\n                        be used.\n\noptions:\n  -h, --help            show this help message and exit\n  --root ROOT_FLAG      specify your root minecraft directory\n  --verbose, -v         increase the amount of information that's printed\n  --quiet, -q           decrease the amount of information that's printed\n  --absolute, -a        use absolute paths for all link targets\n  --relative, -r        use relative paths for all link targets\n\n  --keep-broken-links   do not remove broken links from instances\n  --keep-stale-links    do not remove existing links into the EnderChest, even\n                        if the shulker box or instance spec has changed\n  -k                    shorthand for the above cleanup options: -k will\n                        --keep-stale-links, and -kk will --keep-broken-links\n                        as well\n\nerror handling:\n  --stop-at-first-failure, -x\n                        stop linking at the first issue\n  --ignore-errors       ignore any linking errors\n  --errors {prompt,ignore,skip,skip-instance,skip-shulker-box,abort}, -e {prompt,ignore,skip,skip-instance,skip-shulker-box,abort}\n                        specify how to handle linking errors (default behavior\n                        is to prompt after every error)\n</code></pre>"},{"location":"cli/#enderchest-gather-instance","title":"<code>enderchest gather instance</code>","text":"<pre><code>usage: enderchest gather instance [-h] [--root ROOT_FLAG] [--verbose]\n                                  [--quiet] [--official | --mmc]\n                                  [root] search_paths [search_paths ...]\n\nregister (or update the registry of) a Minecraft installation\n\npositional arguments:\n  root              Optionally specify your root minecraft directory. If no\n                    path is given, the current working directory will be used.\n  search_paths      specify a folder or folders to search for Minecraft\n                    installations\n\noptions:\n  -h, --help        show this help message and exit\n  --root ROOT_FLAG  specify your root minecraft directory\n  --verbose, -v     increase the amount of information that's printed\n  --quiet, -q       decrease the amount of information that's printed\n  --official, -o    specify that these are instances managed by the official\n                    launcher\n  --mmc, -m         specify that these are MultiMC-like instances\n</code></pre>"},{"location":"cli/#enderchest-gather-enderchests","title":"<code>enderchest gather enderchests</code>","text":"<pre><code>usage: enderchest gather enderchests [-h] [--root ROOT_FLAG] [--verbose]\n                                     [--quiet]\n                                     [root] remotes [remotes ...]\n\nregister (or update the registry of) a remote EnderChest\n\npositional arguments:\n  root              Optionally specify your root minecraft directory. If no\n                    path is given, the current working directory will be used.\n  remotes           Provide URIs (e.g. rsync://deck@my-steam-deck/home/deck/)\n                    of any remote EnderChest installation to register with\n                    this one.Note: you should not use this method if the alias\n                    (name) of theremote does not match the remote's hostname\n                    (in this example,\"my-steam-deck\").\n\noptions:\n  -h, --help        show this help message and exit\n  --root ROOT_FLAG  specify your root minecraft directory\n  --verbose, -v     increase the amount of information that's printed\n  --quiet, -q       decrease the amount of information that's printed\n</code></pre>"},{"location":"cli/#enderchest-inventory","title":"<code>enderchest inventory</code>","text":"<pre><code>usage: enderchest inventory [-h] [--root ROOT_FLAG] [--verbose] [--quiet]\n                            [--instance INSTANCE_NAME] [--path PATH]\n                            [root]\n\nlist the shulker boxes inside your Enderchest\n\npositional arguments:\n  root                  Optionally specify your root minecraft directory. If\n                        no path is given, the current working directory will\n                        be used.\n\noptions:\n  -h, --help            show this help message and exit\n  --root ROOT_FLAG      specify your root minecraft directory\n  --verbose, -v         increase the amount of information that's printed\n  --quiet, -q           decrease the amount of information that's printed\n  --instance INSTANCE_NAME, -i INSTANCE_NAME\n                        The name of the minecraft instance to query\n  --path PATH, -p PATH  optionally, specify a specific path (absolute,\n                        relative, filename or glob pattern to get a report of\n                        the shulker box(es) that provide that resource\n</code></pre>"},{"location":"cli/#enderchest-inventory-instances","title":"<code>enderchest inventory instances</code>","text":"<pre><code>usage: enderchest inventory instances [-h] [--root ROOT_FLAG] [--verbose]\n                                      [--quiet]\n                                      [root]\n\nlist the minecraft instances registered with your Enderchest\n\npositional arguments:\n  root              Optionally specify your root minecraft directory. If no\n                    path is given, the current working directory will be used.\n\noptions:\n  -h, --help        show this help message and exit\n  --root ROOT_FLAG  specify your root minecraft directory\n  --verbose, -v     increase the amount of information that's printed\n  --quiet, -q       decrease the amount of information that's printed\n</code></pre>"},{"location":"cli/#enderchest-inventory-instance","title":"<code>enderchest inventory instance</code>","text":"<pre><code>usage: enderchest inventory instance [-h] [--root ROOT_FLAG] [--verbose]\n                                     [--quiet] [--path PATH]\n                                     [root] instance_name\n\nlist the shulker boxes that the specified instance links into\n\npositional arguments:\n  root                  Optionally specify your root minecraft directory. If\n                        no path is given, the current working directory will\n                        be used.\n  instance_name         The name of the minecraft instance to query\n\noptions:\n  -h, --help            show this help message and exit\n  --root ROOT_FLAG      specify your root minecraft directory\n  --verbose, -v         increase the amount of information that's printed\n  --quiet, -q           decrease the amount of information that's printed\n  --path PATH, -p PATH  optionally, specify a specific path (absolute,\n                        relative, filename or glob pattern to get a report of\n                        the shulker box(es) that provide that resource\n</code></pre>"},{"location":"cli/#enderchest-inventory-shulker_box","title":"<code>enderchest inventory shulker_box</code>","text":"<pre><code>usage: enderchest inventory shulker_box [-h] [--root ROOT_FLAG] [--verbose]\n                                        [--quiet]\n                                        [root] shulker_box_name\n\nlist the minecraft instances that match the specified shulker box\n\npositional arguments:\n  root              Optionally specify your root minecraft directory. If no\n                    path is given, the current working directory will be used.\n  shulker_box_name  the name of the shulker box to query\n\noptions:\n  -h, --help        show this help message and exit\n  --root ROOT_FLAG  specify your root minecraft directory\n  --verbose, -v     increase the amount of information that's printed\n  --quiet, -q       decrease the amount of information that's printed\n</code></pre>"},{"location":"cli/#enderchest-inventory-enderchests","title":"<code>enderchest inventory enderchests</code>","text":"<pre><code>usage: enderchest inventory enderchests [-h] [--root ROOT_FLAG] [--verbose]\n                                        [--quiet]\n                                        [root]\n\nlist the other EnderChest installations registered with this EnderChest\n\npositional arguments:\n  root              Optionally specify your root minecraft directory. If no\n                    path is given, the current working directory will be used.\n\noptions:\n  -h, --help        show this help message and exit\n  --root ROOT_FLAG  specify your root minecraft directory\n  --verbose, -v     increase the amount of information that's printed\n  --quiet, -q       decrease the amount of information that's printed\n</code></pre>"},{"location":"cli/#enderchest-open","title":"<code>enderchest open</code>","text":"<pre><code>usage: enderchest open [-h] [--root ROOT_FLAG] [--verbose] [--quiet]\n                       [--dry-run] [--exclude EXCLUDE [EXCLUDE ...]]\n                       [--timeout TIMEOUT]\n                       [--wait SYNC_CONFIRM_WAIT | --confirm]\n                       [root]\n\npull changes from other EnderChests\n\npositional arguments:\n  root                  Optionally specify your root minecraft directory. If\n                        no path is given, the current working directory will\n                        be used.\n\noptions:\n  -h, --help            show this help message and exit\n  --root ROOT_FLAG      specify your root minecraft directory\n  --verbose, -v         increase the amount of information that's printed\n  --quiet, -q           decrease the amount of information that's printed\n  --dry-run             perform a dry run of the sync operation, reporting the\n                        operations that will be performed but not actually\n                        carrying them out\n  --exclude EXCLUDE [EXCLUDE ...], -e EXCLUDE [EXCLUDE ...]\n                        Provide any file patterns you would like to skip\n                        syncing\n  --timeout TIMEOUT, -t TIMEOUT\n                        set a maximum number of seconds to try to sync to a\n                        remote chest before giving up and going on to the next\n                        one\n\nsync confirmation control:\n  The default behavior when syncing EnderChests is to first perform a dry\n  run of every sync operation and then wait 5 seconds before proceeding with\n  the real sync. The idea is to give you time to interrupt the sync if the\n  dry run looks wrong. You can raise or lower that wait time through these\n  flags. You can also modify it by editing the enderchest.cfg file.\n\n  --wait SYNC_CONFIRM_WAIT, -w SYNC_CONFIRM_WAIT\n                        set the time in seconds to wait after performing a dry\n                        run before the real sync is performed\n  --confirm, -c         after performing the dry run, explicitly ask for\n                        confirmation before performing the real sync\n</code></pre>"},{"location":"cli/#enderchest-close","title":"<code>enderchest close</code>","text":"<pre><code>usage: enderchest close [-h] [--root ROOT_FLAG] [--verbose] [--quiet]\n                        [--dry-run] [--exclude EXCLUDE [EXCLUDE ...]]\n                        [--timeout TIMEOUT]\n                        [--wait SYNC_CONFIRM_WAIT | --confirm]\n                        [root]\n\npush changes to other EnderChests\n\npositional arguments:\n  root                  Optionally specify your root minecraft directory. If\n                        no path is given, the current working directory will\n                        be used.\n\noptions:\n  -h, --help            show this help message and exit\n  --root ROOT_FLAG      specify your root minecraft directory\n  --verbose, -v         increase the amount of information that's printed\n  --quiet, -q           decrease the amount of information that's printed\n  --dry-run             perform a dry run of the sync operation, reporting the\n                        operations that will be performed but not actually\n                        carrying them out\n  --exclude EXCLUDE [EXCLUDE ...], -e EXCLUDE [EXCLUDE ...]\n                        Provide any file patterns you would like to skip\n                        syncing\n  --timeout TIMEOUT, -t TIMEOUT\n                        set a maximum number of seconds to try to sync to a\n                        remote chest before giving up and going on to the next\n                        one\n\nsync confirmation control:\n  The default behavior when syncing EnderChests is to first perform a dry\n  run of every sync operation and then wait 5 seconds before proceeding with\n  the real sync. The idea is to give you time to interrupt the sync if the\n  dry run looks wrong. You can raise or lower that wait time through these\n  flags. You can also modify it by editing the enderchest.cfg file.\n\n  --wait SYNC_CONFIRM_WAIT, -w SYNC_CONFIRM_WAIT\n                        set the time in seconds to wait after performing a dry\n                        run before the real sync is performed\n  --confirm, -c         after performing the dry run, explicitly ask for\n                        confirmation before performing the real sync\n</code></pre>"},{"location":"cli/#enderchest-test","title":"<code>enderchest test</code>","text":"<pre><code>usage: enderchest test [-h] [--use-local-ssh] ...\n\nrun the EnderChest test suite\n\npositional arguments:\n  pytest_args      any additional arguments to pass through to py.test\n\noptions:\n  -h, --help       show this help message and exit\n  --use-local-ssh  By default, tests of SSH functionality will be run against\n                   a mock SSH server. If you are running EnderChest on a\n                   machine you can SSH into locally (by running `ssh\n                   localhost`) without requiring a password, running the tests\n                   with this flag will produce more accurate results.\n</code></pre>"},{"location":"contrib/","title":"Contribution Guide","text":"<p>EnderChest is an open source project, and its source code is publicly available on GitHub.</p> <p>Please open a new issue to report a bug or to propose a new feature or enhancement.</p> <p>If you would like to contribute your own bugfixes or code enhancements, start by forking this repo, and cloning it into your local workspace.</p> <p>Note</p> <p>Note that all work should be done off of the <code>dev</code> branch</p>"},{"location":"contrib/#setting-up-a-development-environment","title":"Setting up a Development Environment","text":"<p>The EnderChest development environment is managed using conda. If you don't have one already, I highly recommend using a conda-forge-based distribution, such as mambaforge.</p> <p>Once you have conda installed and your fork cloned to your local workspace, navigate to that workspace and:</p> <ol> <li>Create the development environment via    <pre><code>mamba env create\n</code></pre>    (substitute <code>conda</code> if you so choose)</li> <li>Install the package in editable mode:    <pre><code>python -m pip install --user -e .[test]\n</code></pre></li> <li>Set up pre-commit:    <pre><code>pre-commit install\n</code></pre></li> </ol> <p>Note</p> <p>The developemnt environment specifies <code>rsync</code> as a dependency, and there is currently no build of rsync available for Windows. If you are developing from Windows, you will either need to do your development within WSL or comment out that line and install rsync yourself.</p> <p>Once that's done, start developing! Pre-commit is a fantastic tool that will take care of most style-guide enforcement for you, but details are below.</p>"},{"location":"contrib/#style-guide","title":"Style Guide","text":"<p>EnderChest follows the standard Python style guides, most notably PEP8, targeting the Python 3.10 feature set. The one exception is that the line length maximum is set to 88, not 79. All non-trivial and \"public\" functions must have docstrings in the NumPy style.</p> <p>All code should be fully type-hinted, leveraging the latest changes introduced to the language. Favor use of <code>| None</code> \u2705 instead of <code>Optional</code> \u274c and built-in types (<code>list</code>, <code>tuple</code> \u2705) over their capitalized types (<code>from typing import List, Tuple</code> \u274c).</p> Type Hinting Pro Tip <p>A good practice to follow when using type hints is to make your return hints as specific and explicit as possible while making your parameter hints as broad as the function will allow. For example: <pre><code>from typing import Any, Collection\n\n\ndef stringify_dedupe_and_sort(sort_me: Collection[Any]) -&gt; list[str]:\n    \"\"\"Take a collection of stuff, turn them all into strings, remove\n    any duplicates, and then return the results sorted in alphabetical\n    (lexical?) order\n\n    Parameters\n    ----------\n    sort_me : list-like\n        The things you want to sort\n\n    Returns\n    -------\n    list of str\n        The stringified, deduped and sorted items\n\n    Notes\n    -----\n    @ me if you want to see this implemented via a one-line comprehension!\n    \"\"\"\n    return_me: list[str] = []\n    for value in sort_me:\n        stringified: str = str(value)\n        for i, existing_value in enumerate(return_me):\n            if existing_value &gt; stringified:\n                return_me.insert(i, stringified)\n                break\n            elif existing_value == stringified:\n                break\n            else:\n                pass\n        else:\n            return_me.append(stringified)\n\n    return return_me\n</code></pre> In the above, <code>sort_me</code> could be a list of strings, a set of <code>Path</code>s, or really any group of objects that you can iteratethrough and that has a defined length (and even that isn't even technically a requirement). Meanwhile on the output side, you're defining right off the bat that <code>return_me</code> is going to be a list and then enforcing that every member will be a string.</p> <p>There are a variety of other style conventions, especially around non-Python files, but they will be automatically enforced by pre-commit.</p>"},{"location":"contrib/#unit-testing","title":"Unit Testing","text":"<p>While unit tests are not globally required, any PR will require validation that the changes introduced are performing as intended (see below), and unit tests are a great way to provide that, especially given that EnderChest is meant to run across a wide variety of platforms. EnderChest uses py.test as its test runner, and a wide variety of testing utilities and fixtures are available for you to leverage for help mocking out file systems.</p>"},{"location":"contrib/#tests-requiring-ssh","title":"Tests Requiring SSH","text":"<p>SFTP syncing was originally tested against an SSH server running locally that could be authenticated against passwordlessly. To remove the requirement that developers have their systems set up similarly, these tests now default to mocking the calls to paramiko using cached SFTP attributes.</p> <p>If you make any changes or additions to the \"remote\" file system used by these tests, this cache will need to be regenerated, and for that you will need to set up SSH for local passwordless authentication.</p> <p>Tip</p> <p>A good example for configuring key-based passwordless SSH on a POSIX system can be found in our GitHub Actions.</p> <p>The current procedure to regenerate that cache is:</p> <ol> <li>Un-comment this unit test</li> <li>Run    <pre><code>pytest enderchest/test/test_sync.py::TestSFTPSync::test_generate_lstat_cache --use-local-ssh\n</code></pre></li> <li>Re-comment-out that test, then make sure the cache is working by running    <pre><code>pytest -vvx enderchest/test/test_sync.py::TestSFTPSync\n</code></pre></li> <li>If all tests pass when using the cache, then make sure to <code>git add</code> the    regenerated testing file and include it in your next commit</li> </ol>"},{"location":"contrib/#documentation","title":"Documentation","text":"<p>In addition to internal (docstring) documentation, the EnderChest project includes HTML documentation hosted on GitHub Pages. This includes the static guides (that you are literally reading right now) as well as dynamically-generated HTML docs.</p> <p>The tool that performs this magic is called MkDocs and is included in the EnderChest development environment. One of MkDocs' killer] features is its ability to quickly render and serve the documentation locally. To do this, navigate your terminal to the repo root, activate your EnderChest environment and run the command:</p> <pre><code>mkdocs serve\n</code></pre> <p>and the terminal will soon contain a link (typically to http://127.0.0.1:8000/) where you can preview the documentation.</p> <p>When developing EnderChest, you should both check the compiled API docs based on your docstrings (and changes to the CLI) to ensure that everything is rendering as it should.</p>"},{"location":"contrib/#development-workflow","title":"Development Workflow","text":"<p>EnderChest development follows Gitflow, with all development done on feature-branches created off the <code>dev</code> branch.</p> <p>Once a significant number of changes have been merged into <code>dev</code> (usually the culmination of a milestone), a staging branch will be created off of <code>dev</code>, and a PR will be opened targeting merging changes from that branch into <code>release</code>. This process is typically accompanied by the creation of release candidate versions which are built and uploaded to PyPI for pre-release testing. During this phase, changes will be made directly to the staging branch to fix any bugs or regressions that come up during testing.</p> <p>Once it's time to cut a release,</p> <ol> <li>The staging PR will be merged into <code>release</code>.</li> <li> <p>A new release will    be created targeting the <code>release</code> branch and with a tag of the form    <code>v0.x.y</code>. The release notes should highlight the    significant changes in the new version, and the auto-generated release notes    should be modified to cover the period from the last full release    (as opposed to just the last release candidate).</p> <p>Tip</p> <p>Create draft release notes when cutting the first release candidate so that you can just copy them into the full release</p> </li> <li> <p>Cutting the new release will automatically push a new package build to    pypi and    update the docs.</p> </li> <li>Once the release is complete, the <code>dev</code> branch must be rebased on top of    <code>release</code>. This serves two goals:    - it applies any changes committed directly to the staging branch to <code>dev</code>    - it keeps the commit history linear (and makes it much easier to calculate)      the number of commits in <code>dev</code> since the last release.</li> </ol>"},{"location":"contrib/#opening-a-pr","title":"Opening a PR","text":"<p>Once you're ready to contribute your code change back, open a PR (remember to target the <code>dev</code> branch unless this is a hotfix), fill out the PR template, and then tag @OpenBagTwo for review.</p>"},{"location":"contrib/#license","title":"License","text":"<p>This project--the executable, source code and all documentation--are published under the GNU Public License v3, and any contributions to or derivatives of this project must be licensed under compatible terms.</p>"},{"location":"installation/","title":"Installation","text":"<p>EnderChest has minimal package dependencies and should run on pretty much any computer or operating system. It does require Python 3.10 or greater, portable distributions (read: no need for admin privileges) of which are available through miniconda and mambaforge.</p> <p>You can check your Python version by opening a terminal and running: <pre><code>python3 -V\n</code></pre></p> <p>Warning</p> <p>Because of EnderChest's heavy reliance on symlinks, Windows users are required to turn on Developer Mode. Read more here.</p>"},{"location":"installation/#installing-enderchest","title":"Installing EnderChest","text":"<p>The recommended way to install EnderChest is via <code>pipx</code>: <pre><code>pipx install enderchest[test]\n</code></pre></p> <p>If you can't install <code>pipx</code> on your system or if your system Python is too old, you can use a conda environment instead following the instructions in the next section. If you prefer to use <code>pip</code> directly with the system Python, skip to this section.</p>"},{"location":"installation/#creating-a-conda-environment","title":"Creating a conda environment","text":"<p>These instructions assume that you've already downloaded and installed miniforge or another conda distribution and that mamba/conda is already registered to your system path.</p> <ol> <li> <p>Open a terminal (miniforge prompt on Windows) and create a new virtual environment via:    <pre><code>mamba create -n enderchest \"python&gt;=3.10\" \"pip&gt;22\"\n</code></pre>    (substitute <code>conda</code> for <code>mamba</code> as needed)</p> </li> <li> <p>Activate your new environment:     <pre><code>conda activate enderchest\n</code></pre></p> </li> </ol> <p>Then continue onto the next section.</p>"},{"location":"installation/#installation-via-pip","title":"Installation via pip","text":"<ol> <li> <p>Install <code>enderchest</code> from PyPI using pip:     <pre><code>python3 -m pip install --user enderchest[test]\n</code></pre></p> <p>Optional</p> <p>If you plan on connecting to any remote servers via SFTP instead of <code>rsync</code>, include the <code>sftp</code> extra:  <pre><code>python3 -m pip install --user enderchest[sftp,test]\n</code></pre></p> </li> <li> <p>Ensure that EnderChest is compatible with your system by running:     <pre><code>enderchest test\n</code></pre>     If all tests pass, then you're good to go!</p> </li> </ol> <p>Tip</p> <p>If you'd like <code>enderchest</code> to be available outside of your virtual environment, you can copy the executable to somewhere within your system path, e.g. for Linux, starting with the virtual environment deactivated: <pre><code>$ echo $PATH\n/home/openbagtwo/.mambaforge/condabin:/home/openbagtwo/.local/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/sbin\n$ conda activate enderchest\n$ which enderchest\n/home/openbagtwo/.mambaforge/envs/enderchest/bin/enderchest\n$ cp /home/openbagtwo/.mambaforge/envs/enderchest/bin/enderchest ~/.local/bin/\n</code></pre></p>"},{"location":"installation/#installing-rsync","title":"Installing <code>rsync</code>","text":"<p>EnderChest's preferred syncing protocol is <code>rsync</code>, and to use EnderChest with <code>rsync</code> you'll need version 3.2 or newer.</p> <p>You can check if a sufficiently recent version of <code>rsync</code> is installed on your system by running the command:</p> <pre><code>rsync -V\n</code></pre> <p>If you get a message back stating: <code>rsync: -V: unknown option</code>, then your <code>rsync</code> is too old (you can confirm this by running <code>rsync --version</code>), and you'll need to follow the instructions below to get a more modern version installed:</p>"},{"location":"installation/#conda-macos-and-linux","title":"Conda (macOS and Linux)","text":"<p>If you've already installed EnderChest in a conda-managed virtual environment, following the instructions above, conda builds of <code>rsync</code> are available for Mac and Linux and can be installed within your virtual environment via:</p> <p><pre><code>conda activate enderchest\nmamba install rsync\n</code></pre> (substituting <code>conda</code> for <code>mamba</code> if needed).</p>"},{"location":"installation/#other-options-for-macos","title":"Other options for macOS","text":"<p>You can (and, honestly, should) upgrade your system's rsync installation via homebrew or MacPorts</p>"},{"location":"installation/#windows","title":"Windows","text":"<p>Use of <code>rsync</code> on Windows is not currently supported, though it may be possible using Cygwin or WSL.</p> <p>Luckily, other protocols are available, though they may require re-installing EnderChest with additional extras, i.e.</p> <pre><code>pipx install enderchest[sftp]\n</code></pre>"},{"location":"installation/#bleeding-edge","title":"Bleeding Edge","text":"<p>If you'd like to test out upcoming features or help with beta testing, you can install from the current development branch via:</p> <pre><code>python3 -m pip install --user git+https://github.com/OpenBagTwo/EnderChest.git@dev#egg=enderchest[test,sftp]\n</code></pre> <p>Be warned that any code on this branch is considered highly experimental. As always, make sure to regularly back up any important data you're managing with this tool.</p>"},{"location":"suggestions/","title":"Best Practices and Suggested Workflows","text":""},{"location":"suggestions/#other-syncing-protocols","title":"Other Syncing Protocols","text":"<p>If you can't or don't want to use rsync, EnderChest supports additional protocols (and has plans for more).</p>"},{"location":"suggestions/#sftp-protocol","title":"SFTP Protocol","text":"<ul> <li>Scheme: <code>sftp://</code></li> <li>Example URI: <code>sftp://deck@steam-deck/home/deck/minecraft</code></li> <li>Platforms: All (see note)</li> <li>Documentation</li> </ul> <p>Installing EnderChest with sftp support uses Paramiko, a pure-Python SSH implementation, to allow you to connect to remote EnderChests over SSH from machines where rsync (or even SSH) isn't available.</p> <p>SSH on Windows</p> <p>While Paramiko can provide a client for initiating file syncs with remote EnderChests over SFTP, in order to use a Windows machine as a remote for connecting from other EnderChests, you will need to install and configure OpenSSH for Windows or a similar solution.</p> <p>For example, say you have an ROG Ally running Windows and a Steam Deck running SteamOS. With EnderChest installed on both machines, you can get away with not running an SSH server on Windows by running all of your <code>open</code> and <code>close</code> operations from the Ally (just remember to run <code>place</code> on the Steam Deck afterwards to refresh any linking changes).</p>"},{"location":"suggestions/#file-protocol","title":"File Protocol","text":"<ul> <li>Scheme: <code>file://</code></li> <li>Example URI: <code>file:///C:/Users/openbagtwo/My%20Minecraft%20Stuff</code></li> <li>Platforms: All</li> <li>Documentation</li> </ul> <p>You can use this protocol to have EnderChest sync between two folders on the same machine. This can be useful if you're using a service like Dropbox or Google Drive that automatically backups and synchronizes files in a specific directory, and where using <code>enderchest open</code> to pull the files out of that shared drive before using them can help avoid conflicts and corruption.</p> <p>Limitation</p> <p>EnderChest does not support using the file protocol to sync files between different computers, nor does it support authenticating as different users.</p>"},{"location":"suggestions/#suggested-shulker-box-layouts","title":"Suggested Shulker Box Layouts","text":""},{"location":"suggestions/#hierarchical","title":"Hierarchical","text":"<p>My personal strategy for effective, collision-free linking is to break down one's Minecraft playing habits into a classification hierarchy:</p> <ol> <li>These are the things I will want every time I play Minecraft</li> <li>These are the things I'll want whenever I want to play a certain kind of    Minecraft</li> <li>These are the things I'll want whenever I'm playing this particular    Minecraft</li> <li>These are the things I only want when I'm playing Minecraft on this    particular computer.</li> </ol> <p>Remember that EnderChest respects a priority order you set on each shulker box, with lower priority boxes getting linked first, and higher priority ones overwriting any links created by the earlier boxes. Use this when thinking about what kinds of boxes to create, and about what items to put in each box.</p> <p>Pro Tip</p> <p>It's a good idea to give each Shulker Box a unique priority value. It's an even better idea to start off by making these priorities, say, multiples of 10 or 100 so that later on you can easily slot in new boxes without having to change the priority of every other box.</p> <p>For example, here is how I have my boxes laid out (the number at the start is their priority values):</p> <ul> <li> <p>(-20) Global: This shulker box is configured to link to everything and   contains my <code>usercache.json</code> and <code>usernamecache.json</code> files, a bunch of   resource packs that work across  a wide swath of Minecraft versions,   as well as the \"Standard\" linked folders (backups, logs, crash reports,   screenshots, etc.)</p> <p>Note</p> <p>If you're creating your shulker box through the command-line interface, this is pretty much the only sort of box where I'd recommend selecting the \"Global\" set of linked-folders.</p> </li> </ul> <p>This is also where I have a baseline <code>options.txt</code> file. It's almost certain    to get replaced in the actual instance, but it saves me so much aggravation    to be able to create and onboard a new instance and not have to remember to    turn off <code>autoJump</code> before hopping into a world.</p> <ul> <li> <p>(-10) Shaders: Because shaders tend to be compatible across pretty much any   supported Minecraft version, this box is set up to link with any instance   that has Optifine or Iris installed, which for me is just anything   non-vanilla, so the <code>shulkerbox.cfg</code> looks like:   <pre><code>[minecraft]\n*\n\n[modloader]\nforge\nfabric-like\n</code></pre>   I also have another box ((-11) Modconfigs) where I put baseline configuration   files for mods where the config format hasn't changed or is   generally backwards / forwards compatible (so things like \"Replay Mod: don't   record single-player by default\" or   \"IndyPets: pets should not be independent   by default\"). Even though not every instance linked will use these configs,   the files won't hurt anything by being there.</p> </li> <li> <p>(0) 1.20, and also:</p> <ul> <li>(1) 1.12</li> <li>(2) 1.16</li> <li>(3) 1.18</li> <li>(4) 20w14infinite</li> <li>(5) 23w13a_or_b</li> </ul> <p>these version-specific shulker boxes contain all the resource packs that were built for just those Minecraft versions along with customized <code>options.txt</code> files that overwrite the one in the \"(-20) Global\" box. The last two boxes also contain the worlds for those versions, since it's not like there are modpacks for the April Fool's updates.</p> </li> <li> <p>(10) 1.20 Quilt, and also:</p> <ul> <li>(11) 1.12 Forge</li> <li>(12) 1.16 Forge</li> <li>(13) 1.18 Fabric</li> <li>(14) 1.18 Forge</li> </ul> <p>these boxes contain the optimization, performance and other \"no regrets\" mods that I would always want installed for that version and modloader: things like Optifine, Sodium, Iris, Replay Mod, Shulker Box Tooltip, etc.</p> </li> <li> <p>(100) Better End, and also:</p> <ul> <li>(110) Fox Nap</li> </ul> <p>Note</p> <p>See how I jumped from priority 13 to 100? This is to make sure that there's plenty of space for future Minecraft version x modloader combos.</p> <p>This next level is for mods that I use across different instances but maybe not all instances for a given loader and version. The matching is done via tag (as well as version and loader), and I have at times had sub-boxes (Better End 1.18, 1.19, 1.20; Fox Nap 1.19.0, 1.19.2, 1.19.3) to contain the most up-to-date mod-specific builds while the configuration files go in the main box.</p> </li> <li> <p>(200)-(299) Instance-specific boxes. Each instance then gets their own box that     explicitly specifies each mod going into that instance, along with any     tweaked options or configuration files.</p> </li> <li> <p>(300) Battlestation.local, and also:</p> <ul> <li>(310) Couch-Gamer.local</li> <li>(320) Steam-Deck.local</li> </ul> <p>These boxes contain computer-specific optimizations, such as overriding shaderpack settings and changing keybindings. These have the highest priority so as to get applied last (and consequently, I'll also sometimes have instance-specific, machine-specific boxes that further tweak these settings). You may find you have better luck giving \"local\" boxes lower priority (in the -10 range) and then having your instance/machine-specific tweaks set at the instance or modpack priority level.</p> </li> </ul> <p>And yes, at the end of the day, I end up with a lot of boxes (45 as of this writng). And since the  system relies on links overwriting links as you go from broad to specific, it can be difficult to trace back where an individual file actually comes from or which other instances it is shared with.</p> <p>But the advantage is that when I get notified that there's version of a mod, I know exactly where to put it so that the right instances get the new build, and the same goes for settings--I make a tweak to my Do A Barrel Roll settings? It gets automatically applied to every Minecraft instance that works with that config.</p>"},{"location":"suggestions/#chest-monster","title":"Chest Monster","text":"<p>The polar opposite of the careful hierarchical approach takes advantage of the ability of symlinks to point to other symlinks.</p> <p>This strategy relies on having a non-shulker-box folder that gets synced within your EnderChest that contains every single mod, resource pack, world, config file, etc. that you want to use, and every version or permutation of each of those files (so, for example, you could have <code>options.basic.txt</code> alongside an <code>options.controller.txt</code> that remaps keybinds for instances running on the Steam Deck or other handhelds).</p> <p>Tip</p> <p>Name your Chest Monster something like \"_Chest Monster\" so that it shows up first (or last) when viewing your EnderChest contents alphabetically</p> <p>From there, you then create a shulker box for each instance that contains symlinks pointing into the files that live in the EnderChest (e.g. <code>instance_shulker/options.txt -&gt; _Chest Monster/options files/basic_options.txt</code>).</p> <p>Each instance will probably want to use the \"Global\" set of linked folders so that when an instance generates new screenshots, logs, crash reports, etc., they go into the EnderChest, and by making the \"folders\" inside of the shulker boxes symlinks themselves, they can point into either shared or separated folders within the Chest Monster, i.e.</p> <ul> <li><code>instance_shulker/saves -&gt; _Chest Monster/worlds</code>, vs.</li> <li><code>instance_shulker/saves -&gt; _Chest Monster/worlds/instance's worlds</code></li> </ul> <p>This strategy has the advantage of ensuring that there are no linking conflicts, as in its purest form, each instance is linked to only one chest, and onboarding an existing instance following this approach is comparatively straightforward--just move all of the instance's contents into the shulker box, then move each file one-by-one from the shulker into the Chest Monster, putting a link in the shulker box in the place of each file.</p> <p>The downside, however, is that this process needs to be carried out every time there's a new instance, and replacing a mod with a newer version of that mod requires updating every single link in each of your shulker boxes.</p> <p>Pro Tip</p> <p>If you remove the build and mod-version information from a mod's filename, then when you replace that file with a newer build, all the existing links will still work.</p> <p>You can also accomplish a similar effect by creating symlinks named <code>&lt;mod&gt;.&lt;minecraft_version&gt;.latest.jar</code> that point to the actual latest version. Then you can have the links in your shulker boxes safely point to that \"latest\" file, and when you upgrade the mod, you only need to update one symlink.</p> <p>The other downside is that you can end up with \"orphaned\" files in your Chest Monster that are no longer linked to by any shulker box.</p> <p>There are, of course, hybrid approaches (for example, even though I mostly follow the hierarchical approach for my instances, all of my worlds actually live within structured folders inside of a \"Chest Monster\" for ease of backup management), and if you come up with a different workflow that works for you, I'd be delighted to hear about it.</p>"},{"location":"suggestions/#effective-syncing","title":"Effective Syncing","text":""},{"location":"suggestions/#passwordless-ssh-authentication","title":"Passwordless SSH Authentication","text":"<p>When connecting to an SSH server (rsync / sftp), it is both more secure and more convenient to use public key authentication instead of a password. Instructions for setting up pubkey authentication can be found here for Windows and here for macOS and Linux</p>"},{"location":"suggestions/#pointing-links-outside-of-your-enderchest","title":"Pointing Links Outside of Your EnderChest","text":"<p>While link-folders (entire folders inside of your shulker box that are linked to from your Minecraft instances) are great for centralizing things like backups, logs, and crash reports that you probably don't need to have split by instance, you probably don't need to sync them across different computers. My suggestion is to structure your minecraft folder (the parent of your EnderChest folder) as follows:</p> <pre><code>&lt;minecraft root&gt;: a single folder where all your minecraft data will live\n \u251c\u2500\u2500 instances: your MultiMC-type instances (most launchers let you set a custom location)\n \u251c\u2500\u2500 backups\n \u251c\u2500\u2500 crash reports\n \u251c\u2500\u2500 logs\n \u251c\u2500\u2500 EnderChest: the root directory for all resources managed by this package\n \u2502   \u251c\u2500\u2500 global: shulker box that links to all instances\n \u2502   \u2502   \u251c\u2500\u2500 backups \u21b5 -&gt; ../../../backups\n \u2502   \u2502   \u251c\u2500\u2500 crash-reports \u21b5 -&gt; ../../../crash reports\n \u2502   \u2502   \u251c\u2500\u2500 logs \u21b5 -&gt; ../../../logs\n \u2502   \u2502   \u251c\u2500\u2500 screenshots \u21b5 -&gt; ~/Pictures/minecraft screenshots\n</code></pre> <p>Since backups, crash reports, logs and, in my example, screenshots, live outside of the Enderchest, the contents won't actually be synced. Meanwhile, because the links themselves do sync, and because I've used relative links, this EnderChest configuration will work on any EnderChest installation that uses this folder structure, and all without needing to muck with the <code>do-not-sync</code> settings in the config file!</p>"},{"location":"suggestions/#keeping-local-boxes-local","title":"Keeping Local Boxes Local","text":"<p>EnderChest's default behavior is to sync all shulker boxes across all installations, even if that shulker box won't be used on other machines. This is done so that your local files are backed up and available for reference wherever you're playing Minecraft.</p> <p>But if you have a lot of EnderChests and a lot of local-only shulker boxes, that might not be something that you want, at least not on every machine.</p> <p>To exclude a folder (or file) from sync, open your <code>enderchest.cfg</code> file (inside your EnderChest folder). Inside the top <code>[properties]</code> section you should see an entry named \"do-not-sync\". By default it should look like this:</p> <pre><code>do-not-sync =\n        EnderChest/enderchest.cfg\n        EnderChest/.*\n        .DS_Store\n</code></pre> <p>If there's a shulker box you want to exclude from syncing, just add it on a new line (prefixing it with <code>EnderChest/</code> will help ensure that you're not excluding files with that name in other boxes).</p> <p>Pro Tip</p> <p>If you use a consistent naming convention, such as giving all of your local-only shulker boxes names that end in \".local\", you can exclude them all at once by adding the line: <pre><code>EnderChest/*.local\n</code></pre></p> <p>Note that this \"do-not-sync\" list is only obeyed for sync commands run from the lcoal machine / EnderChest--this means that while running <code>enderchest close</code> from one machine may exclude a shulker box from being pushed, running <code>enderchest open</code> from that that other machine may grab that box anyway.</p>"},{"location":"suggestions/#version-control-with-git","title":"Version control with Git","text":"<p>As mentioned above, if a folder in your EnderChest is prefixed with a \".\" then EnderChest by default will not sync it with other machines or place links into that folder. One reason for this is to make it easier to create incremental backups and put your configurations under full version control using something like Git.</p> <p>If you navigate into your EnderChest folder and run the command</p> <pre><code>git init\n</code></pre> <p>then assuming you have Git installed on your system, it will turn your entire EnderChest into a repository and store its version history in the hidden \".git\" folder. This isn't the place for a full tutorial, but a handy cheat-sheet of the basic <code>git</code> commands can be found here.</p> <p>The relevant section for you is the one that reads \"Make changes.\" You probably don't want to be pushing your EnderChest (which probably contains a large number of very large files) to GitHub, though adding the ability for EnderChest to sync between installations directly via the Git protocol is definitely under consideration.</p> <p>Shameless Plug</p> <p>If you like the idea of version controls and backups but are intimidated by the complexity of Git, have a look at one of my other projects: Game Save Backups, which distills the all the essential backup management operations down to a few simple verbs.</p> <p>Tip</p> <p>If following the Chest Monster approach, you may want to add the Chest Monster's folder to your <code>.gitignore</code> file to prevent changes from being tracked (I personally prefer to manage my world-save backups separately using <code>gsb</code>)</p>"},{"location":"suggestions/#launcher-integration","title":"Launcher Integration","text":""},{"location":"suggestions/#startup-and-shutdown-scripts","title":"Startup and Shutdown Scripts","text":"<p>Launchers like PrismLauncher can be configured to run commands before an  instance is launched or after it's closed. Consider putting <code>enderchest open /path/to/minecraft_root</code> in your startup scripts and <code>enderchest close /path/to/minecraft_root</code> in your shutdown scripts (where \"minecraft_root\" is the location where you usually run the enderchest commands, i.e. the parent of your EnderChest folder.</p>"},{"location":"usage/","title":"Quick-Start Guide","text":"<p>This is a brief guide to getting an EnderChest set up and linking. It covers the most important command-line operations and how to make best use of shulker boxes.</p>"},{"location":"usage/#locating-your-minecraft-instances","title":"Locating Your Minecraft Instances","text":"<p>Before setting up an EnderChest, it's a good idea to take a minute and figure out where all of your Minecraft data is actually stored. This will vary based on your operating system and the launchers you use. This document, for example, tells you how to find the official launcher data. MultiMC-derived programs like PrismLauncher will often have a \"Folder\" button that will take you to the location of each instance, which is especially helpful for the flatpak distribution.</p>"},{"location":"usage/#selecting-a-minecraft-root","title":"Selecting a \"Minecraft Root\"","text":"<p>Once you have the lay of the land, the next thing you'll want to do is decide where you want your EnderChest folder to live. This could be your home folder (<code>~</code> or <code>C:\\Users\\yourusername\\</code>, in the folder containing your MultiMC <code>instances</code> directory, or anywhere that's convenient for you. Go to that directory in your terminal.</p> <p>Tip</p> <p>You can run any EnderChest command from any location by explicitly specifying the Minecraft root, e.g. <pre><code>enderchest craft --root /path/to/my_minecraft_stuff\n</code></pre></p> <p>Tip</p> <p>You can also specify your Minecraft root by using an enviroment variable. <pre><code>export MINECRAFT_ROOT=/path/to/my_minecraft_stuff\n</code></pre></p>"},{"location":"usage/#creating-an-enderchest","title":"Creating an EnderChest","text":"<p>When ready, run the command:</p> <pre><code>enderchest craft\n</code></pre> <p>to begin the guided setup process. This process will ask you about directories to look for Minecraft installations inside. Note that these will be the folders containing <code>.minecraft</code>, not the <code>.minecraft</code> folders themselves.</p> <p>You'll also be prompted for the address of another EnderChest installation you want to sync with. For now, I'll assume that this is your first EnderChest, so leave that answer blank. When you're ready to create another EnderChest on another machine, the Managing Remotes section will have you covered.</p> <p>Once the installer finishes, you'll end up with a new folder inside your current directory (or Minecraft root) named EnderChest along with a file inside that folder named <code>enderchest.cfg</code>. Feel free to open up that file in your favorite text editor and take a look. It's designed to be easily edited to make it easy to, for example, manually add a tag to an instance.</p> <p>Info</p> <p>When a given entry can have multiple values, you can separate those values by commas, e.g. <pre><code>tags = vanilla_plus, modded, sodium\n</code></pre> or by putting each entry on its own (indented) line, e.g. <pre><code>tags =\n    aether\n    modded\n    optifine\n</code></pre></p>"},{"location":"usage/#registering-additional-instances","title":"Registering Additional Instances","text":"<p>Once you have an EnderChest installed, you can register additional instances at any time by using the <code>gather</code> action. Running:</p> <pre><code>enderchest gather instance &lt;path&gt;\n</code></pre> <p>will recursively search the provided directory for folders named <code>.minecraft</code> and attempt to register them.</p> <p>Tip</p> <p>You can control how much information gets displayed when running EnderChest commands by using the <code>--verbose</code> (<code>-v</code>) and <code>--quiet</code> (<code>-q</code>) flags.</p>"},{"location":"usage/#creating-shulker-boxes","title":"Creating Shulker Boxes","text":"<p>Once you've populated your EnderChest configuration with all the Minecraft instances you want to manage, it's time to start crafting shulker boxes.</p> <p>Running:</p> <pre><code>enderchest craft shulker_box &lt;name&gt;\n</code></pre> <p>will take you through a guided setup that will let to control how your shulker box will know which instances will link to it along with what other remote EnderChest installations will use it. At the conclusion of the process you'll end up with a folder within your EnderChest that's pre-populated so as to mirror what you'd see in a <code>.minecraft</code> folder.</p>"},{"location":"usage/#moving-files-into-your-shulker-box","title":"Moving Files into Your Shulker Box","text":"<p>If you have existing Minecraft installations, now is the time to start moving the assets from those instances into your shulker box. Just put them in the exact same place inside the shulker box that they'd be inside of <code>.minecraft</code> (so resource packs go in <code>resourcepacks</code>, worlds go in <code>saves</code>, etc.)</p>"},{"location":"usage/#linking-entire-folders","title":"Linking Entire Folders","text":"<p>During the shulker box creation process, you were prompted to select any folders that you wanted to symlink whole-hog. This is useful for things like screenshots or logs where files will be generated by the instance and not just accessed or updated.</p> <p>Important!</p> <p>By default, for the purposes of linking EnderChest treats any folder that's not at the top level (e.g. <code>saves/my world</code>) as a file that's symlinked in its entirety. You can change this behavior by setting the <code>max-link-depth</code> parameter in the shulker box config, but doing so should be considered highly experimental.</p>"},{"location":"usage/#linking-your-instances","title":"Linking Your Instances","text":"<p>Once everything is set up, to actually link up all of your instances, you just need to run:</p> <pre><code>enderchest place\n</code></pre> <p>Important!!</p> <p>Starting with Minecraft 1.20, Mojang by default no longer allows worlds to load if they are or if they contain symbolic links. Obviously this will be a problem if you're using EnderChest to centralize and organize your world saves.</p> <p>By default, EnderChest will offer to create an <code>allowed_symlinks.txt</code> folder inside any 1.20+ instance that doesn't have one already and update the file to blanket-allow symbolic links into your EnderChest.</p> <p>If you would prefer to do this by hand or not at all, you can edit your <code>enderchest.cfg</code> and change the value for <code>offer-to-update-symlink-allowlist</code> to <code>False</code>. EnderChest will never create any file or symlink without your consent and will never place a symlink pointing directly to a place outside of your EnderChest.</p> <p>If you would like to get a full report of all symlinks EnderChest places, you can run: <pre><code>enderchest place --verbose\n</code></pre> to get a full audit.</p> <p>As EnderChest places all your links, it will stop if at any point there's already a file or a non-empty folder at that location. Sometimes that happens because you forgot to clean out an existing instance. Other times, your shulker box configurations might be conflicting with each other. Regardless, rather than just overwriting your data, EnderChest will ask you how you want to proceed. And once you've fixed the issue, you can just run</p> <pre><code>enderchest place\n</code></pre> <p>again--running <code>place</code> multiple times is completely safe (and is something you should do regularly! and particularly after any shulker box modification or file sync!).</p>"},{"location":"usage/#managing-remotes","title":"Managing Remotes","text":"<p>Once you've finished setting up an EnderChest on a given computer, the next thing to consider is setting it up on another one. To do that, you'll need to set up some form of file transfer. EnderChest's preferred transfer protocol is <code>rsync</code>, an extremely efficient open source tool for performing backups and generally moving files between two locations. Most Linux distributions (including SteamOS) come with a sufficiently recent version of <code>rsync</code> preinstalled (EnderChest requires <code>rsync</code> 3.2 or newer), and Mac users can upgrade their <code>rsync</code> easily via homebrew, MacPorts or conda.</p> <p>Windows users may be able to get EnderChest working with <code>rsync</code> via Cygwin or WSL, but this is not currently supported, and Windows users may be better off using a different protocol.</p> <p>To register a remote with your EnderChest, you just need to run the following command:</p> <pre><code>enderchest gather enderchests &lt;remote&gt;\n</code></pre> <p>where <code>&lt;remote&gt;</code> is the URI to the remote chest.</p>"},{"location":"usage/#understanding-uris","title":"Understanding URIs","text":"<p>A Uniform Resource Identifier, or URI, is a way of referencing files or folders--oftentimes on other computers-- in a standard way. URLs, like you're familiar with from web browsers, are a type of URI. The format of a URI typically follows the following schema:</p> <pre><code>&lt;protocol&gt;://[[&lt;username&gt;@]&lt;host&gt;[:port]&lt;path&gt;[?&lt;query&gt;]\n</code></pre> <p>The important bits right now are: - the protocol must be one that's supported by both EnderChest and by your machine - the host can be the local IP of your remote machine, but most home routers support   connecting to machines via their hostname. This is much better for users whose   routers don't assign machines statis IP addresses. - the path must be URL encoded to transform special   characters (especially spaces) into a single unambiguous string - the path must be absolute, (and in the URI syntax must start with a <code>/</code>),   starting from the computer or service's root directory (hence the <code>/</code> for   macOS and Linux users) - the path does not point to an EnderChest, but to the folder containing the   EnderChest.</p> <p>As an example, let's say I have an EnderChest installed on my Steam Deck (hostname: \"steamdeck\") directly inside my home directory (so <code>~/EnderChest</code>). If I'm setting up an EnderChest on my couch gaming laptop and want to sync with my Deck, the URI for it will be: <code>rsync://deck@steamdeck/home/deck</code></p> <p>Tip</p> <p>You can use this website to encode any file name or POSIX path as a URI. You can also get the URI to your current directory in Python by running the following code: <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; print(Path().absolute().as_uri())\n</code></pre> While that will give you the <code>file://</code> protocol, URI you can then just replace the <code>file://</code> part (make sure not to grab the third slash!) and replace it with the <code>protocol://[user@]hostname[:port]</code> of your choice.</p>"},{"location":"usage/#syncing","title":"Syncing","text":"<p>Once you have some remote EnderChests set up, the way you sync with them is via the <code>close</code> and <code>open</code> actions:</p> <pre><code>enderchest close\n</code></pre> <p>will push your local changes to all registered remote chests</p> <pre><code>enderchest open\n</code></pre> <p>will pull changes from your other EnderChests while</p> <p>Info</p> <p>Where you have multiple remotes specified, <code>enderchest open</code> will only pull changes from one, prioritizing them in the order that they're listed, and stopping once it manages to sync successfully.</p> <p>In contrast, <code>enderchest close</code> will push changes to all registered remotes.</p> <p>This is useful for when you have EnderChests running on laptops or handhelds that are not always on, or not always on the same network as the other devices, but it means you need to be careful that the first remote listed in your config is the one most likely to be up-to-date.</p> <p>Sync operations are destructive and won't hesitate to wipe out all the files in an EnderChest if you have your remote mis-configured. That's why all sync operations support the <code>--dry-run</code> flag, which lets you preview the operations that will be performed before they're actually run.</p> <p>In fact, by default, all sync operations will perform a dry run first and give you five seconds to review the dry run log and interrupt the sync if things are about to go sideways (documentation for overriding this behavior is available in the CLI docs).</p> <p>Bonus</p> <p>Starting with v0.1.3, after a successful <code>enderchest open</code>, EnderChest will automatically update all of your instances' symlinks, saving you from needing to remember to run:</p> <pre><code>enderchest place\n</code></pre> <p>(this behavior can be disabled by editing the <code>place-after-open</code> setting in your <code>enderchest.cfg</code> file).</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>enderchest<ul> <li>filesystem</li> <li>cli</li> <li>gather</li> <li>instance</li> <li>place</li> <li>prompt</li> <li>config</li> <li>shulker_box</li> <li>remote</li> <li>craft</li> <li>loggers</li> <li>enderchest</li> <li>sync<ul> <li>file</li> <li>utils</li> <li>rsync</li> <li>sftp</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/enderchest/","title":"enderchest","text":"<p>Top-level imports</p>"},{"location":"reference/enderchest/#enderchest.EnderChest","title":"<code>EnderChest</code>  <code>dataclass</code>","text":"<p>Configuration of an EnderChest</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>URI or Path</code> <p>The \"address\" of this EnderChest, ideally as it can be accessed from other EnderChest installations, including both the path to where the EnderChest folder can be found (that is, the parent of the EnderChest folder itself, aka the \"minecraft_root\"), its net location including credentials, and the protocol that should be used to perform the syncing. All that being said, if just a path is provided, the constructor will try to figure out the rest.</p> required <code>name</code> <code>str</code> <p>A unique name to give to this EnderChest installation. If None is provided, this will be taken from the hostname of the supplied URI.</p> <code>None</code> <code>instances</code> <code>list-like of InstanceSpec</code> <p>The list of instances to register with this EnderChest installation</p> <code>None</code> <code>remotes</code> <code>list-like of URI, or (URI, str) tuples</code> <p>A list of other installations that this EnderChest should be aware of (for syncing purposes). When a (URI, str) tuple is provided, the second value will be used as the name/alias of the remote.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The unique name of this EnderChest installation. This is most commonly the computer's hostname, but one can configure multiple EnderChests to coexist on the same system (either for the sake of having a \"cold\" backup or for multi-user systems).</p> <code>uri</code> <code>str</code> <p>The complete URI of this instance</p> <code>root</code> <code>Path</code> <p>The path to this EnderChest folder</p> <code>instances</code> <code>list-like of InstanceSpec</code> <p>The instances registered with this EnderChest</p> <code>remotes</code> <code>list-like of (ParseResult, str) pairs</code> <p>The other EnderChest installations this EnderChest is aware of, paired with their aliases</p> <code>offer_to_update_symlink_allowlist</code> <code>bool</code> <p>By default, EnderChest will offer to create or update <code>allowed_symlinks.txt</code> on any 1.20+ instances that do not already blanket allow links into EnderChest. EnderChest will never modify that or any other Minecraft file without your express consent. If you would prefer to edit these files yourself (or simply not symlink your world saves), change this parameter to False.</p> <code>sync_confirm_wait</code> <code>bool or int</code> <p>The default behavior when syncing EnderChests is to first perform a dry run of every sync operation and then wait 5 seconds before proceeding with the real sync. The idea is to give the user time to interrupt the sync if the dry run looks wrong. This can be changed by either raising or lowering the value of confirm, by disabling the dry-run-first behavior entirely (<code>confirm=False</code>) or by requiring that the user explicitly confirms the sync (<code>confirm=True</code>). This default behavior can also be overridden when actually calling the sync commands.</p> <code>place_after_open</code> <code>bool</code> <p>By default, EnderChest will follow up any <code>enderchest open</code> operation with an <code>enderchest place</code> to refresh any changed symlinks. This functionality can be disabled by setting this parameter to False.</p> <code>do_not_sync</code> <code>list of str</code> <p>Glob patterns of files that should not be synced between EnderChest installations. By default, this list comprises <code>EnderChest/enderchest.cfg</code>, any top-level folders starting with a \".\" (like .git) and <code>.DS_Store</code> (for all you mac gamers).</p> <code>shulker_box_folders</code> <code>list of str</code> <p>The folders that will be created inside each new shulker box</p> <code>standard_link_folders</code> <code>list of str</code> <p>The default set of \"link folders\" when crafting a new shulker box</p> <code>global_link_folders</code> <code>list of str</code> <p>The \"global\" set of \"link folders,\" offered as a suggestion when crafting a new shulker box</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>@dataclass(init=False, repr=False, eq=False)\nclass EnderChest:\n    \"\"\"Configuration of an EnderChest\n\n    Parameters\n    ----------\n    uri : URI or Path\n        The \"address\" of this EnderChest, ideally as it can be accessed from other\n        EnderChest installations, including both the path to where\n        the EnderChest folder can be found (that is, the parent of the\n        EnderChest folder itself, aka the \"minecraft_root\"), its net location\n        including credentials, and the protocol that should be used to perform\n        the syncing. All that being said, if just a path is provided, the\n        constructor will try to figure out the rest.\n    name : str, optional\n        A unique name to give to this EnderChest installation. If None is\n        provided, this will be taken from the hostname of the supplied URI.\n    instances : list-like of InstanceSpec, optional\n        The list of instances to register with this EnderChest installation\n    remotes : list-like of URI, or (URI, str) tuples\n        A list of other installations that this EnderChest should be aware of\n        (for syncing purposes). When a (URI, str) tuple is provided, the\n        second value will be used as the name/alias of the remote.\n\n    Attributes\n    ----------\n    name : str\n        The unique name of this EnderChest installation. This is most commonly\n        the computer's hostname, but one can configure multiple EnderChests\n        to coexist on the same system (either for the sake of having a \"cold\"\n        backup or for multi-user systems).\n    uri : str\n        The complete URI of this instance\n    root : Path\n        The path to this EnderChest folder\n    instances : list-like of InstanceSpec\n        The instances registered with this EnderChest\n    remotes : list-like of (ParseResult, str) pairs\n        The other EnderChest installations this EnderChest is aware of, paired\n        with their aliases\n    offer_to_update_symlink_allowlist : bool\n        By default, EnderChest will offer to create or update `allowed_symlinks.txt`\n        on any 1.20+ instances that do not already blanket allow links into\n        EnderChest. **EnderChest will never modify that or any other Minecraft\n        file without your express consent.** If you would prefer to edit these\n        files yourself (or simply not symlink your world saves), change this\n        parameter to False.\n    sync_confirm_wait : bool or int\n        The default behavior when syncing EnderChests is to first perform a dry\n        run of every sync operation and then wait 5 seconds before proceeding with the\n        real sync. The idea is to give the user time to interrupt the sync if\n        the dry run looks wrong. This can be changed by either raising or lowering\n        the value of confirm, by disabling the dry-run-first behavior entirely\n        (`confirm=False`) or by requiring that the user explicitly confirms\n        the sync (`confirm=True`). This default behavior can also be overridden\n        when actually calling the sync commands.\n    place_after_open: bool\n        By default, EnderChest will follow up any `enderchest open` operation\n        with an `enderchest place` to refresh any changed symlinks. This\n        functionality can be disabled by setting this parameter to False.\n    do_not_sync : list of str\n        Glob patterns of files that should not be synced between EnderChest\n        installations. By default, this list comprises `EnderChest/enderchest.cfg`,\n        any top-level folders starting with a \".\" (like .git) and\n        `.DS_Store` (for all you mac gamers).\n    shulker_box_folders : list of str\n        The folders that will be created inside each new shulker box\n    standard_link_folders : list of str\n        The default set of \"link folders\" when crafting a new shulker box\n    global_link_folders : list of str\n        The \"global\" set of \"link folders,\" offered as a suggestion when\n        crafting a new shulker box\n    \"\"\"\n\n    name: str\n    _uri: ParseResult\n    _instances: list[i.InstanceSpec]\n    _remotes: dict[str, ParseResult]\n    offer_to_update_symlink_allowlist: bool\n    sync_confirm_wait: bool | int\n    place_after_open: bool\n    do_not_sync: list[str]\n    shulker_box_folders: list[str]\n    standard_link_folders: list[str]\n    global_link_folders: list[str]\n\n    def __init__(\n        self,\n        uri: str | ParseResult | Path,\n        name: str | None = None,\n        remotes: Iterable[str | ParseResult | tuple[str, str] | tuple[ParseResult, str]]\n        | None = None,\n        instances: Iterable[i.InstanceSpec] | None = None,\n    ):\n        for setting, value in _DEFAULTS:\n            setattr(self, setting, list(value) if isinstance(value, tuple) else value)\n\n        try:\n            if isinstance(uri, ParseResult):\n                self._uri = uri\n            elif isinstance(uri, Path):\n                self._uri = urlparse(uri.absolute().as_uri())\n            else:\n                self._uri = urlparse(uri)\n        except AttributeError as parse_problem:  # pragma: no cover\n            raise ValueError(f\"{uri} is not a valid URI\") from parse_problem\n\n        if not self._uri.netloc:\n            self._uri = self._uri._replace(netloc=sync.get_default_netloc())\n        if not self._uri.scheme:\n            self._uri = self._uri._replace(scheme=sync.DEFAULT_PROTOCOL)\n\n        self.name = name or self._uri.hostname or gethostname()\n\n        self._instances = []\n        self._remotes = {}\n\n        for instance in instances or ():\n            self.register_instance(instance)\n\n        for remote in remotes or ():\n            if isinstance(remote, (str, ParseResult)):\n                self.register_remote(remote)\n            else:\n                self.register_remote(*remote)\n\n    @property\n    def uri(self) -&gt; str:\n        return self._uri.geturl()\n\n    def __repr__(self) -&gt; str:\n        return f\"EnderChest({self.uri, self.name})\"\n\n    @property\n    def root(self) -&gt; Path:\n        return fs.ender_chest_folder(abspath_from_uri(self._uri), check_exists=False)\n\n    @property\n    def instances(self) -&gt; tuple[i.InstanceSpec, ...]:\n        return tuple(self._instances)\n\n    def register_instance(self, instance: i.InstanceSpec) -&gt; i.InstanceSpec:\n        \"\"\"Register a new Minecraft installation\n\n        Parameters\n        ----------\n        instance : InstanceSpec\n            The instance to register\n\n        Returns\n        -------\n        InstanceSpec\n            The spec of the instance as it was actually registered (in case the\n            name changed or somesuch)\n\n        Notes\n        -----\n        - If the instance's name is already assigned to a registered instance,\n          this method will choose a new one\n        - If this instance shares a path with an existing instance, it will\n          replace that instance\n        \"\"\"\n        matching_instances: list[i.InstanceSpec] = []\n        for old_instance in self._instances:\n            if i.equals(abspath_from_uri(self._uri), instance, old_instance):\n                matching_instances.append(old_instance)\n                self._instances.remove(old_instance)\n\n        instance = i.merge(*matching_instances, instance)\n\n        name = instance.name\n        counter = 0\n        taken_names = {old_instance.name for old_instance in self._instances}\n        while True:\n            if name not in taken_names:\n                break\n            counter += 1\n            name = f\"{instance.name}.{counter}\"\n\n        GATHER_LOGGER.debug(f\"Registering instance {name} at {instance.root}\")\n        self._instances.append(instance._replace(name=name))\n        return self._instances[-1]\n\n    @property\n    def remotes(self) -&gt; tuple[tuple[ParseResult, str], ...]:\n        return tuple((remote, alias) for alias, remote in self._remotes.items())\n\n    def register_remote(\n        self, remote: str | ParseResult, alias: str | None = None\n    ) -&gt; None:\n        \"\"\"Register a new remote EnderChest installation (or update an existing\n        registry)\n\n        Parameters\n        ----------\n        remote : URI\n            The URI of the remote\n        alias : str, optional\n            an alias to give to this remote. If None is provided, the URI's hostname\n            will be used.\n\n        Raises\n        ------\n        ValueError\n            If the provided remote is invalid\n        \"\"\"\n        try:\n            remote = remote if isinstance(remote, ParseResult) else urlparse(remote)\n            alias = alias or remote.hostname\n            if not alias:  # pragma: no cover\n                raise AttributeError(f\"{remote.geturl()} has no hostname\")\n            GATHER_LOGGER.debug(\"Registering remote %s (%s)\", remote.geturl(), alias)\n            self._remotes[alias] = remote\n        except AttributeError as parse_problem:  # pragma: no cover\n            raise ValueError(f\"{remote} is not a valid URI\") from parse_problem\n\n    @classmethod\n    def from_cfg(cls, config_file: Path) -&gt; \"EnderChest\":\n        \"\"\"Parse an EnderChest from its config file\n\n        Parameters\n        ----------\n        config_file : Path\n            The path to the config file\n\n        Returns\n        -------\n        EnderChest\n            The resulting EnderChest\n\n        Raises\n        ------\n        ValueError\n            If the config file at that location cannot be parsed\n        FileNotFoundError\n            If there is no config file at the specified location\n        \"\"\"\n        GATHER_LOGGER.debug(\"Reading config file from %s\", config_file)\n        config = cfg.read_cfg(config_file)\n\n        # All I'm gonna say is that Windows pathing is the worst\n        path = urlparse(config_file.absolute().parent.parent.as_uri()).path\n\n        instances: list[i.InstanceSpec] = []\n        remotes: list[str | tuple[str, str]] = []\n\n        requires_rewrite = False\n\n        scheme: str | None = None\n        netloc: str | None = None\n        name: str | None = None\n        sync_confirm_wait: str | None = None\n        place_after_open: bool | None = None\n        offer_to_update_symlink_allowlist: bool = True\n        do_not_sync: list[str] | None = None\n        folder_defaults: dict[str, list[str] | None] = {\n            \"shulker_box_folders\": None,\n            \"standard_link_folders\": None,\n            \"global_link_folders\": None,\n        }\n\n        for section in config.sections():\n            if section == \"properties\":\n                scheme = config[section].get(\"sync-protocol\")\n                netloc = config[section].get(\"address\")\n                name = config[section].get(\"name\")\n                sync_confirm_wait = config[section].get(\"sync-confirmation-time\")\n                place_after_open = config[section].getboolean(\"place-after-open\")\n                offer_to_update_symlink_allowlist = config[section].getboolean(\n                    \"offer-to-update-symlink-allowlist\", True\n                )\n                if \"do-not-sync\" in config[section].keys():\n                    do_not_sync = cfg.parse_ini_list(\n                        config[section][\"do-not-sync\"] or \"\"\n                    )\n                for setting in folder_defaults.keys():\n                    setting_key = setting.replace(\"_\", \"-\")\n                    if setting_key in config[section].keys():\n                        folder_defaults[setting] = cfg.parse_ini_list(\n                            config[section][setting_key] or \"\"\n                        )\n            elif section == \"remotes\":\n                for remote in config[section].items():\n                    if remote[1] is None:\n                        raise ValueError(\"All remotes must have an alias specified\")\n                    remotes.append((remote[1], remote[0]))\n            else:\n                # TODO: flag requires_rewrite if instance was normalized\n                instances.append(i.InstanceSpec.from_cfg(config[section]))\n\n        scheme = scheme or sync.DEFAULT_PROTOCOL\n        netloc = netloc or sync.get_default_netloc()\n        uri = ParseResult(\n            scheme=scheme, netloc=netloc, path=path, params=\"\", query=\"\", fragment=\"\"\n        )\n\n        ender_chest = EnderChest(uri, name, remotes, instances)\n        if sync_confirm_wait is not None:\n            match sync_confirm_wait.lower():\n                case \"true\" | \"prompt\" | \"yes\" | \"confirm\":\n                    ender_chest.sync_confirm_wait = True\n                case \"false\" | \"no\" | \"skip\":\n                    ender_chest.sync_confirm_wait = False\n                case _:\n                    try:\n                        ender_chest.sync_confirm_wait = int(sync_confirm_wait)\n                    except ValueError as bad_input:\n                        raise ValueError(\n                            \"Invalid value for sync-confirmation-time:\"\n                            f\" {sync_confirm_wait}\"\n                        ) from bad_input\n        if place_after_open is None:\n            GATHER_LOGGER.warning(\n                \"This EnderChest does not have a value set for place-after-open.\"\n                \"\\nIt is being set to False for now. To enable this functionality,\"\n                \"\\nedit the value in %s\",\n                config_file,\n            )\n            ender_chest.place_after_open = False\n            requires_rewrite = True\n        else:\n            ender_chest.place_after_open = place_after_open\n\n        ender_chest.offer_to_update_symlink_allowlist = (\n            offer_to_update_symlink_allowlist\n        )\n\n        if do_not_sync is not None:\n            ender_chest.do_not_sync = do_not_sync\n            chest_cfg_exclusion = \"/\".join(\n                (fs.ENDER_CHEST_FOLDER_NAME, fs.ENDER_CHEST_CONFIG_NAME)\n            )\n            if chest_cfg_exclusion not in do_not_sync:\n                GATHER_LOGGER.warning(\n                    \"This EnderChest was not configured to exclude the EnderChest\"\n                    \" config file from sync operations.\"\n                    \"\\nThat is being fixed now.\"\n                )\n                ender_chest.do_not_sync.insert(0, chest_cfg_exclusion)\n                requires_rewrite = True\n        for setting in folder_defaults:\n            if folder_defaults[setting] is None:\n                folder_defaults[setting] = dict(_DEFAULTS)[setting]  # type: ignore\n                # requires_rewrite = True  # though I'm considering it\n            setattr(ender_chest, setting, folder_defaults[setting])\n\n        if requires_rewrite:\n            ender_chest.write_to_cfg(config_file)\n            return cls.from_cfg(config_file)\n        return ender_chest\n\n    def write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n        \"\"\"Write this EnderChest's configuration to INI\n\n        Parameters\n        ----------\n        config_file : Path, optional\n            The path to the config file, assuming you'd like to write the\n            contents to file\n\n        Returns\n        -------\n        str\n            An INI-syntax rendering of this EnderChest's config\n\n        Notes\n        -----\n        The \"root\" attribute is ignored for this method\n        \"\"\"\n        properties: dict[str, Any] = {\n            \"name\": self.name,\n            \"address\": self._uri.netloc,\n            \"sync-protocol\": self._uri.scheme,\n        }\n        if self.sync_confirm_wait is True:\n            properties[\"sync-confirmation-time\"] = \"prompt\"\n        else:\n            properties[\"sync-confirmation-time\"] = self.sync_confirm_wait\n\n        for setting, _ in _DEFAULTS:\n            if setting == \"sync_confirm_wait\":\n                continue  # already did this one\n            setting_key = setting.replace(\"_\", \"-\")\n            properties[setting_key] = getattr(self, setting)\n\n        remotes: dict[str, str] = {name: uri.geturl() for uri, name in self.remotes}\n\n        instances: dict[str, dict[str, Any]] = {}\n\n        for instance in self.instances:\n            instances[instance.name] = {\n                \"root\": instance.root,\n                \"minecraft-version\": instance.minecraft_versions,\n                \"modloader\": instance.modloader,\n                \"groups\": instance.groups_,\n                \"tags\": instance.tags_,\n            }\n\n        config = cfg.dumps(\n            fs.ENDER_CHEST_CONFIG_NAME, properties, remotes=remotes, **instances\n        )\n\n        if config_file:\n            CRAFT_LOGGER.debug(\"Writing configuration file to %s\", config_file)\n            config_file.write_text(config)\n        return config\n</code></pre>"},{"location":"reference/enderchest/#enderchest.EnderChest.from_cfg","title":"<code>from_cfg(config_file)</code>  <code>classmethod</code>","text":"<p>Parse an EnderChest from its config file</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path</code> <p>The path to the config file</p> required <p>Returns:</p> Type Description <code>EnderChest</code> <p>The resulting EnderChest</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the config file at that location cannot be parsed</p> <code>FileNotFoundError</code> <p>If there is no config file at the specified location</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>@classmethod\ndef from_cfg(cls, config_file: Path) -&gt; \"EnderChest\":\n    \"\"\"Parse an EnderChest from its config file\n\n    Parameters\n    ----------\n    config_file : Path\n        The path to the config file\n\n    Returns\n    -------\n    EnderChest\n        The resulting EnderChest\n\n    Raises\n    ------\n    ValueError\n        If the config file at that location cannot be parsed\n    FileNotFoundError\n        If there is no config file at the specified location\n    \"\"\"\n    GATHER_LOGGER.debug(\"Reading config file from %s\", config_file)\n    config = cfg.read_cfg(config_file)\n\n    # All I'm gonna say is that Windows pathing is the worst\n    path = urlparse(config_file.absolute().parent.parent.as_uri()).path\n\n    instances: list[i.InstanceSpec] = []\n    remotes: list[str | tuple[str, str]] = []\n\n    requires_rewrite = False\n\n    scheme: str | None = None\n    netloc: str | None = None\n    name: str | None = None\n    sync_confirm_wait: str | None = None\n    place_after_open: bool | None = None\n    offer_to_update_symlink_allowlist: bool = True\n    do_not_sync: list[str] | None = None\n    folder_defaults: dict[str, list[str] | None] = {\n        \"shulker_box_folders\": None,\n        \"standard_link_folders\": None,\n        \"global_link_folders\": None,\n    }\n\n    for section in config.sections():\n        if section == \"properties\":\n            scheme = config[section].get(\"sync-protocol\")\n            netloc = config[section].get(\"address\")\n            name = config[section].get(\"name\")\n            sync_confirm_wait = config[section].get(\"sync-confirmation-time\")\n            place_after_open = config[section].getboolean(\"place-after-open\")\n            offer_to_update_symlink_allowlist = config[section].getboolean(\n                \"offer-to-update-symlink-allowlist\", True\n            )\n            if \"do-not-sync\" in config[section].keys():\n                do_not_sync = cfg.parse_ini_list(\n                    config[section][\"do-not-sync\"] or \"\"\n                )\n            for setting in folder_defaults.keys():\n                setting_key = setting.replace(\"_\", \"-\")\n                if setting_key in config[section].keys():\n                    folder_defaults[setting] = cfg.parse_ini_list(\n                        config[section][setting_key] or \"\"\n                    )\n        elif section == \"remotes\":\n            for remote in config[section].items():\n                if remote[1] is None:\n                    raise ValueError(\"All remotes must have an alias specified\")\n                remotes.append((remote[1], remote[0]))\n        else:\n            # TODO: flag requires_rewrite if instance was normalized\n            instances.append(i.InstanceSpec.from_cfg(config[section]))\n\n    scheme = scheme or sync.DEFAULT_PROTOCOL\n    netloc = netloc or sync.get_default_netloc()\n    uri = ParseResult(\n        scheme=scheme, netloc=netloc, path=path, params=\"\", query=\"\", fragment=\"\"\n    )\n\n    ender_chest = EnderChest(uri, name, remotes, instances)\n    if sync_confirm_wait is not None:\n        match sync_confirm_wait.lower():\n            case \"true\" | \"prompt\" | \"yes\" | \"confirm\":\n                ender_chest.sync_confirm_wait = True\n            case \"false\" | \"no\" | \"skip\":\n                ender_chest.sync_confirm_wait = False\n            case _:\n                try:\n                    ender_chest.sync_confirm_wait = int(sync_confirm_wait)\n                except ValueError as bad_input:\n                    raise ValueError(\n                        \"Invalid value for sync-confirmation-time:\"\n                        f\" {sync_confirm_wait}\"\n                    ) from bad_input\n    if place_after_open is None:\n        GATHER_LOGGER.warning(\n            \"This EnderChest does not have a value set for place-after-open.\"\n            \"\\nIt is being set to False for now. To enable this functionality,\"\n            \"\\nedit the value in %s\",\n            config_file,\n        )\n        ender_chest.place_after_open = False\n        requires_rewrite = True\n    else:\n        ender_chest.place_after_open = place_after_open\n\n    ender_chest.offer_to_update_symlink_allowlist = (\n        offer_to_update_symlink_allowlist\n    )\n\n    if do_not_sync is not None:\n        ender_chest.do_not_sync = do_not_sync\n        chest_cfg_exclusion = \"/\".join(\n            (fs.ENDER_CHEST_FOLDER_NAME, fs.ENDER_CHEST_CONFIG_NAME)\n        )\n        if chest_cfg_exclusion not in do_not_sync:\n            GATHER_LOGGER.warning(\n                \"This EnderChest was not configured to exclude the EnderChest\"\n                \" config file from sync operations.\"\n                \"\\nThat is being fixed now.\"\n            )\n            ender_chest.do_not_sync.insert(0, chest_cfg_exclusion)\n            requires_rewrite = True\n    for setting in folder_defaults:\n        if folder_defaults[setting] is None:\n            folder_defaults[setting] = dict(_DEFAULTS)[setting]  # type: ignore\n            # requires_rewrite = True  # though I'm considering it\n        setattr(ender_chest, setting, folder_defaults[setting])\n\n    if requires_rewrite:\n        ender_chest.write_to_cfg(config_file)\n        return cls.from_cfg(config_file)\n    return ender_chest\n</code></pre>"},{"location":"reference/enderchest/#enderchest.EnderChest.register_instance","title":"<code>register_instance(instance)</code>","text":"<p>Register a new Minecraft installation</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>InstanceSpec</code> <p>The instance to register</p> required <p>Returns:</p> Type Description <code>InstanceSpec</code> <p>The spec of the instance as it was actually registered (in case the name changed or somesuch)</p>"},{"location":"reference/enderchest/#enderchest.EnderChest.register_instance--notes","title":"Notes","text":"<ul> <li>If the instance's name is already assigned to a registered instance,   this method will choose a new one</li> <li>If this instance shares a path with an existing instance, it will   replace that instance</li> </ul> Source code in <code>enderchest/enderchest.py</code> <pre><code>def register_instance(self, instance: i.InstanceSpec) -&gt; i.InstanceSpec:\n    \"\"\"Register a new Minecraft installation\n\n    Parameters\n    ----------\n    instance : InstanceSpec\n        The instance to register\n\n    Returns\n    -------\n    InstanceSpec\n        The spec of the instance as it was actually registered (in case the\n        name changed or somesuch)\n\n    Notes\n    -----\n    - If the instance's name is already assigned to a registered instance,\n      this method will choose a new one\n    - If this instance shares a path with an existing instance, it will\n      replace that instance\n    \"\"\"\n    matching_instances: list[i.InstanceSpec] = []\n    for old_instance in self._instances:\n        if i.equals(abspath_from_uri(self._uri), instance, old_instance):\n            matching_instances.append(old_instance)\n            self._instances.remove(old_instance)\n\n    instance = i.merge(*matching_instances, instance)\n\n    name = instance.name\n    counter = 0\n    taken_names = {old_instance.name for old_instance in self._instances}\n    while True:\n        if name not in taken_names:\n            break\n        counter += 1\n        name = f\"{instance.name}.{counter}\"\n\n    GATHER_LOGGER.debug(f\"Registering instance {name} at {instance.root}\")\n    self._instances.append(instance._replace(name=name))\n    return self._instances[-1]\n</code></pre>"},{"location":"reference/enderchest/#enderchest.EnderChest.register_remote","title":"<code>register_remote(remote, alias=None)</code>","text":"<p>Register a new remote EnderChest installation (or update an existing registry)</p> <p>Parameters:</p> Name Type Description Default <code>remote</code> <code>URI</code> <p>The URI of the remote</p> required <code>alias</code> <code>str</code> <p>an alias to give to this remote. If None is provided, the URI's hostname will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided remote is invalid</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>def register_remote(\n    self, remote: str | ParseResult, alias: str | None = None\n) -&gt; None:\n    \"\"\"Register a new remote EnderChest installation (or update an existing\n    registry)\n\n    Parameters\n    ----------\n    remote : URI\n        The URI of the remote\n    alias : str, optional\n        an alias to give to this remote. If None is provided, the URI's hostname\n        will be used.\n\n    Raises\n    ------\n    ValueError\n        If the provided remote is invalid\n    \"\"\"\n    try:\n        remote = remote if isinstance(remote, ParseResult) else urlparse(remote)\n        alias = alias or remote.hostname\n        if not alias:  # pragma: no cover\n            raise AttributeError(f\"{remote.geturl()} has no hostname\")\n        GATHER_LOGGER.debug(\"Registering remote %s (%s)\", remote.geturl(), alias)\n        self._remotes[alias] = remote\n    except AttributeError as parse_problem:  # pragma: no cover\n        raise ValueError(f\"{remote} is not a valid URI\") from parse_problem\n</code></pre>"},{"location":"reference/enderchest/#enderchest.EnderChest.write_to_cfg","title":"<code>write_to_cfg(config_file=None)</code>","text":"<p>Write this EnderChest's configuration to INI</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path</code> <p>The path to the config file, assuming you'd like to write the contents to file</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>An INI-syntax rendering of this EnderChest's config</p>"},{"location":"reference/enderchest/#enderchest.EnderChest.write_to_cfg--notes","title":"Notes","text":"<p>The \"root\" attribute is ignored for this method</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>def write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n    \"\"\"Write this EnderChest's configuration to INI\n\n    Parameters\n    ----------\n    config_file : Path, optional\n        The path to the config file, assuming you'd like to write the\n        contents to file\n\n    Returns\n    -------\n    str\n        An INI-syntax rendering of this EnderChest's config\n\n    Notes\n    -----\n    The \"root\" attribute is ignored for this method\n    \"\"\"\n    properties: dict[str, Any] = {\n        \"name\": self.name,\n        \"address\": self._uri.netloc,\n        \"sync-protocol\": self._uri.scheme,\n    }\n    if self.sync_confirm_wait is True:\n        properties[\"sync-confirmation-time\"] = \"prompt\"\n    else:\n        properties[\"sync-confirmation-time\"] = self.sync_confirm_wait\n\n    for setting, _ in _DEFAULTS:\n        if setting == \"sync_confirm_wait\":\n            continue  # already did this one\n        setting_key = setting.replace(\"_\", \"-\")\n        properties[setting_key] = getattr(self, setting)\n\n    remotes: dict[str, str] = {name: uri.geturl() for uri, name in self.remotes}\n\n    instances: dict[str, dict[str, Any]] = {}\n\n    for instance in self.instances:\n        instances[instance.name] = {\n            \"root\": instance.root,\n            \"minecraft-version\": instance.minecraft_versions,\n            \"modloader\": instance.modloader,\n            \"groups\": instance.groups_,\n            \"tags\": instance.tags_,\n        }\n\n    config = cfg.dumps(\n        fs.ENDER_CHEST_CONFIG_NAME, properties, remotes=remotes, **instances\n    )\n\n    if config_file:\n        CRAFT_LOGGER.debug(\"Writing configuration file to %s\", config_file)\n        config_file.write_text(config)\n    return config\n</code></pre>"},{"location":"reference/enderchest/#enderchest.InstanceSpec","title":"<code>InstanceSpec</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Specification of a Minecraft instance</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The \"display name\" for the instance</p> required <code>root</code> <code>Path</code> <p>The path to its \".minecraft\" folder</p> required <code>minecraft_versions</code> <code>list-like of str</code> <p>The minecraft versions of this instance. This is typically a 1-tuple, but some loaders (such as the official one) will just comingle all your assets together across all profiles</p> required <code>modloader</code> <code>str</code> <p>The (display) name of the modloader (vanilla corresponds to \"\")</p> required <code>tags</code> <code>list-like of str</code> <p>The tags assigned to this instance, including both the ones assigned in the launcher (groups) and the ones assigned by hand.</p> required Source code in <code>enderchest/instance.py</code> <pre><code>class InstanceSpec(NamedTuple):\n    \"\"\"Specification of a Minecraft instance\n\n    Parameters\n    ----------\n    name : str\n        The \"display name\" for the instance\n    root : Path\n        The path to its \".minecraft\" folder\n    minecraft_versions : list-like of str\n        The minecraft versions of this instance. This is typically a 1-tuple,\n        but some loaders (such as the official one) will just comingle all\n        your assets together across all profiles\n    modloader : str\n        The (display) name of the modloader (vanilla corresponds to \"\")\n    tags : list-like of str\n        The tags assigned to this instance, including both the ones assigned\n        in the launcher (groups) and the ones assigned by hand.\n    \"\"\"\n\n    name: str\n    root: Path\n    minecraft_versions: tuple[str, ...]\n    modloader: str\n    groups_: tuple[str, ...]\n    tags_: tuple[str, ...]\n\n    @classmethod\n    def from_cfg(cls, section: SectionProxy) -&gt; \"InstanceSpec\":\n        \"\"\"Parse an instance spec as read in from the enderchest config file\n\n        Parameters\n        ----------\n        section : dict-like of str to str\n            The section in the enderchest config as parsed by a ConfigParser\n\n        Returns\n        -------\n        InstanceSpec\n            The resulting InstanceSpec\n\n        Raises\n        ------\n        KeyError\n            If a required key is absent\n        ValueError\n            If a required entry cannot be parsed\n        \"\"\"\n        return cls(\n            section.name,\n            Path(section[\"root\"]),\n            tuple(\n                parse_version(version.strip())\n                for version in cfg.parse_ini_list(\n                    section.get(\"minecraft-version\", section.get(\"minecraft_version\"))\n                )\n            ),\n            normalize_modloader(section.get(\"modloader\", None))[0],\n            tuple(cfg.parse_ini_list(section.get(\"groups\", \"\"))),\n            tuple(cfg.parse_ini_list(section.get(\"tags\", \"\"))),\n        )\n\n    @property\n    def tags(self):\n        return tuple(sorted({*self.groups_, *self.tags_}))\n</code></pre>"},{"location":"reference/enderchest/#enderchest.InstanceSpec.from_cfg","title":"<code>from_cfg(section)</code>  <code>classmethod</code>","text":"<p>Parse an instance spec as read in from the enderchest config file</p> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>dict-like of str to str</code> <p>The section in the enderchest config as parsed by a ConfigParser</p> required <p>Returns:</p> Type Description <code>InstanceSpec</code> <p>The resulting InstanceSpec</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If a required key is absent</p> <code>ValueError</code> <p>If a required entry cannot be parsed</p> Source code in <code>enderchest/instance.py</code> <pre><code>@classmethod\ndef from_cfg(cls, section: SectionProxy) -&gt; \"InstanceSpec\":\n    \"\"\"Parse an instance spec as read in from the enderchest config file\n\n    Parameters\n    ----------\n    section : dict-like of str to str\n        The section in the enderchest config as parsed by a ConfigParser\n\n    Returns\n    -------\n    InstanceSpec\n        The resulting InstanceSpec\n\n    Raises\n    ------\n    KeyError\n        If a required key is absent\n    ValueError\n        If a required entry cannot be parsed\n    \"\"\"\n    return cls(\n        section.name,\n        Path(section[\"root\"]),\n        tuple(\n            parse_version(version.strip())\n            for version in cfg.parse_ini_list(\n                section.get(\"minecraft-version\", section.get(\"minecraft_version\"))\n            )\n        ),\n        normalize_modloader(section.get(\"modloader\", None))[0],\n        tuple(cfg.parse_ini_list(section.get(\"groups\", \"\"))),\n        tuple(cfg.parse_ini_list(section.get(\"tags\", \"\"))),\n    )\n</code></pre>"},{"location":"reference/enderchest/#enderchest.ShulkerBox","title":"<code>ShulkerBox</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Specification of a shulker box</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>The priority for linking assets in the shulker box (higher priority boxes are linked last)</p> required <code>name</code> <code>str</code> <p>The name of the shulker box (which is incidentally used to break priority ties)</p> required <code>root</code> <code>Path</code> <p>The path to the root of the shulker box</p> required <code>match_criteria</code> <code>list-like of tuples</code> <p>The parameters for matching instances to this shulker box. Each element consists of:</p> <ul> <li>the name of the condition</li> <li>the matching values for that condition</li> </ul> <p>The logic applied is that an instance must match at least one value for each condition (so it's ANDing a collection of ORs)</p> required <code>link_folders</code> <code>list-like of str</code> <p>The folders that should be linked in their entirety</p> required <code>max_link_depth</code> <code>int</code> <p>By default, non-root-level folders (that is, folders inside of folders) will be treated as files for the purpose of linking. Put another way, only files with a depth of 2 or less from the shulker root will be linked. This behavior can be overridden by explicitly setting the <code>max_link_depth</code> value, but this feature is highly experimental, so use it at your own risk.</p> required <code>do_not_link</code> <code>list-like of str</code> <p>Glob patterns of files that should not be linked. By default, this list comprises <code>shulkerbox.cfg</code> and <code>.DS_Store</code> (for all you mac gamers).</p> required"},{"location":"reference/enderchest/#enderchest.ShulkerBox--notes","title":"Notes","text":"<p>A shulker box specification is immutable, so making changes (such as updating the match criteria) can only be done on copies created via the <code>_replace</code> method, inherited from the NamedTuple parent class.</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>class ShulkerBox(NamedTuple):\n    \"\"\"Specification of a shulker box\n\n    Parameters\n    ----------\n    priority : int\n        The priority for linking assets in the shulker box (higher priority\n        boxes are linked last)\n    name : str\n        The name of the shulker box (which is incidentally used to break\n        priority ties)\n    root : Path\n        The path to the root of the shulker box\n    match_criteria : list-like of tuples\n        The parameters for matching instances to this shulker box. Each element\n        consists of:\n\n          - the name of the condition\n          - the matching values for that condition\n\n        The logic applied is that an instance must match at least one value\n        for each condition (so it's ANDing a collection of ORs)\n    link_folders : list-like of str\n        The folders that should be linked in their entirety\n    max_link_depth : int, optional\n        By default, non-root-level folders (that is, folders inside of folders)\n        will be treated as files for the purpose of linking. Put another way,\n        only files with a depth of 2 or less from the shulker root will be\n        linked. This behavior can be overridden by explicitly setting\n        the `max_link_depth` value, but **this feature is highly experimental**,\n        so use it at your own risk.\n    do_not_link : list-like of str, optional\n        Glob patterns of files that should not be linked. By default, this list\n        comprises `shulkerbox.cfg` and `.DS_Store` (for all you mac gamers).\n\n    Notes\n    -----\n    A shulker box specification is immutable, so making changes (such as\n    updating the match criteria) can only be done on copies created via the\n    `_replace` method, inherited from the NamedTuple parent class.\n    \"\"\"\n\n    priority: int\n    name: str\n    root: Path\n    match_criteria: tuple[tuple[str, tuple[str, ...]], ...]\n    link_folders: tuple[str, ...]\n    max_link_depth: int = _DEFAULT_LINK_DEPTH\n    do_not_link: tuple[str, ...] = _DEFAULT_DO_NOT_LINK\n\n    @classmethod\n    def from_cfg(cls, config_file: Path) -&gt; \"ShulkerBox\":\n        \"\"\"Parse a shulker box from its config file\n\n        Parameters\n        ----------\n        config_file : Path\n            The path to the config file\n\n        Returns\n        -------\n        ShulkerBox\n            The resulting ShulkerBox\n\n        Raises\n        ------\n        ValueError\n            If the config file at that location cannot be parsed\n        FileNotFoundError\n            If there is no config file at the specified location\n        \"\"\"\n        priority = 0\n        max_link_depth = 2\n        root = config_file.parent\n        name = root.name\n        config = cfg.read_cfg(config_file)\n\n        match_criteria: dict[str, tuple[str, ...]] = {}\n\n        for section in config.sections():\n            normalized = (\n                section.lower().replace(\" \", \"\").replace(\"-\", \"\").replace(\"_\", \"\")\n            )\n            if normalized.endswith(\"s\"):\n                normalized = normalized[:-1]  # lazy de-pluralization\n            if normalized in (\"linkfolder\", \"folder\"):\n                normalized = \"link-folders\"\n            if normalized in (\"donotlink\",):\n                normalized = \"do-not-link\"\n            if normalized in (\"minecraft\", \"version\", \"minecraftversion\"):\n                normalized = \"minecraft\"\n            if normalized in (\"modloader\", \"loader\"):\n                normalized = \"modloader\"\n            if normalized in (\"instance\", \"tag\", \"host\"):\n                normalized += \"s\"  # lazy re-pluralization\n\n            if normalized == \"propertie\":  # lulz\n                # TODO check to make sure properties hasn't been read before\n                # most of this section gets ignored\n                priority = config[section].getint(\"priority\", _DEFAULT_PRIORITY)\n                max_link_depth = config[section].getint(\n                    \"max-link-depth\", _DEFAULT_LINK_DEPTH\n                )\n                # TODO: support specifying filters (and link-folders) in the properties section\n                continue\n            if normalized in match_criteria:\n                raise ValueError(f\"{config_file} specifies {normalized} more than once\")\n\n            if normalized == \"minecraft\":\n                minecraft_versions = []\n                for key, value in config[section].items():\n                    if value is None:\n                        minecraft_versions.append(key)\n                    elif key.lower().strip().startswith(\"version\"):\n                        minecraft_versions.append(value)\n                    else:  # what happens if you specify \"&gt;=1.19\" or \"=1.12\"\n                        minecraft_versions.append(\"=\".join((key, value)))\n                match_criteria[normalized] = tuple(minecraft_versions)\n            elif normalized == \"modloader\":\n                modloaders: set[str] = set()\n                for loader in config[section].keys():\n                    modloaders.update(normalize_modloader(loader))\n                match_criteria[normalized] = tuple(sorted(modloaders))\n            else:\n                # really hoping delimiter shenanigans doesn't show up anywhere else\n                match_criteria[normalized] = tuple(config[section].keys())\n\n        link_folders = match_criteria.pop(\"link-folders\", ())\n        do_not_link = match_criteria.pop(\"do-not-link\", _DEFAULT_DO_NOT_LINK)\n\n        return cls(\n            priority,\n            name,\n            root,\n            tuple(match_criteria.items()),\n            link_folders,\n            max_link_depth=max_link_depth,\n            do_not_link=do_not_link,\n        )\n\n    def write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n        \"\"\"Write this box's configuration to INI\n\n        Parameters\n        ----------\n        config_file : Path, optional\n            The path to the config file, assuming you'd like to write the\n            contents to file\n\n        Returns\n        -------\n        str\n            An INI-syntax rendering of this shulker box's config\n\n        Notes\n        -----\n        The \"root\" attribute is ignored for this method\n        \"\"\"\n        properties: dict[str, Any] = {\"priority\": self.priority}\n        if self.max_link_depth != _DEFAULT_LINK_DEPTH:\n            properties[\"max-link-depth\"] = self.max_link_depth\n\n        config = cfg.dumps(\n            os.path.join(self.name, fs.SHULKER_BOX_CONFIG_NAME),\n            properties,\n            **dict(self.match_criteria),\n            link_folders=self.link_folders,\n            do_not_link=self.do_not_link,\n        )\n\n        if config_file:\n            config_file.write_text(config)\n        return config\n\n    def matches(self, instance: InstanceSpec) -&gt; bool:\n        \"\"\"Determine whether the shulker box matches the given instance\n\n        Parameters\n        ----------\n        instance : InstanceSpec\n            The instance's specification\n\n        Returns\n        -------\n        bool\n            True if the instance matches the shulker box's conditions, False\n            otherwise.\n        \"\"\"\n        for condition, values in self.match_criteria:\n            match condition:  # these should have been normalized on read-in\n                case \"instances\":\n                    for value in values:\n                        if fnmatch.fnmatchcase(instance.name, value):\n                            break\n                    else:\n                        return False\n                case \"tags\":\n                    for value in values:\n                        if value == \"*\":  # in case instance.tags is empty\n                            break\n                        if fnmatch.filter(\n                            [tag.lower() for tag in instance.tags], value.lower()\n                        ):\n                            break\n                    else:\n                        return False\n                case \"modloader\":\n                    for value in values:\n                        if fnmatch.fnmatchcase(\n                            instance.modloader.lower(),\n                            value.lower(),\n                        ):\n                            break\n                    else:\n                        return False\n                case \"minecraft\":\n                    for value in values:\n                        if any(\n                            (\n                                _matches_version(value, version)\n                                for version in instance.minecraft_versions\n                            )\n                        ):\n                            break\n                    else:\n                        return False\n                case \"hosts\":\n                    # this is handled at a higher level\n                    pass\n                case _:\n                    raise NotImplementedError(\n                        f\"Don't know how to apply match condition {condition}.\"\n                    )\n        return True\n\n    def matches_host(self, hostname: str):\n        \"\"\"Determine whether the shulker box should be linked to from the\n        current host machine\n\n        Returns\n        -------\n        bool\n            True if the shulker box's hosts spec matches the host, False otherwise.\n        \"\"\"\n        for condition, values in self.match_criteria:\n            if condition == \"hosts\":\n                if not any(\n                    fnmatch.fnmatchcase(hostname.lower(), host_spec.lower())\n                    for host_spec in values\n                ):\n                    return False\n        return True\n</code></pre>"},{"location":"reference/enderchest/#enderchest.ShulkerBox.from_cfg","title":"<code>from_cfg(config_file)</code>  <code>classmethod</code>","text":"<p>Parse a shulker box from its config file</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path</code> <p>The path to the config file</p> required <p>Returns:</p> Type Description <code>ShulkerBox</code> <p>The resulting ShulkerBox</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the config file at that location cannot be parsed</p> <code>FileNotFoundError</code> <p>If there is no config file at the specified location</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>@classmethod\ndef from_cfg(cls, config_file: Path) -&gt; \"ShulkerBox\":\n    \"\"\"Parse a shulker box from its config file\n\n    Parameters\n    ----------\n    config_file : Path\n        The path to the config file\n\n    Returns\n    -------\n    ShulkerBox\n        The resulting ShulkerBox\n\n    Raises\n    ------\n    ValueError\n        If the config file at that location cannot be parsed\n    FileNotFoundError\n        If there is no config file at the specified location\n    \"\"\"\n    priority = 0\n    max_link_depth = 2\n    root = config_file.parent\n    name = root.name\n    config = cfg.read_cfg(config_file)\n\n    match_criteria: dict[str, tuple[str, ...]] = {}\n\n    for section in config.sections():\n        normalized = (\n            section.lower().replace(\" \", \"\").replace(\"-\", \"\").replace(\"_\", \"\")\n        )\n        if normalized.endswith(\"s\"):\n            normalized = normalized[:-1]  # lazy de-pluralization\n        if normalized in (\"linkfolder\", \"folder\"):\n            normalized = \"link-folders\"\n        if normalized in (\"donotlink\",):\n            normalized = \"do-not-link\"\n        if normalized in (\"minecraft\", \"version\", \"minecraftversion\"):\n            normalized = \"minecraft\"\n        if normalized in (\"modloader\", \"loader\"):\n            normalized = \"modloader\"\n        if normalized in (\"instance\", \"tag\", \"host\"):\n            normalized += \"s\"  # lazy re-pluralization\n\n        if normalized == \"propertie\":  # lulz\n            # TODO check to make sure properties hasn't been read before\n            # most of this section gets ignored\n            priority = config[section].getint(\"priority\", _DEFAULT_PRIORITY)\n            max_link_depth = config[section].getint(\n                \"max-link-depth\", _DEFAULT_LINK_DEPTH\n            )\n            # TODO: support specifying filters (and link-folders) in the properties section\n            continue\n        if normalized in match_criteria:\n            raise ValueError(f\"{config_file} specifies {normalized} more than once\")\n\n        if normalized == \"minecraft\":\n            minecraft_versions = []\n            for key, value in config[section].items():\n                if value is None:\n                    minecraft_versions.append(key)\n                elif key.lower().strip().startswith(\"version\"):\n                    minecraft_versions.append(value)\n                else:  # what happens if you specify \"&gt;=1.19\" or \"=1.12\"\n                    minecraft_versions.append(\"=\".join((key, value)))\n            match_criteria[normalized] = tuple(minecraft_versions)\n        elif normalized == \"modloader\":\n            modloaders: set[str] = set()\n            for loader in config[section].keys():\n                modloaders.update(normalize_modloader(loader))\n            match_criteria[normalized] = tuple(sorted(modloaders))\n        else:\n            # really hoping delimiter shenanigans doesn't show up anywhere else\n            match_criteria[normalized] = tuple(config[section].keys())\n\n    link_folders = match_criteria.pop(\"link-folders\", ())\n    do_not_link = match_criteria.pop(\"do-not-link\", _DEFAULT_DO_NOT_LINK)\n\n    return cls(\n        priority,\n        name,\n        root,\n        tuple(match_criteria.items()),\n        link_folders,\n        max_link_depth=max_link_depth,\n        do_not_link=do_not_link,\n    )\n</code></pre>"},{"location":"reference/enderchest/#enderchest.ShulkerBox.matches","title":"<code>matches(instance)</code>","text":"<p>Determine whether the shulker box matches the given instance</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>InstanceSpec</code> <p>The instance's specification</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the instance matches the shulker box's conditions, False otherwise.</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>def matches(self, instance: InstanceSpec) -&gt; bool:\n    \"\"\"Determine whether the shulker box matches the given instance\n\n    Parameters\n    ----------\n    instance : InstanceSpec\n        The instance's specification\n\n    Returns\n    -------\n    bool\n        True if the instance matches the shulker box's conditions, False\n        otherwise.\n    \"\"\"\n    for condition, values in self.match_criteria:\n        match condition:  # these should have been normalized on read-in\n            case \"instances\":\n                for value in values:\n                    if fnmatch.fnmatchcase(instance.name, value):\n                        break\n                else:\n                    return False\n            case \"tags\":\n                for value in values:\n                    if value == \"*\":  # in case instance.tags is empty\n                        break\n                    if fnmatch.filter(\n                        [tag.lower() for tag in instance.tags], value.lower()\n                    ):\n                        break\n                else:\n                    return False\n            case \"modloader\":\n                for value in values:\n                    if fnmatch.fnmatchcase(\n                        instance.modloader.lower(),\n                        value.lower(),\n                    ):\n                        break\n                else:\n                    return False\n            case \"minecraft\":\n                for value in values:\n                    if any(\n                        (\n                            _matches_version(value, version)\n                            for version in instance.minecraft_versions\n                        )\n                    ):\n                        break\n                else:\n                    return False\n            case \"hosts\":\n                # this is handled at a higher level\n                pass\n            case _:\n                raise NotImplementedError(\n                    f\"Don't know how to apply match condition {condition}.\"\n                )\n    return True\n</code></pre>"},{"location":"reference/enderchest/#enderchest.ShulkerBox.matches_host","title":"<code>matches_host(hostname)</code>","text":"<p>Determine whether the shulker box should be linked to from the current host machine</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the shulker box's hosts spec matches the host, False otherwise.</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>def matches_host(self, hostname: str):\n    \"\"\"Determine whether the shulker box should be linked to from the\n    current host machine\n\n    Returns\n    -------\n    bool\n        True if the shulker box's hosts spec matches the host, False otherwise.\n    \"\"\"\n    for condition, values in self.match_criteria:\n        if condition == \"hosts\":\n            if not any(\n                fnmatch.fnmatchcase(hostname.lower(), host_spec.lower())\n                for host_spec in values\n            ):\n                return False\n    return True\n</code></pre>"},{"location":"reference/enderchest/#enderchest.ShulkerBox.write_to_cfg","title":"<code>write_to_cfg(config_file=None)</code>","text":"<p>Write this box's configuration to INI</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path</code> <p>The path to the config file, assuming you'd like to write the contents to file</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>An INI-syntax rendering of this shulker box's config</p>"},{"location":"reference/enderchest/#enderchest.ShulkerBox.write_to_cfg--notes","title":"Notes","text":"<p>The \"root\" attribute is ignored for this method</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>def write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n    \"\"\"Write this box's configuration to INI\n\n    Parameters\n    ----------\n    config_file : Path, optional\n        The path to the config file, assuming you'd like to write the\n        contents to file\n\n    Returns\n    -------\n    str\n        An INI-syntax rendering of this shulker box's config\n\n    Notes\n    -----\n    The \"root\" attribute is ignored for this method\n    \"\"\"\n    properties: dict[str, Any] = {\"priority\": self.priority}\n    if self.max_link_depth != _DEFAULT_LINK_DEPTH:\n        properties[\"max-link-depth\"] = self.max_link_depth\n\n    config = cfg.dumps(\n        os.path.join(self.name, fs.SHULKER_BOX_CONFIG_NAME),\n        properties,\n        **dict(self.match_criteria),\n        link_folders=self.link_folders,\n        do_not_link=self.do_not_link,\n    )\n\n    if config_file:\n        config_file.write_text(config)\n    return config\n</code></pre>"},{"location":"reference/enderchest/cli/","title":"cli","text":"<p>Command-line interface</p>"},{"location":"reference/enderchest/cli/#enderchest.cli.Action","title":"<code>Action</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Common protocol for CLI actions</p> Source code in <code>enderchest/cli.py</code> <pre><code>class Action(Protocol):  # pragma: no cover\n    \"\"\"Common protocol for CLI actions\"\"\"\n\n    def __call__(self, minecraft_root: Path, /) -&gt; Any:\n        ...\n</code></pre>"},{"location":"reference/enderchest/cli/#enderchest.cli.generate_parsers","title":"<code>generate_parsers()</code>","text":"<p>Generate the command-line parsers</p> <p>Returns:</p> Name Type Description <code>enderchest_parser</code> <code>ArgumentParser</code> <p>The top-level argument parser responsible for routing arguments to specific action parsers</p> <code>action_parsers</code> <code>dict of str to ArgumentParser</code> <p>The verb-specific argument parsers</p> Source code in <code>enderchest/cli.py</code> <pre><code>def generate_parsers() -&gt; tuple[ArgumentParser, dict[str, ArgumentParser]]:\n    \"\"\"Generate the command-line parsers\n\n    Returns\n    -------\n    enderchest_parser : ArgumentParser\n        The top-level argument parser responsible for routing arguments to\n        specific action parsers\n    action_parsers : dict of str to ArgumentParser\n        The verb-specific argument parsers\n    \"\"\"\n    descriptions: dict[str, str] = {}\n    root_description: str = \"\"\n    for commands, description, _ in ACTIONS:\n        descriptions[commands[0]] = description\n        root_description += f\"\\n\\t{commands[0]}\\n\\t\\tto {description}\"\n\n    enderchest_parser = ArgumentParser(\n        prog=\"enderchest\",\n        description=(\n            f\"v{get_versions()['version']}\\n\"\n            \"\\nsyncing and linking for all your Minecraft instances\"\n        ),\n        formatter_class=RawTextHelpFormatter,\n    )\n\n    enderchest_parser.add_argument(\n        \"-v\",  # don't worry--this doesn't actually conflict with --verbose\n        \"-V\",\n        \"--version\",\n        action=\"version\",\n        version=f\"%(prog)s v{get_versions()['version']}\",\n    )\n\n    # these are really just for the sake of --help\n    # (the parsed args aren't actually used)\n    enderchest_parser.add_argument(\n        \"action\",\n        help=f\"The action to perform. Options are:{root_description}\",\n        type=str,\n    )\n    enderchest_parser.add_argument(\n        \"arguments\",\n        nargs=\"*\",\n        help=\"Any additional arguments for the specific action.\"\n        \" To learn more, try: enderchest {action} -h\",\n    )\n\n    action_parsers: dict[str, ArgumentParser] = {}\n    for verb, description in descriptions.items():\n        parser = ArgumentParser(\n            prog=f\"enderchest {verb}\",\n            description=description,\n        )\n        if verb != \"test\":\n            root = parser.add_mutually_exclusive_group()\n            root.add_argument(\n                \"root\",\n                nargs=\"?\",\n                help=(\n                    \"Optionally specify your root minecraft directory.\"\n                    \"  If no path is given, the current working directory will be used.\"\n                ),\n                type=Path,\n            )\n            root.add_argument(\n                \"--root\",\n                dest=\"root_flag\",\n                help=\"specify your root minecraft directory\",\n                type=Path,\n            )\n\n            # I'm actually okay with -vvqvqqv hilarity\n            parser.add_argument(\n                \"--verbose\",\n                \"-v\",\n                action=\"count\",\n                default=0,\n                help=\"increase the amount of information that's printed\",\n            )\n            parser.add_argument(\n                \"--quiet\",\n                \"-q\",\n                action=\"count\",\n                default=0,\n                help=\"decrease the amount of information that's printed\",\n            )\n        action_parsers[verb] = parser\n\n    # craft options\n    craft_parser = action_parsers[_create_aliases[0]]\n    craft_parser.add_argument(\n        \"--from\",\n        dest=\"copy_from\",\n        help=(\n            \"provide the URI (e.g. rsync://deck@my-steam-deck/home/deck/) of a\"\n            \" remote EnderChest installation that can be used\"\n            \" to boostrap the creation of this one.\"\n        ),\n    )\n    craft_parser.add_argument(\n        \"-r\",\n        \"--remote\",\n        dest=\"remotes\",\n        action=\"append\",\n        help=(\n            \"provide the URI (e.g. rsync://deck@my-steam-deck/home/deck/) of a\"\n            \" remote EnderChest installation to register with this one\"\n        ),\n    )\n    craft_parser.add_argument(\n        \"-i\",\n        \"--instance\",\n        dest=\"instance_search_paths\",\n        action=\"append\",\n        type=Path,\n        help=\"specify a folder to search for Minecraft installations in\",\n    )\n    craft_parser.add_argument(\n        \"--overwrite\",\n        action=\"store_true\",\n        help=(\n            \"if there's already an EnderChest installation in this location,\"\n            \" overwrite its configuration\"\n        ),\n    )\n\n    # shulker box craft options\n    shulker_craft_parser = action_parsers[\n        f\"{_create_aliases[0]} {_shulker_box_aliases[0]}\"\n    ]\n    shulker_craft_parser.add_argument(\n        \"name\",\n        help=\"specify the name for this shulker box\",\n    )\n    shulker_craft_parser.add_argument(\n        \"--priority\",\n        \"-p\",\n        help=\"specify the link priority for this shulker box (higher = linked later)\",\n    )\n    shulker_craft_parser.add_argument(\n        \"-i\",\n        \"--instance\",\n        dest=\"instances\",\n        action=\"append\",\n        help=\"only link instances with one of the provided names to this shulker box\",\n    )\n    shulker_craft_parser.add_argument(\n        \"-t\",\n        \"--tag\",\n        dest=\"tags\",\n        action=\"append\",\n        help=\"only link instances with one of the provided tags to this shulker box\",\n    )\n    shulker_craft_parser.add_argument(\n        \"-e\",\n        \"--enderchest\",\n        dest=\"hosts\",\n        action=\"append\",\n        help=(\n            \"only link instances registered to one of the provided EnderChest\"\n            \" installations with this shulker box\"\n        ),\n    )\n    shulker_craft_parser.add_argument(\n        \"-l\",\n        \"--folder\",\n        dest=\"link_folders\",\n        action=\"append\",\n        help=(\n            \"specify the name of a folder inside this shulker box\"\n            \" that should be linked completely\"\n        ),\n    )\n    shulker_craft_parser.add_argument(\n        \"--overwrite\",\n        action=\"store_true\",\n        help=(\n            \"if there's already a shulker box with the specified name,\"\n            \" overwrite its configuration\"\n        ),\n    )\n\n    # place options\n    place_parser = action_parsers[\"place\"]\n    cleanup = place_parser.add_argument_group()\n    cleanup.add_argument(\n        \"--keep-broken-links\",\n        action=\"store_true\",\n        help=\"do not remove broken links from instances\",\n    )\n    cleanup.add_argument(\n        \"--keep-stale-links\",\n        action=\"store_true\",\n        help=(\n            \"do not remove existing links into the EnderChest,\"\n            \" even if the shulker box or instance spec has changed\"\n        ),\n    )\n    cleanup.add_argument(\n        \"-k\",\n        dest=\"keep_level\",\n        action=\"count\",\n        default=0,\n        help=(\n            \"shorthand for the above cleanup options:\"\n            \" -k will --keep-stale-links,\"\n            \" and -kk will --keep-broken-links as well\"\n        ),\n    )\n    error_handling = place_parser.add_argument_group(\n        title=\"error handling\"\n    ).add_mutually_exclusive_group()\n    error_handling.add_argument(\n        \"--stop-at-first-failure\",\n        \"-x\",\n        action=\"store_true\",\n        help=\"stop linking at the first issue\",\n    )\n    error_handling.add_argument(\n        \"--ignore-errors\", action=\"store_true\", help=\"ignore any linking errors\"\n    )\n    error_handling.add_argument(\n        \"--errors\",\n        \"-e\",\n        choices=(\n            \"prompt\",\n            \"ignore\",\n            \"skip\",\n            \"skip-instance\",\n            \"skip-shulker-box\",\n            \"abort\",\n        ),\n        default=\"prompt\",\n        help=(\n            \"specify how to handle linking errors\"\n            \" (default behavior is to prompt after every error)\"\n        ),\n    )\n    link_type = place_parser.add_mutually_exclusive_group()\n    link_type.add_argument(\n        \"--absolute\",\n        \"-a\",\n        action=\"store_true\",\n        help=\"use absolute paths for all link targets\",\n    )\n    link_type.add_argument(\n        \"--relative\",\n        \"-r\",\n        action=\"store_true\",\n        help=\"use relative paths for all link targets\",\n    )\n\n    # gather instance options\n    gather_instance_parser = action_parsers[f\"gather {_instance_aliases[0]}\"]\n    gather_instance_parser.add_argument(\n        \"search_paths\",\n        nargs=\"+\",\n        action=\"extend\",\n        type=Path,\n        help=\"specify a folder or folders to search for Minecraft installations\",\n    )\n    instance_type = gather_instance_parser.add_mutually_exclusive_group()\n    instance_type.add_argument(\n        \"--official\",\n        \"-o\",\n        action=\"store_true\",\n        help=\"specify that these are instances managed by the official launcher\",\n    )\n    instance_type.add_argument(\n        \"--mmc\",\n        \"-m\",\n        action=\"store_true\",\n        help=\"specify that these are MultiMC-like instances\",\n    )\n\n    # gather remote options\n    gather_remote_parser = action_parsers[f\"gather {_remote_aliases[0]}\"]\n    gather_remote_parser.add_argument(\n        \"remotes\",\n        nargs=\"+\",\n        action=\"extend\",\n        help=(\n            \"Provide URIs (e.g. rsync://deck@my-steam-deck/home/deck/) of any\"\n            \" remote EnderChest installation to register with this one.\"\n            \"Note: you should not use this method if the alias (name) of the\"\n            \"remote does not match the remote's hostname (in this example,\"\n            '\"my-steam-deck\").'\n        ),\n    )\n\n    # list shulker box options\n\n    # list [instance] boxes options\n    list_boxes_parser = action_parsers[f\"{_list_aliases[0]}\"]\n    list_instance_boxes_parser = action_parsers[\n        f\"{_list_aliases[0]} {_instance_aliases[0]}\"\n    ]\n\n    instance_name_docs = \"The name of the minecraft instance to query\"\n    list_boxes_parser.add_argument(\n        \"--instance\", \"-i\", dest=\"instance_name\", help=instance_name_docs\n    )\n    list_instance_boxes_parser.add_argument(\"instance_name\", help=instance_name_docs)\n\n    for parser in (list_boxes_parser, list_instance_boxes_parser):\n        parser.add_argument(\n            \"--path\",\n            \"-p\",\n            help=(\n                \"optionally, specify a specific path\"\n                \" (absolute, relative, filename or glob pattern\"\n                \" to get a report of the shulker box(es) that provide that resource\"\n            ),\n        )\n\n    # list shulker options\n    list_shulker_box_parser = action_parsers[\n        f\"{_list_aliases[0]} {_shulker_box_aliases[0]}\"\n    ]\n    list_shulker_box_parser.add_argument(\n        \"shulker_box_name\", help=\"the name of the shulker box to query\"\n    )\n\n    # open / close options\n    for action in (\"open\", \"close\"):\n        sync_parser = action_parsers[action]\n\n        sync_parser.add_argument(\n            \"--dry-run\",\n            action=\"store_true\",\n            help=(\n                \"perform a dry run of the sync operation,\"\n                \" reporting the operations that will be performed\"\n                \" but not actually carrying them out\"\n            ),\n        )\n        sync_parser.add_argument(\n            \"--exclude\",\n            \"-e\",\n            action=\"extend\",\n            nargs=\"+\",\n            help=\"Provide any file patterns you would like to skip syncing\",\n        )\n        sync_parser.add_argument(\n            \"--timeout\",\n            \"-t\",\n            type=int,\n            help=(\n                \"set a maximum number of seconds to try to sync to a remote chest\"\n                \" before giving up and going on to the next one\"\n            ),\n        )\n        sync_confirm_wait = sync_parser.add_argument_group(\n            title=\"sync confirmation control\",\n            description=(\n                \"The default behavior when syncing EnderChests is to first perform a\"\n                \" dry run of every sync operation and then wait 5 seconds before\"\n                \" proceeding with the real sync. The idea is to give you time to\"\n                \" interrupt the sync if the dry run looks wrong. You can raise or\"\n                \" lower that wait time through these flags. You can also modify it\"\n                \" by editing the enderchest.cfg file.\"\n            ),\n        ).add_mutually_exclusive_group()\n        sync_confirm_wait.add_argument(\n            \"--wait\",\n            \"-w\",\n            dest=\"sync_confirm_wait\",\n            type=int,\n            help=\"set the time in seconds to wait after performing a dry run\"\n            \" before the real sync is performed\",\n        )\n        sync_confirm_wait.add_argument(\n            \"--confirm\",\n            \"-c\",\n            dest=\"sync_confirm_wait\",\n            action=\"store_true\",\n            help=\"after performing the dry run, explicitly ask for confirmation\"\n            \" before performing the real sync\",\n        )\n\n    # test pass-through\n    test_parser = action_parsers[\"test\"]\n    test_parser.add_argument(\n        \"--use-local-ssh\",\n        action=\"store_true\",\n        dest=\"use_local_ssh\",\n        help=(\n            \"By default, tests of SSH functionality will be run against a mock\"\n            \" SSH server. If you are running EnderChest on a machine you can SSH\"\n            \" into locally (by running `ssh localhost`) without requiring a password,\"\n            \" running the tests with this flag will produce more accurate results.\"\n        ),\n    )\n    test_parser.add_argument(\n        \"pytest_args\",\n        nargs=argparse.REMAINDER,\n        help=\"any additional arguments to pass through to py.test\",\n    )\n\n    return enderchest_parser, action_parsers\n</code></pre>"},{"location":"reference/enderchest/cli/#enderchest.cli.main","title":"<code>main()</code>","text":"<p>CLI Entrypoint</p> Source code in <code>enderchest/cli.py</code> <pre><code>def main():\n    \"\"\"CLI Entrypoint\"\"\"\n    logger = logging.getLogger(__package__)\n    cli_handler = logging.StreamHandler()\n    cli_handler.setFormatter(loggers.CLIFormatter())\n    logger.addHandler(cli_handler)\n\n    action, root, log_level, kwargs = parse_args(sys.argv)\n\n    # TODO: set log levels per logger based on the command\n    cli_handler.setLevel(log_level)\n\n    # TODO: when we add log files, set this to minimum log level across all handlers\n    logger.setLevel(log_level)\n\n    action(root, **kwargs)\n</code></pre>"},{"location":"reference/enderchest/cli/#enderchest.cli.parse_args","title":"<code>parse_args(argv)</code>","text":"<p>Parse the provided command-line options to determine the action to perform and the arguments to pass to the action</p> <p>Parameters:</p> Name Type Description Default <code>argv</code> <code>list-like of str (sys.argv)</code> <p>The options passed into the command line</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The action method that will be called</p> <code>str</code> <p>The root of the minecraft folder (parent of the EnderChest) where the action will be performed</p> <code>int</code> <p>The verbosity level of the operation (in terms of log levels)</p> <code>dict</code> <p>Any additional options that will be given to the action method</p> Source code in <code>enderchest/cli.py</code> <pre><code>def parse_args(argv: Sequence[str]) -&gt; tuple[Action, Path, int, dict[str, Any]]:\n    \"\"\"Parse the provided command-line options to determine the action to perform and\n    the arguments to pass to the action\n\n    Parameters\n    ----------\n    argv : list-like of str (sys.argv)\n        The options passed into the command line\n\n    Returns\n    -------\n    Callable\n        The action method that will be called\n    str\n        The root of the minecraft folder (parent of the EnderChest)\n        where the action will be performed\n    int\n        The verbosity level of the operation (in terms of log levels)\n    dict\n        Any additional options that will be given to the action method\n\n    \"\"\"\n    actions: dict[str, Action] = {}\n    aliases: dict[str, str] = {}\n    for commands, _, method in ACTIONS:\n        for command in commands:\n            aliases[command] = commands[0]\n        actions[commands[0]] = method\n\n    enderchest_parser, action_parsers = generate_parsers()\n\n    _ = enderchest_parser.parse_args(argv[1:2])  # check for --help and --version\n\n    for command in sorted(aliases.keys(), key=lambda x: -len(x)):  # longest first\n        if \" \".join((*argv[1:], \"\")).startswith(command + \" \"):\n            if command == \"test\":\n                parsed, extra = action_parsers[\"test\"].parse_known_args(argv[2:])\n                return (\n                    actions[\"test\"],\n                    Path(),\n                    0,\n                    {\n                        \"use_local_ssh\": parsed.use_local_ssh,\n                        \"pytest_args\": [*parsed.pytest_args, *extra],\n                    },\n                )\n            action_kwargs = vars(\n                action_parsers[aliases[command]].parse_args(\n                    argv[1 + len(command.split()) :]\n                )\n            )\n\n            action = actions[aliases[command]]\n\n            root_arg = action_kwargs.pop(\"root\")\n            root_flag = action_kwargs.pop(\"root_flag\")\n\n            verbosity = action_kwargs.pop(\"verbose\") - action_kwargs.pop(\"quiet\")\n\n            argspec = inspect.getfullargspec(action)\n            if \"verbosity\" in argspec.args + argspec.kwonlyargs:\n                action_kwargs[\"verbosity\"] = verbosity\n\n            log_level = loggers.verbosity_to_log_level(verbosity)\n\n            MINECRAFT_ROOT = os.getenv(\"MINECRAFT_ROOT\")\n\n            return (\n                actions[aliases[command]],\n                Path(root_arg or root_flag or MINECRAFT_ROOT or os.getcwd()),\n                log_level,\n                action_kwargs,\n            )\n\n    enderchest_parser.print_help(sys.stderr)\n    sys.exit(1)\n</code></pre>"},{"location":"reference/enderchest/config/","title":"config","text":"<p>Helpers for parsing and writing INI-format config files</p>"},{"location":"reference/enderchest/config/#enderchest.config.dumps","title":"<code>dumps(header, properties, **sections)</code>","text":"<p>Serialize a configuration into an INI-formatted string</p> <p>Parameters:</p> Name Type Description Default <code>header</code> <code>str | None</code> <p>A header to render as a comment at the top of the file</p> required <code>properties</code> <code>dict[str, Any]</code> <p>The \"main\" section contents. Note that this method will add some of its own</p> required <code>**sections</code> <code>dict or list</code> <p>Any additional sections to write. Each section may consist of a set of key-value pairs or they might simply be a list of values</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The contents of the configuration, suitable for writing to file</p> Source code in <code>enderchest/config.py</code> <pre><code>def dumps(\n    header: str | None,\n    properties: dict[str, Any],\n    **sections: Mapping[str, Any] | Sequence[str],\n) -&gt; str:\n    \"\"\"Serialize a configuration into an INI-formatted string\n\n    Parameters\n    ----------\n    header: str\n        A header to render as a comment at the top of the file\n    properties: dict\n        The \"main\" section contents. Note that this method will add some of its own\n    **sections : dict or list\n        Any additional sections to write. Each section may consist of a set\n        of key-value pairs or they might simply be a list of values\n\n    Returns\n    -------\n    str\n        The contents of the configuration, suitable for writing to file\n    \"\"\"\n    config = get_configurator()\n\n    config.add_section(\"properties\")\n    for key, value in properties.items():\n        config.set(\"properties\", to_ini_key(key), to_ini_value(value))\n\n    config.set(\n        \"properties\",\n        \"last-modified\",\n        to_ini_value(dt.datetime.now()),\n    )\n    config.set(\n        \"properties\", \"generated-by-enderchest-version\", get_versions()[\"version\"]\n    )\n\n    for section, values in sections.items():\n        section_name = to_ini_key(section)\n        config.add_section(section_name)\n        if isinstance(values, Mapping):\n            for key, value in values.items():\n                config.set(section_name, to_ini_key(key), to_ini_value(value))\n        else:\n            for value in values:\n                config.set(section_name, to_ini_value(value))\n\n    buffer = StringIO()\n    if header:\n        buffer.write(f\"; {header}\\n\")\n    config.write(buffer)\n    buffer.seek(0)  # rewind\n    return buffer.read()\n</code></pre>"},{"location":"reference/enderchest/config/#enderchest.config.get_configurator","title":"<code>get_configurator()</code>","text":"<p>Generate a configuration parser capable of reading or writing INI files</p> <p>Returns:</p> Type Description <code>ConfigParser</code> <p>The pre-configured configurator</p> Source code in <code>enderchest/config.py</code> <pre><code>def get_configurator() -&gt; ConfigParser:\n    \"\"\"Generate a configuration parser capable of reading or writing INI files\n\n    Returns\n    -------\n    ConfigParser\n        The pre-configured configurator\n    \"\"\"\n    configurator = ConfigParser(\n        allow_no_value=True, inline_comment_prefixes=(\";\",), interpolation=None\n    )\n    configurator.optionxform = str  # type: ignore\n    return configurator\n</code></pre>"},{"location":"reference/enderchest/config/#enderchest.config.list_to_ini","title":"<code>list_to_ini(values)</code>","text":"<p>Format a list of values into a string suitable for use in an INI entry</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list - like</code> <p>the values in the list</p> required <p>Returns:</p> Type Description <code>str</code> <p>The formatted INI-appropriate value</p> Source code in <code>enderchest/config.py</code> <pre><code>def list_to_ini(values: Sequence) -&gt; str:\n    \"\"\"Format a list of values into a string suitable for use in an INI entry\n\n    Parameters\n    ----------\n    values : list-like\n        the values in the list\n\n    Returns\n    -------\n    str\n        The formatted INI-appropriate value\n    \"\"\"\n    if len(values) == 0:\n        return \"\"\n    if len(values) == 1:\n        return values[0]\n    return \"\\n\" + \"\\n\".join(values)\n</code></pre>"},{"location":"reference/enderchest/config/#enderchest.config.parse_ini_list","title":"<code>parse_ini_list(entry)</code>","text":"<p>Parse a list from an INI config entry</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>str</code> <p>The raw entry from the INI</p> required <p>Returns:</p> Type Description <code>list of str</code> <p>The parsed entries</p>"},{"location":"reference/enderchest/config/#enderchest.config.parse_ini_list--notes","title":"Notes","text":"<p>This method is only for parsing specific values of a key-value entry and not for the whole \"section is the key, lines are the values\" thing I've got going on.</p> Source code in <code>enderchest/config.py</code> <pre><code>def parse_ini_list(entry: str) -&gt; list[str]:\n    \"\"\"Parse a list from an INI config entry\n\n    Parameters\n    ----------\n    entry : str\n        The raw entry from the INI\n\n    Returns\n    -------\n    list of str\n        The parsed entries\n\n    Notes\n    -----\n    This method is *only* for parsing specific values of a key-value entry\n    *and not* for the whole \"section is the key, lines are the values\" thing\n    I've got going on.\n    \"\"\"\n    entry = entry.strip()\n    try:\n        parsed = ast.literal_eval(entry)\n        if isinstance(parsed, str):\n            return [parsed]\n        return [str(value) for value in parsed]\n    except (TypeError, ValueError, SyntaxError):\n        # if only it were that easy...\n        pass\n\n    values: list[str] = []\n    for line in entry.splitlines():\n        try:\n            values.append(str(ast.literal_eval(line)))\n        except (TypeError, ValueError, SyntaxError):\n            values.append(line.strip())\n    return values\n</code></pre>"},{"location":"reference/enderchest/config/#enderchest.config.read_cfg","title":"<code>read_cfg(config_file)</code>","text":"<p>Read in a configuration file</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path</code> <p>The path to the configuration file</p> required <p>Returns:</p> Type Description <code>ConfigParser</code> <p>The parsed configuration</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the config file at that location cannot be parsed</p> <code>FileNotFoundError</code> <p>If there is no config file at the specified location</p> Source code in <code>enderchest/config.py</code> <pre><code>def read_cfg(config_file: Path) -&gt; ConfigParser:\n    \"\"\"Read in a configuration file\n\n    Parameters\n    ----------\n    config_file : Path\n        The path to the configuration file\n\n    Returns\n    -------\n    ConfigParser\n        The parsed configuration\n\n    Raises\n    ------\n    ValueError\n        If the config file at that location cannot be parsed\n    FileNotFoundError\n        If there is no config file at the specified location\n    \"\"\"\n    configurator = get_configurator()\n    try:\n        assert configurator.read(config_file)\n    except ParsingError as bad_cfg:\n        raise ValueError(f\"Could not parse {config_file}\") from bad_cfg\n    except AssertionError as not_read:\n        raise FileNotFoundError(f\"Could not open {config_file}\") from not_read\n    return configurator\n</code></pre>"},{"location":"reference/enderchest/config/#enderchest.config.to_ini_key","title":"<code>to_ini_key(key)</code>","text":"<p>Style guide enforcement for INI keys</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The entry key to normalize</p> required <p>Returns:</p> Type Description <code>str</code> <p>The normalized key</p> Source code in <code>enderchest/config.py</code> <pre><code>def to_ini_key(key: str) -&gt; str:\n    \"\"\"Style guide enforcement for INI keys\n\n    Parameters\n    ----------\n    key : str\n        The entry key to normalize\n\n    Returns\n    -------\n    str\n        The normalized key\n    \"\"\"\n    return key.replace(\"_\", \"-\")\n</code></pre>"},{"location":"reference/enderchest/config/#enderchest.config.to_ini_value","title":"<code>to_ini_value(value)</code>","text":"<p>Format a value into a string suitable for use in an INI entry</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to format</p> required <p>Returns:</p> Type Description <code>str</code> <p>The formatted INI-appropriate value</p> Source code in <code>enderchest/config.py</code> <pre><code>def to_ini_value(value: Any) -&gt; str:\n    \"\"\"Format a value into a string suitable for use in an INI entry\n\n    Parameters\n    ----------\n    value\n        The value to format\n\n    Returns\n    -------\n    str\n        The formatted INI-appropriate value\n    \"\"\"\n    if isinstance(value, str):\n        # have to put in this check since strings are iterable\n        return value\n    if value is None:\n        return \"\"\n    if isinstance(value, Iterable):\n        return list_to_ini(list(value))\n    if isinstance(value, dt.datetime):\n        return value.isoformat(sep=\" \")\n    if isinstance(value, dt.date):\n        # note that datetimes are considered dates\n        return value.isoformat()\n\n    return str(value)\n</code></pre>"},{"location":"reference/enderchest/craft/","title":"craft","text":"<p>Functionality for setting up the folder structure of both chests and shulker boxes</p>"},{"location":"reference/enderchest/craft/#enderchest.craft.craft_ender_chest","title":"<code>craft_ender_chest(minecraft_root, copy_from=None, instance_search_paths=None, remotes=None, overwrite=False)</code>","text":"<p>Craft an EnderChest, either from the specified keyword arguments, or interactively via prompts</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff is in (or, at least, the one inside which you want to create your EnderChest)</p> required <code>copy_from</code> <code>URI</code> <p>Optionally bootstrap your configuration by pulling the list of remotes from an existing remote EnderChest</p> <code>None</code> <code>instance_search_paths</code> <code>list of Paths</code> <p>Any paths to search for Minecraft instances</p> <code>None</code> <code>remotes</code> <code>list of URIs or (URI, str) tuples</code> <p>Any remotes you wish you manually specify. If used with <code>copy_from</code>, these will overwrite any remotes pulled from the remote EnderChest. When a (URI, str) tuple is provided, the second value will be used as the name/alias of the remote.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>This method will not overwrite an EnderChest instance installed within the <code>minecraft_root</code> unless the user provides <code>overwrite=True</code></p> <code>False</code>"},{"location":"reference/enderchest/craft/#enderchest.craft.craft_ender_chest--notes","title":"Notes","text":"<ul> <li>The guided / interactive specifier will only be used if no other keyword   arguments are provided (not even <code>overwrite=True</code>)</li> <li>The instance searcher will first attempt to parse any instances it finds   as official-launcher Minecrafts and then, if that doesn't work, will try   parsing them as MultiMC-style instances.</li> <li>The instance searcher is fully recursive, so keep that in mind before   passing in, say \"/\"</li> </ul> Source code in <code>enderchest/craft.py</code> <pre><code>def craft_ender_chest(\n    minecraft_root: Path,\n    copy_from: str | ParseResult | None = None,\n    instance_search_paths: Iterable[str | Path] | None = None,\n    remotes: Iterable[str | ParseResult | tuple[str, str] | tuple[ParseResult, str]]\n    | None = None,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"Craft an EnderChest, either from the specified keyword arguments, or\n    interactively via prompts\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff is in (or, at least, the\n        one inside which you want to create your EnderChest)\n    copy_from : URI, optional\n        Optionally bootstrap your configuration by pulling the list of remotes\n        from an existing remote EnderChest\n    instance_search_paths : list of Paths, optional\n        Any paths to search for Minecraft instances\n    remotes : list of URIs or (URI, str) tuples, optional\n        Any remotes you wish you manually specify. If used with `copy_from`, these\n        will overwrite any remotes pulled from the remote EnderChest. When a\n        (URI, str) tuple is provided, the second value will be used as the\n        name/alias of the remote.\n    overwrite : bool, optional\n        This method will not overwrite an EnderChest instance installed within\n        the `minecraft_root` unless the user provides `overwrite=True`\n\n    Notes\n    -----\n    - The guided / interactive specifier will only be used if no other keyword\n      arguments are provided (not even `overwrite=True`)\n    - The instance searcher will first attempt to parse any instances it finds\n      as official-launcher Minecrafts and then, if that doesn't work, will try\n      parsing them as MultiMC-style instances.\n    - The instance searcher is fully recursive, so keep that in mind before\n      passing in, say \"/\"\n    \"\"\"\n    if not minecraft_root.exists():\n        CRAFT_LOGGER.error(f\"The directory {minecraft_root} does not exist\")\n        CRAFT_LOGGER.error(\"Aborting\")\n        return\n    if (\n        copy_from is None\n        and instance_search_paths is None\n        and remotes is None\n        and not overwrite\n    ):\n        # then we go interactive\n        try:\n            ender_chest = specify_ender_chest_from_prompt(minecraft_root)\n        except (FileExistsError, RuntimeError):\n            CRAFT_LOGGER.error(\"Aborting\")\n            return\n    else:\n        try:\n            fs.ender_chest_config(minecraft_root, check_exists=True)\n            exist_message = (\n                f\"There is already an EnderChest installed to {minecraft_root}\"\n            )\n            if overwrite:\n                CRAFT_LOGGER.warning(exist_message)\n            else:\n                CRAFT_LOGGER.error(exist_message)\n                CRAFT_LOGGER.error(\"Aborting\")\n                return\n        except FileNotFoundError:\n            pass  # no existing chest? no problem!\n\n        ender_chest = EnderChest(minecraft_root)\n\n        for search_path in instance_search_paths or ():\n            for instance in gather_minecraft_instances(\n                minecraft_root, Path(search_path), None\n            ):\n                ender_chest.register_instance(instance)\n\n        if copy_from:\n            try:\n                for remote, alias in fetch_remotes_from_a_remote_ender_chest(copy_from):\n                    if alias == ender_chest.name:\n                        continue  # don't register yourself!\n                    ender_chest.register_remote(remote, alias)\n            except (RuntimeError, ValueError) as fetch_fail:\n                CRAFT_LOGGER.error(\n                    f\"Could not fetch remotes from {copy_from}:\\n  {fetch_fail}\"\n                )\n                CRAFT_LOGGER.error(\"Aborting.\")\n                return\n\n        for extra_remote in remotes or ():\n            if isinstance(extra_remote, (str, ParseResult)):\n                ender_chest.register_remote(extra_remote)\n            else:\n                ender_chest.register_remote(*extra_remote)\n\n    create_ender_chest(minecraft_root, ender_chest)\n    CRAFT_LOGGER.info(\n        \"\\nNow craft some shulker boxes via\\n$ enderchest craft shulker_box\\n\"\n    )\n</code></pre>"},{"location":"reference/enderchest/craft/#enderchest.craft.craft_shulker_box","title":"<code>craft_shulker_box(minecraft_root, name, priority=None, link_folders=None, instances=None, tags=None, hosts=None, overwrite=False)</code>","text":"<p>Craft a shulker box, either from the specified keyword arguments, or interactively via prompts</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>name</code> <code>str</code> <p>A name to give to this shulker box</p> required <code>priority</code> <code>int</code> <p>The priority for linking assets in the shulker box (higher priority shulkers are linked last)</p> <code>None</code> <code>link_folders</code> <code>list of str</code> <p>The folders that should be linked in their entirety</p> <code>None</code> <code>instances</code> <code>list of str</code> <p>The names of the instances you'd like to link to this shulker box</p> <code>None</code> <code>tags</code> <code>list of str</code> <p>You can instead (see notes) provide a list of tags where any instances with those tags will be linked to this shulker box</p> <code>None</code> <code>hosts</code> <code>list of str</code> <p>The EnderChest installations that this shulker box should be applied to</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>This method will not overwrite an existing shulker box unless the user provides <code>overwrite=True</code></p> <code>False</code>"},{"location":"reference/enderchest/craft/#enderchest.craft.craft_shulker_box--notes","title":"Notes","text":"<ul> <li>The guided / interactive specifier will only be used if no other keyword   arguments are provided (not even <code>overwrite=True</code>)</li> <li>The conditions specified by instances, tags and hosts are ANDed   together--that is, if an instance is listed explicitly, but it doesn't   match a provided tag, it will not link to this shulker box</li> <li>Wildcards are supported for instances, tags and hosts (but not link-folders)</li> <li>Not specifying instances, tags or hosts is equivalent to providing <code>[\"*\"]</code></li> <li>When values are provided to the keyword arguments, no validation is performed   to ensure that they are valid or actively in use</li> </ul> Source code in <code>enderchest/craft.py</code> <pre><code>def craft_shulker_box(\n    minecraft_root: Path,\n    name: str,\n    priority: int | None = None,\n    link_folders: Sequence[str] | None = None,\n    instances: Sequence[str] | None = None,\n    tags: Sequence[str] | None = None,\n    hosts: Sequence[str] | None = None,\n    overwrite: bool = False,\n):\n    \"\"\"Craft a shulker box, either from the specified keyword arguments, or\n    interactively via prompts\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    name : str\n        A name to give to this shulker box\n    priority : int, optional\n        The priority for linking assets in the shulker box (higher priority\n        shulkers are linked last)\n    link_folders : list of str, optional\n        The folders that should be linked in their entirety\n    instances : list of str, optional\n        The names of the instances you'd like to link to this shulker box\n    tags : list of str, optional\n        You can instead (see notes) provide a list of tags where any instances\n        with those tags will be linked to this shulker box\n    hosts : list of str, optional\n        The EnderChest installations that this shulker box should be applied to\n    overwrite : bool, optional\n        This method will not overwrite an existing shulker box unless the user\n        provides `overwrite=True`\n\n    Notes\n    -----\n    - The guided / interactive specifier will only be used if no other keyword\n      arguments are provided (not even `overwrite=True`)\n    - The conditions specified by instances, tags and hosts are ANDed\n      together--that is, if an instance is listed explicitly, but it doesn't\n      match a provided tag, it will not link to this shulker box\n    - Wildcards are supported for instances, tags and hosts (but not link-folders)\n    - Not specifying instances, tags or hosts is equivalent to providing `[\"*\"]`\n    - When values are provided to the keyword arguments, no validation is performed\n      to ensure that they are valid or actively in use\n    \"\"\"\n    if not is_valid_filename(name):\n        CRAFT_LOGGER.error(f\"{name} is not a valid name: must be usable as a filename\")\n        return\n\n    try:\n        folders = load_ender_chest(minecraft_root).shulker_box_folders\n        if (\n            priority is None\n            and link_folders is None\n            and instances is None\n            and tags is None\n            and hosts is None\n            and not overwrite\n        ):\n            try:\n                shulker_box = specify_shulker_box_from_prompt(minecraft_root, name)\n            except FileExistsError as seat_taken:\n                CRAFT_LOGGER.error(seat_taken)\n                CRAFT_LOGGER.error(\"Aborting\")\n                return\n        else:\n            config_path = fs.shulker_box_config(minecraft_root, name)\n            if config_path.exists():\n                exist_message = (\n                    f\"There is already a shulker box named {name}\"\n                    f\" in {fs.ender_chest_folder(minecraft_root)}\"\n                )\n                if overwrite:\n                    CRAFT_LOGGER.warning(exist_message)\n                else:\n                    CRAFT_LOGGER.error(exist_message)\n                    CRAFT_LOGGER.error(\"Aborting\")\n                    return\n            match_criteria: list[tuple[str, tuple[str, ...]]] = []\n            if instances is not None:\n                match_criteria.append((\"instances\", tuple(instances)))\n            if tags is not None:\n                match_criteria.append((\"tags\", tuple(tags)))\n            if hosts is not None:\n                match_criteria.append((\"hosts\", tuple(hosts)))\n            shulker_box = ShulkerBox(\n                priority=priority or 0,\n                name=name,\n                root=minecraft_root,\n                match_criteria=tuple(match_criteria),\n                link_folders=tuple(link_folders or ()),\n            )\n    except FileNotFoundError as no_ender_chest:\n        CRAFT_LOGGER.error(no_ender_chest)\n        return\n\n    create_shulker_box(minecraft_root, shulker_box, folders)\n</code></pre>"},{"location":"reference/enderchest/craft/#enderchest.craft.specify_ender_chest_from_prompt","title":"<code>specify_ender_chest_from_prompt(minecraft_root)</code>","text":"<p>Parse an EnderChest based on interactive user input</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff is in (or, at least, the one inside which you want to create your EnderChest)</p> required <p>Returns:</p> Type Description <code>EnderChest</code> <p>The resulting EnderChest</p> Source code in <code>enderchest/craft.py</code> <pre><code>def specify_ender_chest_from_prompt(minecraft_root: Path) -&gt; EnderChest:\n    \"\"\"Parse an EnderChest based on interactive user input\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff is in (or, at least, the\n        one inside which you want to create your EnderChest)\n\n    Returns\n    -------\n    EnderChest\n        The resulting EnderChest\n    \"\"\"\n    try:\n        root = fs.ender_chest_folder(minecraft_root)\n        CRAFT_LOGGER.info(\n            f\"This will overwrite the EnderChest configuration at {root}.\"\n        )\n        if not confirm(default=False):\n            message = f\"Aborting: {fs.ender_chest_config(minecraft_root)} exists.\"\n            raise FileExistsError(message)\n    except FileNotFoundError:\n        # good! Then we don't already have an EnderChest here\n        CRAFT_LOGGER.debug(f\"{minecraft_root} does not already contain an EnderChest\")\n\n    instances: list[InstanceSpec] = []\n\n    while True:\n        search_home = prompt(\n            \"Would you like to search your home directory for the official launcher?\",\n            suggestion=\"Y/n\",\n        ).lower()\n        if search_home == \"\" or search_home in YES:\n            instances.extend(\n                gather_minecraft_instances(minecraft_root, Path.home(), official=True)\n            )\n        elif search_home not in NO:\n            continue\n        break\n\n    while True:\n        search_here = prompt(\n            \"Would you like to search the current directory for MultiMC-type instances?\",\n            suggestion=\"Y/n\",\n        ).lower()\n        if search_here == \"\" or search_here in YES:\n            instances.extend(\n                gather_minecraft_instances(minecraft_root, Path(), official=False)\n            )\n        elif search_here not in NO:\n            continue\n        break\n\n    if minecraft_root.absolute() != Path().absolute():\n        while True:\n            search_mc_folder = prompt(\n                f\"Would you like to search {minecraft_root} for MultiMC-type instances?\",\n                suggestion=\"Y/n\",\n            ).lower()\n            if search_mc_folder == \"\" or search_here in YES:\n                instances.extend(\n                    gather_minecraft_instances(\n                        minecraft_root, minecraft_root, official=False\n                    )\n                )\n            elif search_mc_folder not in NO:\n                continue\n            break\n\n    CRAFT_LOGGER.info(\n        \"\\nYou can always add more instances later using\"\n        \"\\n$ enderchest gather minecraft\\n\"\n    )\n\n    while True:\n        remotes: list[tuple[ParseResult, str]] = []\n        remote_uri = prompt(\n            \"Would you like to grab the list of remotes from another EnderChest?\"\n            \"\\nIf so, enter the URI of that EnderChest now (leave empty to skip).\"\n        )\n        if remote_uri == \"\":\n            break\n        try:\n            remotes.extend(fetch_remotes_from_a_remote_ender_chest(remote_uri))\n        except Exception as fetch_fail:\n            CRAFT_LOGGER.error(\n                f\"Could not fetch remotes from {remote_uri}\\n  {fetch_fail}\"\n            )\n            if not confirm(default=True):\n                continue\n        break\n\n    CRAFT_LOGGER.info(\n        \"\\nYou can always add more remotes later using\"\n        \"\\n$ enderchest gather enderchest\\n\"\n    )\n\n    while True:\n        protocol = (\n            prompt(\n                (\n                    \"Specify the method for syncing with this EnderChest.\"\n                    \"\\nSupported protocols are: \" + \", \".join(sync.SUPPORTED_PROTOCOLS)\n                ),\n                suggestion=sync.DEFAULT_PROTOCOL,\n            ).lower()\n            or sync.DEFAULT_PROTOCOL\n        )\n\n        if protocol not in sync.SUPPORTED_PROTOCOLS:\n            CRAFT_LOGGER.error(\"Unsupported protocol\\n\")\n            continue\n        break\n\n    while True:\n        default_netloc = sync.get_default_netloc()\n        netloc = (\n            prompt(\n                (\n                    \"What's the address for accessing this machine?\"\n                    \"\\n(hostname or IP address, plus often a username)\"\n                ),\n                suggestion=default_netloc,\n            )\n            or default_netloc\n        )\n\n        uri = ParseResult(\n            scheme=protocol,\n            netloc=netloc,\n            path=minecraft_root.as_posix(),\n            params=\"\",\n            query=\"\",\n            fragment=\"\",\n        )\n        if not uri.hostname:\n            CRAFT_LOGGER.error(\"Invalid hostname\")\n            continue\n        break\n\n    while True:\n        name = (\n            prompt(\"Provide a name for this EnderChest\", suggestion=uri.hostname)\n            or uri.hostname\n        )\n        if name in (alias for _, alias in remotes):\n            CRAFT_LOGGER.error(\n                f\"The name {name} is already in use. Choose a different name.\"\n            )\n            continue\n        break\n\n    ender_chest = EnderChest(uri, name, remotes, instances)\n\n    CRAFT_LOGGER.info(\n        \"\\n%s\\nPreparing to generate an EnderChest with the above configuration.\",\n        ender_chest.write_to_cfg(),\n    )\n\n    if not confirm(default=True):\n        raise RuntimeError(\"EnderChest creation aborted.\")\n\n    return ender_chest\n</code></pre>"},{"location":"reference/enderchest/craft/#enderchest.craft.specify_shulker_box_from_prompt","title":"<code>specify_shulker_box_from_prompt(minecraft_root, name)</code>","text":"<p>Parse a shulker box based on interactive user input</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>name</code> <code>str</code> <p>The name to give to the shulker box</p> required <p>Returns:</p> Type Description <code>ShulkerBox</code> <p>The resulting ShulkerBox</p> Source code in <code>enderchest/craft.py</code> <pre><code>def specify_shulker_box_from_prompt(minecraft_root: Path, name: str) -&gt; ShulkerBox:\n    \"\"\"Parse a shulker box based on interactive user input\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    name : str\n        The name to give to the shulker box\n\n    Returns\n    -------\n    ShulkerBox\n        The resulting ShulkerBox\n    \"\"\"\n    ender_chest = load_ender_chest(minecraft_root)\n    shulker_root = fs.shulker_box_root(minecraft_root, name)\n    if shulker_root in shulker_root.parent.iterdir():\n        if not shulker_root.is_dir():\n            raise FileExistsError(\n                f\"A file named {name} already exists in your EnderChest folder.\"\n            )\n        CRAFT_LOGGER.warning(\n            f\"There is already a folder named {name} in your EnderChest folder.\"\n        )\n        if not confirm(default=False):\n            raise FileExistsError(\n                f\"There is already a folder named {name} in your EnderChest folder.\"\n            )\n\n    shulker_box = ShulkerBox(0, name, shulker_root, (), ())\n\n    def refresh_ender_chest_instance_list() -&gt; Sequence[InstanceSpec]:\n        \"\"\"The primary reason to lambda-fy this is to re-print the instance list.\"\"\"\n        return load_ender_chest_instances(minecraft_root)\n\n    instances = refresh_ender_chest_instance_list()\n\n    explicit_type = \"name\"\n    if len(instances) &gt; 0:\n        explicit_type = \"number\"\n    while True:\n        selection_type = prompt(\n            f\"Would you like to specify instances by [F]ilter or by [N]{explicit_type[1:]}?\"\n        ).lower()\n        match selection_type:\n            case \"f\" | \"filter\":\n                shulker_box = _prompt_for_filters(shulker_box, instances)\n            case \"n\":\n                if explicit_type == \"name\":\n                    shulker_box = _prompt_for_instance_names(shulker_box)\n                else:  # if explicit_type == \"number\"\n                    shulker_box = _prompt_for_instance_numbers(\n                        shulker_box, instances, refresh_ender_chest_instance_list\n                    )\n            case \"name\":\n                # yeah, this is always available\n                shulker_box = _prompt_for_instance_names(shulker_box)\n            case \"number\":\n                if explicit_type == \"name\":\n                    continue\n                shulker_box = _prompt_for_instance_numbers(\n                    shulker_box, instances, refresh_ender_chest_instance_list\n                )\n            case _:\n                continue\n        break\n\n    while True:\n        selection_type = prompt(\n            \"Folders to Link?\"\n            \"\\nThe [G]lobal set is:\"\n            f' {\", \".join(ender_chest.global_link_folders) or \"(none)\"}'\n            \"\\nThe [S]tandard set is:\"\n            f' {\", \".join(ender_chest.standard_link_folders) or \"(none)\"}'\n            \"\\nYou can also choose [N]one or to [M]anually specify the folders to link\",\n            suggestion=\"S\",\n        ).lower()\n        match selection_type:\n            case \"n\" | \"none\":\n                link_folders: tuple[str, ...] = ()\n            case \"g\" | \"global\" | \"global set\":\n                link_folders = tuple(ender_chest.global_link_folders)\n            case \"s\" | \"standard\" | \"standard set\" | \"\":\n                link_folders = tuple(ender_chest.standard_link_folders)\n            case \"m\" | \"manual\" | \"manually specify\":\n                folder_choices = prompt(\n                    \"Specify the folders to link using a comma-separated list\"\n                    \" (wildcards are not allowed)\"\n                )\n                link_folders = tuple(\n                    folder.strip() for folder in folder_choices.split(\",\")\n                )\n            case _:\n                continue\n        break\n\n    while True:\n        # this is such a kludge\n        existing_shulker_boxes = load_shulker_boxes(\n            minecraft_root, log_level=logging.DEBUG\n        )\n        if existing_shulker_boxes:\n            _report_shulker_boxes(\n                existing_shulker_boxes, logging.INFO, \"the current EnderChest\"\n            )\n\n        value = (\n            prompt(\n                (\n                    \"What priority value should be assigned to this shulker box?\"\n                    \"\\nhigher number = applied later\"\n                ),\n                suggestion=\"0\",\n            )\n            or \"0\"\n        )\n        try:\n            priority = int(value)\n        except ValueError:\n            continue\n        break\n\n    while True:\n        _ = load_ender_chest_remotes(minecraft_root)  # to display some log messages\n        values = (\n            prompt(\n                (\n                    \"What hosts (EnderChest installations) should use this shulker box?\"\n                    \"\\nProvide a comma-separated list (wildcards are allowed)\"\n                    \"\\nand remember to include the name of this EnderChest\"\n                    f' (\"{ender_chest.name}\")'\n                ),\n                suggestion=\"*\",\n            )\n            or \"*\"\n        )\n        hosts = tuple(host.strip() for host in values.split(\",\"))\n\n        host = ender_chest.name\n\n        if not shulker_box._replace(match_criteria=((\"hosts\", hosts),)).matches_host(\n            host\n        ):\n            CRAFT_LOGGER.warning(\n                \"This shulker box will not link to any instances on this machine\"\n            )\n            if not confirm(default=False):\n                continue\n        break\n\n    shulker_box = shulker_box._replace(\n        priority=priority,\n        match_criteria=shulker_box.match_criteria + ((\"hosts\", hosts),),\n        link_folders=link_folders,\n    )\n\n    CRAFT_LOGGER.info(\n        \"\\n%sPreparing to generate a shulker box with the above configuration.\",\n        shulker_box.write_to_cfg(),\n    )\n\n    if not confirm(default=True):\n        raise RuntimeError(\"Shulker box creation aborted.\")\n\n    return shulker_box\n</code></pre>"},{"location":"reference/enderchest/enderchest/","title":"enderchest","text":"<p>Specification and configuration of an EnderChest</p>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.EnderChest","title":"<code>EnderChest</code>  <code>dataclass</code>","text":"<p>Configuration of an EnderChest</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>URI or Path</code> <p>The \"address\" of this EnderChest, ideally as it can be accessed from other EnderChest installations, including both the path to where the EnderChest folder can be found (that is, the parent of the EnderChest folder itself, aka the \"minecraft_root\"), its net location including credentials, and the protocol that should be used to perform the syncing. All that being said, if just a path is provided, the constructor will try to figure out the rest.</p> required <code>name</code> <code>str</code> <p>A unique name to give to this EnderChest installation. If None is provided, this will be taken from the hostname of the supplied URI.</p> <code>None</code> <code>instances</code> <code>list-like of InstanceSpec</code> <p>The list of instances to register with this EnderChest installation</p> <code>None</code> <code>remotes</code> <code>list-like of URI, or (URI, str) tuples</code> <p>A list of other installations that this EnderChest should be aware of (for syncing purposes). When a (URI, str) tuple is provided, the second value will be used as the name/alias of the remote.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The unique name of this EnderChest installation. This is most commonly the computer's hostname, but one can configure multiple EnderChests to coexist on the same system (either for the sake of having a \"cold\" backup or for multi-user systems).</p> <code>uri</code> <code>str</code> <p>The complete URI of this instance</p> <code>root</code> <code>Path</code> <p>The path to this EnderChest folder</p> <code>instances</code> <code>list-like of InstanceSpec</code> <p>The instances registered with this EnderChest</p> <code>remotes</code> <code>list-like of (ParseResult, str) pairs</code> <p>The other EnderChest installations this EnderChest is aware of, paired with their aliases</p> <code>offer_to_update_symlink_allowlist</code> <code>bool</code> <p>By default, EnderChest will offer to create or update <code>allowed_symlinks.txt</code> on any 1.20+ instances that do not already blanket allow links into EnderChest. EnderChest will never modify that or any other Minecraft file without your express consent. If you would prefer to edit these files yourself (or simply not symlink your world saves), change this parameter to False.</p> <code>sync_confirm_wait</code> <code>bool or int</code> <p>The default behavior when syncing EnderChests is to first perform a dry run of every sync operation and then wait 5 seconds before proceeding with the real sync. The idea is to give the user time to interrupt the sync if the dry run looks wrong. This can be changed by either raising or lowering the value of confirm, by disabling the dry-run-first behavior entirely (<code>confirm=False</code>) or by requiring that the user explicitly confirms the sync (<code>confirm=True</code>). This default behavior can also be overridden when actually calling the sync commands.</p> <code>place_after_open</code> <code>bool</code> <p>By default, EnderChest will follow up any <code>enderchest open</code> operation with an <code>enderchest place</code> to refresh any changed symlinks. This functionality can be disabled by setting this parameter to False.</p> <code>do_not_sync</code> <code>list of str</code> <p>Glob patterns of files that should not be synced between EnderChest installations. By default, this list comprises <code>EnderChest/enderchest.cfg</code>, any top-level folders starting with a \".\" (like .git) and <code>.DS_Store</code> (for all you mac gamers).</p> <code>shulker_box_folders</code> <code>list of str</code> <p>The folders that will be created inside each new shulker box</p> <code>standard_link_folders</code> <code>list of str</code> <p>The default set of \"link folders\" when crafting a new shulker box</p> <code>global_link_folders</code> <code>list of str</code> <p>The \"global\" set of \"link folders,\" offered as a suggestion when crafting a new shulker box</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>@dataclass(init=False, repr=False, eq=False)\nclass EnderChest:\n    \"\"\"Configuration of an EnderChest\n\n    Parameters\n    ----------\n    uri : URI or Path\n        The \"address\" of this EnderChest, ideally as it can be accessed from other\n        EnderChest installations, including both the path to where\n        the EnderChest folder can be found (that is, the parent of the\n        EnderChest folder itself, aka the \"minecraft_root\"), its net location\n        including credentials, and the protocol that should be used to perform\n        the syncing. All that being said, if just a path is provided, the\n        constructor will try to figure out the rest.\n    name : str, optional\n        A unique name to give to this EnderChest installation. If None is\n        provided, this will be taken from the hostname of the supplied URI.\n    instances : list-like of InstanceSpec, optional\n        The list of instances to register with this EnderChest installation\n    remotes : list-like of URI, or (URI, str) tuples\n        A list of other installations that this EnderChest should be aware of\n        (for syncing purposes). When a (URI, str) tuple is provided, the\n        second value will be used as the name/alias of the remote.\n\n    Attributes\n    ----------\n    name : str\n        The unique name of this EnderChest installation. This is most commonly\n        the computer's hostname, but one can configure multiple EnderChests\n        to coexist on the same system (either for the sake of having a \"cold\"\n        backup or for multi-user systems).\n    uri : str\n        The complete URI of this instance\n    root : Path\n        The path to this EnderChest folder\n    instances : list-like of InstanceSpec\n        The instances registered with this EnderChest\n    remotes : list-like of (ParseResult, str) pairs\n        The other EnderChest installations this EnderChest is aware of, paired\n        with their aliases\n    offer_to_update_symlink_allowlist : bool\n        By default, EnderChest will offer to create or update `allowed_symlinks.txt`\n        on any 1.20+ instances that do not already blanket allow links into\n        EnderChest. **EnderChest will never modify that or any other Minecraft\n        file without your express consent.** If you would prefer to edit these\n        files yourself (or simply not symlink your world saves), change this\n        parameter to False.\n    sync_confirm_wait : bool or int\n        The default behavior when syncing EnderChests is to first perform a dry\n        run of every sync operation and then wait 5 seconds before proceeding with the\n        real sync. The idea is to give the user time to interrupt the sync if\n        the dry run looks wrong. This can be changed by either raising or lowering\n        the value of confirm, by disabling the dry-run-first behavior entirely\n        (`confirm=False`) or by requiring that the user explicitly confirms\n        the sync (`confirm=True`). This default behavior can also be overridden\n        when actually calling the sync commands.\n    place_after_open: bool\n        By default, EnderChest will follow up any `enderchest open` operation\n        with an `enderchest place` to refresh any changed symlinks. This\n        functionality can be disabled by setting this parameter to False.\n    do_not_sync : list of str\n        Glob patterns of files that should not be synced between EnderChest\n        installations. By default, this list comprises `EnderChest/enderchest.cfg`,\n        any top-level folders starting with a \".\" (like .git) and\n        `.DS_Store` (for all you mac gamers).\n    shulker_box_folders : list of str\n        The folders that will be created inside each new shulker box\n    standard_link_folders : list of str\n        The default set of \"link folders\" when crafting a new shulker box\n    global_link_folders : list of str\n        The \"global\" set of \"link folders,\" offered as a suggestion when\n        crafting a new shulker box\n    \"\"\"\n\n    name: str\n    _uri: ParseResult\n    _instances: list[i.InstanceSpec]\n    _remotes: dict[str, ParseResult]\n    offer_to_update_symlink_allowlist: bool\n    sync_confirm_wait: bool | int\n    place_after_open: bool\n    do_not_sync: list[str]\n    shulker_box_folders: list[str]\n    standard_link_folders: list[str]\n    global_link_folders: list[str]\n\n    def __init__(\n        self,\n        uri: str | ParseResult | Path,\n        name: str | None = None,\n        remotes: Iterable[str | ParseResult | tuple[str, str] | tuple[ParseResult, str]]\n        | None = None,\n        instances: Iterable[i.InstanceSpec] | None = None,\n    ):\n        for setting, value in _DEFAULTS:\n            setattr(self, setting, list(value) if isinstance(value, tuple) else value)\n\n        try:\n            if isinstance(uri, ParseResult):\n                self._uri = uri\n            elif isinstance(uri, Path):\n                self._uri = urlparse(uri.absolute().as_uri())\n            else:\n                self._uri = urlparse(uri)\n        except AttributeError as parse_problem:  # pragma: no cover\n            raise ValueError(f\"{uri} is not a valid URI\") from parse_problem\n\n        if not self._uri.netloc:\n            self._uri = self._uri._replace(netloc=sync.get_default_netloc())\n        if not self._uri.scheme:\n            self._uri = self._uri._replace(scheme=sync.DEFAULT_PROTOCOL)\n\n        self.name = name or self._uri.hostname or gethostname()\n\n        self._instances = []\n        self._remotes = {}\n\n        for instance in instances or ():\n            self.register_instance(instance)\n\n        for remote in remotes or ():\n            if isinstance(remote, (str, ParseResult)):\n                self.register_remote(remote)\n            else:\n                self.register_remote(*remote)\n\n    @property\n    def uri(self) -&gt; str:\n        return self._uri.geturl()\n\n    def __repr__(self) -&gt; str:\n        return f\"EnderChest({self.uri, self.name})\"\n\n    @property\n    def root(self) -&gt; Path:\n        return fs.ender_chest_folder(abspath_from_uri(self._uri), check_exists=False)\n\n    @property\n    def instances(self) -&gt; tuple[i.InstanceSpec, ...]:\n        return tuple(self._instances)\n\n    def register_instance(self, instance: i.InstanceSpec) -&gt; i.InstanceSpec:\n        \"\"\"Register a new Minecraft installation\n\n        Parameters\n        ----------\n        instance : InstanceSpec\n            The instance to register\n\n        Returns\n        -------\n        InstanceSpec\n            The spec of the instance as it was actually registered (in case the\n            name changed or somesuch)\n\n        Notes\n        -----\n        - If the instance's name is already assigned to a registered instance,\n          this method will choose a new one\n        - If this instance shares a path with an existing instance, it will\n          replace that instance\n        \"\"\"\n        matching_instances: list[i.InstanceSpec] = []\n        for old_instance in self._instances:\n            if i.equals(abspath_from_uri(self._uri), instance, old_instance):\n                matching_instances.append(old_instance)\n                self._instances.remove(old_instance)\n\n        instance = i.merge(*matching_instances, instance)\n\n        name = instance.name\n        counter = 0\n        taken_names = {old_instance.name for old_instance in self._instances}\n        while True:\n            if name not in taken_names:\n                break\n            counter += 1\n            name = f\"{instance.name}.{counter}\"\n\n        GATHER_LOGGER.debug(f\"Registering instance {name} at {instance.root}\")\n        self._instances.append(instance._replace(name=name))\n        return self._instances[-1]\n\n    @property\n    def remotes(self) -&gt; tuple[tuple[ParseResult, str], ...]:\n        return tuple((remote, alias) for alias, remote in self._remotes.items())\n\n    def register_remote(\n        self, remote: str | ParseResult, alias: str | None = None\n    ) -&gt; None:\n        \"\"\"Register a new remote EnderChest installation (or update an existing\n        registry)\n\n        Parameters\n        ----------\n        remote : URI\n            The URI of the remote\n        alias : str, optional\n            an alias to give to this remote. If None is provided, the URI's hostname\n            will be used.\n\n        Raises\n        ------\n        ValueError\n            If the provided remote is invalid\n        \"\"\"\n        try:\n            remote = remote if isinstance(remote, ParseResult) else urlparse(remote)\n            alias = alias or remote.hostname\n            if not alias:  # pragma: no cover\n                raise AttributeError(f\"{remote.geturl()} has no hostname\")\n            GATHER_LOGGER.debug(\"Registering remote %s (%s)\", remote.geturl(), alias)\n            self._remotes[alias] = remote\n        except AttributeError as parse_problem:  # pragma: no cover\n            raise ValueError(f\"{remote} is not a valid URI\") from parse_problem\n\n    @classmethod\n    def from_cfg(cls, config_file: Path) -&gt; \"EnderChest\":\n        \"\"\"Parse an EnderChest from its config file\n\n        Parameters\n        ----------\n        config_file : Path\n            The path to the config file\n\n        Returns\n        -------\n        EnderChest\n            The resulting EnderChest\n\n        Raises\n        ------\n        ValueError\n            If the config file at that location cannot be parsed\n        FileNotFoundError\n            If there is no config file at the specified location\n        \"\"\"\n        GATHER_LOGGER.debug(\"Reading config file from %s\", config_file)\n        config = cfg.read_cfg(config_file)\n\n        # All I'm gonna say is that Windows pathing is the worst\n        path = urlparse(config_file.absolute().parent.parent.as_uri()).path\n\n        instances: list[i.InstanceSpec] = []\n        remotes: list[str | tuple[str, str]] = []\n\n        requires_rewrite = False\n\n        scheme: str | None = None\n        netloc: str | None = None\n        name: str | None = None\n        sync_confirm_wait: str | None = None\n        place_after_open: bool | None = None\n        offer_to_update_symlink_allowlist: bool = True\n        do_not_sync: list[str] | None = None\n        folder_defaults: dict[str, list[str] | None] = {\n            \"shulker_box_folders\": None,\n            \"standard_link_folders\": None,\n            \"global_link_folders\": None,\n        }\n\n        for section in config.sections():\n            if section == \"properties\":\n                scheme = config[section].get(\"sync-protocol\")\n                netloc = config[section].get(\"address\")\n                name = config[section].get(\"name\")\n                sync_confirm_wait = config[section].get(\"sync-confirmation-time\")\n                place_after_open = config[section].getboolean(\"place-after-open\")\n                offer_to_update_symlink_allowlist = config[section].getboolean(\n                    \"offer-to-update-symlink-allowlist\", True\n                )\n                if \"do-not-sync\" in config[section].keys():\n                    do_not_sync = cfg.parse_ini_list(\n                        config[section][\"do-not-sync\"] or \"\"\n                    )\n                for setting in folder_defaults.keys():\n                    setting_key = setting.replace(\"_\", \"-\")\n                    if setting_key in config[section].keys():\n                        folder_defaults[setting] = cfg.parse_ini_list(\n                            config[section][setting_key] or \"\"\n                        )\n            elif section == \"remotes\":\n                for remote in config[section].items():\n                    if remote[1] is None:\n                        raise ValueError(\"All remotes must have an alias specified\")\n                    remotes.append((remote[1], remote[0]))\n            else:\n                # TODO: flag requires_rewrite if instance was normalized\n                instances.append(i.InstanceSpec.from_cfg(config[section]))\n\n        scheme = scheme or sync.DEFAULT_PROTOCOL\n        netloc = netloc or sync.get_default_netloc()\n        uri = ParseResult(\n            scheme=scheme, netloc=netloc, path=path, params=\"\", query=\"\", fragment=\"\"\n        )\n\n        ender_chest = EnderChest(uri, name, remotes, instances)\n        if sync_confirm_wait is not None:\n            match sync_confirm_wait.lower():\n                case \"true\" | \"prompt\" | \"yes\" | \"confirm\":\n                    ender_chest.sync_confirm_wait = True\n                case \"false\" | \"no\" | \"skip\":\n                    ender_chest.sync_confirm_wait = False\n                case _:\n                    try:\n                        ender_chest.sync_confirm_wait = int(sync_confirm_wait)\n                    except ValueError as bad_input:\n                        raise ValueError(\n                            \"Invalid value for sync-confirmation-time:\"\n                            f\" {sync_confirm_wait}\"\n                        ) from bad_input\n        if place_after_open is None:\n            GATHER_LOGGER.warning(\n                \"This EnderChest does not have a value set for place-after-open.\"\n                \"\\nIt is being set to False for now. To enable this functionality,\"\n                \"\\nedit the value in %s\",\n                config_file,\n            )\n            ender_chest.place_after_open = False\n            requires_rewrite = True\n        else:\n            ender_chest.place_after_open = place_after_open\n\n        ender_chest.offer_to_update_symlink_allowlist = (\n            offer_to_update_symlink_allowlist\n        )\n\n        if do_not_sync is not None:\n            ender_chest.do_not_sync = do_not_sync\n            chest_cfg_exclusion = \"/\".join(\n                (fs.ENDER_CHEST_FOLDER_NAME, fs.ENDER_CHEST_CONFIG_NAME)\n            )\n            if chest_cfg_exclusion not in do_not_sync:\n                GATHER_LOGGER.warning(\n                    \"This EnderChest was not configured to exclude the EnderChest\"\n                    \" config file from sync operations.\"\n                    \"\\nThat is being fixed now.\"\n                )\n                ender_chest.do_not_sync.insert(0, chest_cfg_exclusion)\n                requires_rewrite = True\n        for setting in folder_defaults:\n            if folder_defaults[setting] is None:\n                folder_defaults[setting] = dict(_DEFAULTS)[setting]  # type: ignore\n                # requires_rewrite = True  # though I'm considering it\n            setattr(ender_chest, setting, folder_defaults[setting])\n\n        if requires_rewrite:\n            ender_chest.write_to_cfg(config_file)\n            return cls.from_cfg(config_file)\n        return ender_chest\n\n    def write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n        \"\"\"Write this EnderChest's configuration to INI\n\n        Parameters\n        ----------\n        config_file : Path, optional\n            The path to the config file, assuming you'd like to write the\n            contents to file\n\n        Returns\n        -------\n        str\n            An INI-syntax rendering of this EnderChest's config\n\n        Notes\n        -----\n        The \"root\" attribute is ignored for this method\n        \"\"\"\n        properties: dict[str, Any] = {\n            \"name\": self.name,\n            \"address\": self._uri.netloc,\n            \"sync-protocol\": self._uri.scheme,\n        }\n        if self.sync_confirm_wait is True:\n            properties[\"sync-confirmation-time\"] = \"prompt\"\n        else:\n            properties[\"sync-confirmation-time\"] = self.sync_confirm_wait\n\n        for setting, _ in _DEFAULTS:\n            if setting == \"sync_confirm_wait\":\n                continue  # already did this one\n            setting_key = setting.replace(\"_\", \"-\")\n            properties[setting_key] = getattr(self, setting)\n\n        remotes: dict[str, str] = {name: uri.geturl() for uri, name in self.remotes}\n\n        instances: dict[str, dict[str, Any]] = {}\n\n        for instance in self.instances:\n            instances[instance.name] = {\n                \"root\": instance.root,\n                \"minecraft-version\": instance.minecraft_versions,\n                \"modloader\": instance.modloader,\n                \"groups\": instance.groups_,\n                \"tags\": instance.tags_,\n            }\n\n        config = cfg.dumps(\n            fs.ENDER_CHEST_CONFIG_NAME, properties, remotes=remotes, **instances\n        )\n\n        if config_file:\n            CRAFT_LOGGER.debug(\"Writing configuration file to %s\", config_file)\n            config_file.write_text(config)\n        return config\n</code></pre>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.EnderChest.from_cfg","title":"<code>from_cfg(config_file)</code>  <code>classmethod</code>","text":"<p>Parse an EnderChest from its config file</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path</code> <p>The path to the config file</p> required <p>Returns:</p> Type Description <code>EnderChest</code> <p>The resulting EnderChest</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the config file at that location cannot be parsed</p> <code>FileNotFoundError</code> <p>If there is no config file at the specified location</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>@classmethod\ndef from_cfg(cls, config_file: Path) -&gt; \"EnderChest\":\n    \"\"\"Parse an EnderChest from its config file\n\n    Parameters\n    ----------\n    config_file : Path\n        The path to the config file\n\n    Returns\n    -------\n    EnderChest\n        The resulting EnderChest\n\n    Raises\n    ------\n    ValueError\n        If the config file at that location cannot be parsed\n    FileNotFoundError\n        If there is no config file at the specified location\n    \"\"\"\n    GATHER_LOGGER.debug(\"Reading config file from %s\", config_file)\n    config = cfg.read_cfg(config_file)\n\n    # All I'm gonna say is that Windows pathing is the worst\n    path = urlparse(config_file.absolute().parent.parent.as_uri()).path\n\n    instances: list[i.InstanceSpec] = []\n    remotes: list[str | tuple[str, str]] = []\n\n    requires_rewrite = False\n\n    scheme: str | None = None\n    netloc: str | None = None\n    name: str | None = None\n    sync_confirm_wait: str | None = None\n    place_after_open: bool | None = None\n    offer_to_update_symlink_allowlist: bool = True\n    do_not_sync: list[str] | None = None\n    folder_defaults: dict[str, list[str] | None] = {\n        \"shulker_box_folders\": None,\n        \"standard_link_folders\": None,\n        \"global_link_folders\": None,\n    }\n\n    for section in config.sections():\n        if section == \"properties\":\n            scheme = config[section].get(\"sync-protocol\")\n            netloc = config[section].get(\"address\")\n            name = config[section].get(\"name\")\n            sync_confirm_wait = config[section].get(\"sync-confirmation-time\")\n            place_after_open = config[section].getboolean(\"place-after-open\")\n            offer_to_update_symlink_allowlist = config[section].getboolean(\n                \"offer-to-update-symlink-allowlist\", True\n            )\n            if \"do-not-sync\" in config[section].keys():\n                do_not_sync = cfg.parse_ini_list(\n                    config[section][\"do-not-sync\"] or \"\"\n                )\n            for setting in folder_defaults.keys():\n                setting_key = setting.replace(\"_\", \"-\")\n                if setting_key in config[section].keys():\n                    folder_defaults[setting] = cfg.parse_ini_list(\n                        config[section][setting_key] or \"\"\n                    )\n        elif section == \"remotes\":\n            for remote in config[section].items():\n                if remote[1] is None:\n                    raise ValueError(\"All remotes must have an alias specified\")\n                remotes.append((remote[1], remote[0]))\n        else:\n            # TODO: flag requires_rewrite if instance was normalized\n            instances.append(i.InstanceSpec.from_cfg(config[section]))\n\n    scheme = scheme or sync.DEFAULT_PROTOCOL\n    netloc = netloc or sync.get_default_netloc()\n    uri = ParseResult(\n        scheme=scheme, netloc=netloc, path=path, params=\"\", query=\"\", fragment=\"\"\n    )\n\n    ender_chest = EnderChest(uri, name, remotes, instances)\n    if sync_confirm_wait is not None:\n        match sync_confirm_wait.lower():\n            case \"true\" | \"prompt\" | \"yes\" | \"confirm\":\n                ender_chest.sync_confirm_wait = True\n            case \"false\" | \"no\" | \"skip\":\n                ender_chest.sync_confirm_wait = False\n            case _:\n                try:\n                    ender_chest.sync_confirm_wait = int(sync_confirm_wait)\n                except ValueError as bad_input:\n                    raise ValueError(\n                        \"Invalid value for sync-confirmation-time:\"\n                        f\" {sync_confirm_wait}\"\n                    ) from bad_input\n    if place_after_open is None:\n        GATHER_LOGGER.warning(\n            \"This EnderChest does not have a value set for place-after-open.\"\n            \"\\nIt is being set to False for now. To enable this functionality,\"\n            \"\\nedit the value in %s\",\n            config_file,\n        )\n        ender_chest.place_after_open = False\n        requires_rewrite = True\n    else:\n        ender_chest.place_after_open = place_after_open\n\n    ender_chest.offer_to_update_symlink_allowlist = (\n        offer_to_update_symlink_allowlist\n    )\n\n    if do_not_sync is not None:\n        ender_chest.do_not_sync = do_not_sync\n        chest_cfg_exclusion = \"/\".join(\n            (fs.ENDER_CHEST_FOLDER_NAME, fs.ENDER_CHEST_CONFIG_NAME)\n        )\n        if chest_cfg_exclusion not in do_not_sync:\n            GATHER_LOGGER.warning(\n                \"This EnderChest was not configured to exclude the EnderChest\"\n                \" config file from sync operations.\"\n                \"\\nThat is being fixed now.\"\n            )\n            ender_chest.do_not_sync.insert(0, chest_cfg_exclusion)\n            requires_rewrite = True\n    for setting in folder_defaults:\n        if folder_defaults[setting] is None:\n            folder_defaults[setting] = dict(_DEFAULTS)[setting]  # type: ignore\n            # requires_rewrite = True  # though I'm considering it\n        setattr(ender_chest, setting, folder_defaults[setting])\n\n    if requires_rewrite:\n        ender_chest.write_to_cfg(config_file)\n        return cls.from_cfg(config_file)\n    return ender_chest\n</code></pre>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.EnderChest.register_instance","title":"<code>register_instance(instance)</code>","text":"<p>Register a new Minecraft installation</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>InstanceSpec</code> <p>The instance to register</p> required <p>Returns:</p> Type Description <code>InstanceSpec</code> <p>The spec of the instance as it was actually registered (in case the name changed or somesuch)</p>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.EnderChest.register_instance--notes","title":"Notes","text":"<ul> <li>If the instance's name is already assigned to a registered instance,   this method will choose a new one</li> <li>If this instance shares a path with an existing instance, it will   replace that instance</li> </ul> Source code in <code>enderchest/enderchest.py</code> <pre><code>def register_instance(self, instance: i.InstanceSpec) -&gt; i.InstanceSpec:\n    \"\"\"Register a new Minecraft installation\n\n    Parameters\n    ----------\n    instance : InstanceSpec\n        The instance to register\n\n    Returns\n    -------\n    InstanceSpec\n        The spec of the instance as it was actually registered (in case the\n        name changed or somesuch)\n\n    Notes\n    -----\n    - If the instance's name is already assigned to a registered instance,\n      this method will choose a new one\n    - If this instance shares a path with an existing instance, it will\n      replace that instance\n    \"\"\"\n    matching_instances: list[i.InstanceSpec] = []\n    for old_instance in self._instances:\n        if i.equals(abspath_from_uri(self._uri), instance, old_instance):\n            matching_instances.append(old_instance)\n            self._instances.remove(old_instance)\n\n    instance = i.merge(*matching_instances, instance)\n\n    name = instance.name\n    counter = 0\n    taken_names = {old_instance.name for old_instance in self._instances}\n    while True:\n        if name not in taken_names:\n            break\n        counter += 1\n        name = f\"{instance.name}.{counter}\"\n\n    GATHER_LOGGER.debug(f\"Registering instance {name} at {instance.root}\")\n    self._instances.append(instance._replace(name=name))\n    return self._instances[-1]\n</code></pre>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.EnderChest.register_remote","title":"<code>register_remote(remote, alias=None)</code>","text":"<p>Register a new remote EnderChest installation (or update an existing registry)</p> <p>Parameters:</p> Name Type Description Default <code>remote</code> <code>URI</code> <p>The URI of the remote</p> required <code>alias</code> <code>str</code> <p>an alias to give to this remote. If None is provided, the URI's hostname will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided remote is invalid</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>def register_remote(\n    self, remote: str | ParseResult, alias: str | None = None\n) -&gt; None:\n    \"\"\"Register a new remote EnderChest installation (or update an existing\n    registry)\n\n    Parameters\n    ----------\n    remote : URI\n        The URI of the remote\n    alias : str, optional\n        an alias to give to this remote. If None is provided, the URI's hostname\n        will be used.\n\n    Raises\n    ------\n    ValueError\n        If the provided remote is invalid\n    \"\"\"\n    try:\n        remote = remote if isinstance(remote, ParseResult) else urlparse(remote)\n        alias = alias or remote.hostname\n        if not alias:  # pragma: no cover\n            raise AttributeError(f\"{remote.geturl()} has no hostname\")\n        GATHER_LOGGER.debug(\"Registering remote %s (%s)\", remote.geturl(), alias)\n        self._remotes[alias] = remote\n    except AttributeError as parse_problem:  # pragma: no cover\n        raise ValueError(f\"{remote} is not a valid URI\") from parse_problem\n</code></pre>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.EnderChest.write_to_cfg","title":"<code>write_to_cfg(config_file=None)</code>","text":"<p>Write this EnderChest's configuration to INI</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path</code> <p>The path to the config file, assuming you'd like to write the contents to file</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>An INI-syntax rendering of this EnderChest's config</p>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.EnderChest.write_to_cfg--notes","title":"Notes","text":"<p>The \"root\" attribute is ignored for this method</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>def write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n    \"\"\"Write this EnderChest's configuration to INI\n\n    Parameters\n    ----------\n    config_file : Path, optional\n        The path to the config file, assuming you'd like to write the\n        contents to file\n\n    Returns\n    -------\n    str\n        An INI-syntax rendering of this EnderChest's config\n\n    Notes\n    -----\n    The \"root\" attribute is ignored for this method\n    \"\"\"\n    properties: dict[str, Any] = {\n        \"name\": self.name,\n        \"address\": self._uri.netloc,\n        \"sync-protocol\": self._uri.scheme,\n    }\n    if self.sync_confirm_wait is True:\n        properties[\"sync-confirmation-time\"] = \"prompt\"\n    else:\n        properties[\"sync-confirmation-time\"] = self.sync_confirm_wait\n\n    for setting, _ in _DEFAULTS:\n        if setting == \"sync_confirm_wait\":\n            continue  # already did this one\n        setting_key = setting.replace(\"_\", \"-\")\n        properties[setting_key] = getattr(self, setting)\n\n    remotes: dict[str, str] = {name: uri.geturl() for uri, name in self.remotes}\n\n    instances: dict[str, dict[str, Any]] = {}\n\n    for instance in self.instances:\n        instances[instance.name] = {\n            \"root\": instance.root,\n            \"minecraft-version\": instance.minecraft_versions,\n            \"modloader\": instance.modloader,\n            \"groups\": instance.groups_,\n            \"tags\": instance.tags_,\n        }\n\n    config = cfg.dumps(\n        fs.ENDER_CHEST_CONFIG_NAME, properties, remotes=remotes, **instances\n    )\n\n    if config_file:\n        CRAFT_LOGGER.debug(\"Writing configuration file to %s\", config_file)\n        config_file.write_text(config)\n    return config\n</code></pre>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.create_ender_chest","title":"<code>create_ender_chest(minecraft_root, ender_chest)</code>","text":"<p>Create an EnderChest based on the provided configuration</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff is in (or, at least, the one inside which you want to create your EnderChest)</p> required <code>ender_chest</code> <code>EnderChest</code> <p>The spec of the chest to create</p> required"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.create_ender_chest--notes","title":"Notes","text":"<ul> <li>The \"root\" attribute of the EnderChest config will be ignored--instead   the EnderChest will be created at /EnderChest <li>This method does not check to see if there is already an EnderChest set   up at the specified location--if one exists, its config will   be overwritten</li> Source code in <code>enderchest/enderchest.py</code> <pre><code>def create_ender_chest(minecraft_root: Path, ender_chest: EnderChest) -&gt; None:\n    \"\"\"Create an EnderChest based on the provided configuration\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff is in (or, at least, the\n        one inside which you want to create your EnderChest)\n    ender_chest : EnderChest\n        The spec of the chest to create\n\n    Notes\n    -----\n    - The \"root\" attribute of the EnderChest config will be ignored--instead\n      the EnderChest will be created at &lt;minecraft_root&gt;/EnderChest\n    - This method does not check to see if there is already an EnderChest set\n      up at the specified location--if one exists, its config will\n      be overwritten\n    \"\"\"\n    root = fs.ender_chest_folder(minecraft_root, check_exists=False)\n    root.mkdir(exist_ok=True)\n\n    config_path = fs.ender_chest_config(minecraft_root, check_exists=False)\n    ender_chest.write_to_cfg(config_path)\n    CRAFT_LOGGER.info(f\"EnderChest configuration written to {config_path}\")\n</code></pre>"},{"location":"reference/enderchest/filesystem/","title":"filesystem","text":"<p>Functionality for managing the EnderChest and shulker box config files and folders</p>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.ender_chest_config","title":"<code>ender_chest_config(minecraft_root, check_exists=True)</code>","text":"<p>Given a minecraft root directory, return the path to the EnderChest config file</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>check_exists</code> <code>bool</code> <p>By default, this method will raise an error if the enderchest config file does not already exist. To disable that check, call this method with <code>check_exists=False</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>Path</code> <p>The path to the EnderChest config file</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the EnderChest config file isn't where it's supposed to be (and checking hasn't been disabled)</p>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.ender_chest_config--notes","title":"Notes","text":"<p>This method does not check if the config file is valid</p> Source code in <code>enderchest/filesystem.py</code> <pre><code>def ender_chest_config(minecraft_root, check_exists: bool = True) -&gt; Path:\n    \"\"\"Given a minecraft root directory, return the path to the EnderChest\n    config file\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    check_exists : bool, optional\n        By default, this method will raise an error if the enderchest config\n        file does not already exist. To disable that check, call this method\n        with `check_exists=False`.\n\n    Returns\n    -------\n    Path\n        The path to the EnderChest config file\n\n    Raises\n    ------\n    FileNotFoundError\n        If the EnderChest config file isn't where it's supposed to be (and\n        checking hasn't been disabled)\n\n    Notes\n    -----\n    This method does not check if the config file is valid\n    \"\"\"\n    config_path = minecraft_root / ENDER_CHEST_FOLDER_NAME / ENDER_CHEST_CONFIG_NAME\n\n    if check_exists and not config_path.exists():\n        raise FileNotFoundError(\n            f\"No valid EnderChest installation exists within {minecraft_root}\"\n        )\n    return config_path\n</code></pre>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.ender_chest_folder","title":"<code>ender_chest_folder(minecraft_root, check_exists=True)</code>","text":"<p>Given a minecraft root directory, return the path to the EnderChest folder</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>check_exists</code> <code>bool</code> <p>By default, this method will raise an error if no EnderChest exists at that location (meaning no folder or no enderchest config file in that folder). To disable that check, call this method with <code>check_exists=False</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>Path</code> <p>The path to the EnderChest folder</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If no valid EnderChest installation exists within the given minecraft root (and checking hasn't been disabled)</p> Source code in <code>enderchest/filesystem.py</code> <pre><code>def ender_chest_folder(minecraft_root: Path, check_exists: bool = True) -&gt; Path:\n    \"\"\"Given a minecraft root directory, return the path to the EnderChest\n    folder\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    check_exists : bool, optional\n        By default, this method will raise an error if no EnderChest exists\n        at that location (meaning no folder or no enderchest config file in\n        that folder). To disable that check, call this method with\n        `check_exists=False`.\n\n    Returns\n    -------\n    Path\n        The path to the EnderChest folder\n\n    Raises\n    ------\n    FileNotFoundError\n        If no valid EnderChest installation exists within the given\n        minecraft root (and checking hasn't been disabled)\n    \"\"\"\n    return ender_chest_config(minecraft_root, check_exists=check_exists).parent\n</code></pre>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.links_into_enderchest","title":"<code>links_into_enderchest(minecraft_root, link, check_exists=True)</code>","text":"<p>Determine whether a symlink's target is inside the EnderChest specified by the Minecraft root.</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>link</code> <code>Path</code> <p>The link to check</p> required <code>check_exists</code> <code>bool</code> <p>By default, this method will raise an error if no EnderChest exists at that location (meaning no folder or no enderchest config file in that folder). To disable that check, call this method with <code>check_exists=False</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the path is inside of the EnderChest folder. False otherwise.</p>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.links_into_enderchest--notes","title":"Notes","text":"<p>This method only checks the direct target of the link as opposed to the fully resolved path.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If no valid EnderChest installation exists within the given minecraft root (and checking hasn't been disabled)</p> <code>OSError</code> <p>If the link provided isn't actually a symbolic link</p> Source code in <code>enderchest/filesystem.py</code> <pre><code>def links_into_enderchest(\n    minecraft_root: Path, link: Path, check_exists: bool = True\n) -&gt; bool:\n    \"\"\"Determine whether a symlink's target is inside the EnderChest specified\n    by the Minecraft root.\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    link : Path\n        The link to check\n    check_exists : bool, optional\n        By default, this method will raise an error if no EnderChest exists\n        at that location (meaning no folder or no enderchest config file in\n        that folder). To disable that check, call this method with\n        `check_exists=False`.\n\n    Returns\n    -------\n    bool\n        True if the path is inside of the EnderChest folder. False otherwise.\n\n    Notes\n    -----\n    This method only checks the *direct target* of the link as opposed to the\n    fully resolved path.\n\n    Raises\n    ------\n    FileNotFoundError\n        If no valid EnderChest installation exists within the given\n        minecraft root (and checking hasn't been disabled)\n    OSError\n        If the link provided isn't actually a symbolic link\n    \"\"\"\n    chest_folder = os.path.normpath(\n        ender_chest_folder(minecraft_root, check_exists=check_exists)\n        .expanduser()\n        .absolute()\n    )\n\n    target = os.readlink(link)\n    if not os.path.isabs(target):\n        target = os.path.normpath(link.parent / target)\n\n    # Windows shenanigans: https://bugs.python.org/issue42957\n    if target.startswith((\"\\\\\\\\?\\\\\", \"\\\\??\\\\\")):  # pragma: no cover\n        try:\n            os.stat(target[4:])\n            target = target[4:]\n        except (OSError, FileNotFoundError):\n            # then maybe this is somehow legit\n            pass\n\n    # there's probably a better way to check if a file is inside a sub-path\n    try:\n        common_root = os.path.commonpath([target, chest_folder])\n    except ValueError:  # if they have no common root\n        common_root = \"\"\n    return common_root == chest_folder\n</code></pre>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.minecraft_folders","title":"<code>minecraft_folders(search_path)</code>","text":"<p>Find all .minecraft folders within a given search path</p> <p>Parameters:</p> Name Type Description Default <code>search_path</code> <code>Path</code> <p>The directory to search</p> required <p>Returns:</p> Type Description <code>list-like of paths</code> <p>The paths to all the .minecraft folders this method could find</p>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.minecraft_folders--notes","title":"Notes","text":"<p>This method does not check to make sure that those .minecraft folders contain valid minecraft instances, just that they exist</p> Source code in <code>enderchest/filesystem.py</code> <pre><code>def minecraft_folders(search_path: Path) -&gt; Iterable[Path]:\n    \"\"\"Find all .minecraft folders within a given search path\n\n    Parameters\n    ----------\n    search_path : Path\n        The directory to search\n\n    Returns\n    -------\n    list-like of paths\n        The paths to all the .minecraft folders this method could find\n\n    Notes\n    -----\n    This method does not check to make sure that those .minecraft folders\n    contain valid minecraft instances, just that they exist\n    \"\"\"\n    return search_path.rglob(\".minecraft\")\n</code></pre>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.place_cache","title":"<code>place_cache(minecraft_root)</code>","text":"<p>Given a minecraft root directory, return the path to the EnderChest place cache file</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The path to the place cache file</p>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.place_cache--notes","title":"Notes","text":"<p>This method does not check if the cache file is valid or if it even exists</p> Source code in <code>enderchest/filesystem.py</code> <pre><code>def place_cache(minecraft_root: Path) -&gt; Path:\n    \"\"\"Given a minecraft root directory, return the path to the EnderChest\n    place cache file\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n\n    Returns\n    -------\n    Path\n        The path to the place cache file\n\n    Notes\n    -----\n    This method does not check if the cache file is valid or if it even exists\n    \"\"\"\n    return ender_chest_folder(minecraft_root) / PLACE_CACHE_NAME\n</code></pre>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.shulker_box_config","title":"<code>shulker_box_config(minecraft_root, shulker_box_name)</code>","text":"<p>Generate the path to a shulker box config file, given its name and the minecraft root directory</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The path to the shulker box folder</p>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.shulker_box_config--notes","title":"Notes","text":"<p>This method does not check if a shulker box config exists at that location</p> Source code in <code>enderchest/filesystem.py</code> <pre><code>def shulker_box_config(minecraft_root: Path, shulker_box_name: str) -&gt; Path:\n    \"\"\"Generate the path to a shulker box config file, given its name and\n    the minecraft root directory\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n\n    Returns\n    -------\n    Path\n        The path to the shulker box folder\n\n    Notes\n    -----\n    This method does not check if a shulker box config exists at that location\n    \"\"\"\n    return shulker_box_root(minecraft_root, shulker_box_name) / SHULKER_BOX_CONFIG_NAME\n</code></pre>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.shulker_box_configs","title":"<code>shulker_box_configs(minecraft_root)</code>","text":"<p>Find all shulker box configs on the system</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <p>Returns:</p> Type Description <code>list-like of paths</code> <p>The paths to all the shulker box configs on the system</p>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.shulker_box_configs--notes","title":"Notes","text":"<p>This method does not check to make sure those config files are valid, just that they exist</p> Source code in <code>enderchest/filesystem.py</code> <pre><code>def shulker_box_configs(minecraft_root: Path) -&gt; Iterable[Path]:\n    \"\"\"Find all shulker box configs on the system\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n\n    Returns\n    -------\n    list-like of paths\n        The paths to all the shulker box configs on the system\n\n    Notes\n    -----\n    This method does not check to make sure those config files are valid,\n    just that they exist\n    \"\"\"\n    GATHER_LOGGER.debug(f\"Searching for shulker configs within {minecraft_root}\")\n    return ender_chest_folder(minecraft_root).glob(f\"*/{SHULKER_BOX_CONFIG_NAME}\")\n</code></pre>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.shulker_box_root","title":"<code>shulker_box_root(minecraft_root, shulker_box_name)</code>","text":"<p>Generate the path to the root of a shulker box, given its name and the minecraft root directory</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The path to the shulker box folder</p>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.shulker_box_root--notes","title":"Notes","text":"<p>This method does not check if a shulker box exists at that location</p> Source code in <code>enderchest/filesystem.py</code> <pre><code>def shulker_box_root(minecraft_root: Path, shulker_box_name: str) -&gt; Path:\n    \"\"\"Generate the path to the root of a shulker box, given its name and the\n    minecraft root directory\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n\n    Returns\n    -------\n    Path\n        The path to the shulker box folder\n\n    Notes\n    -----\n    This method does not check if a shulker box exists at that location\n    \"\"\"\n    return ender_chest_folder(minecraft_root) / shulker_box_name\n</code></pre>"},{"location":"reference/enderchest/gather/","title":"gather","text":"<p>Functionality for finding, resolving and parsing local installations and instances</p>"},{"location":"reference/enderchest/gather/#enderchest.gather.gather_metadata_for_mmc_instance","title":"<code>gather_metadata_for_mmc_instance(minecraft_folder, instgroups_file=None)</code>","text":"<p>Parse files to generate metadata for a MultiMC-like instance</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_folder</code> <code>Path</code> <p>The path to the installation's .minecraft folder</p> required <code>instgroups_file</code> <code>Path</code> <p>The path to instgroups.json. If None is provided, this method will look for it two directories up from the minecraft folder</p> <code>None</code> <p>Returns:</p> Type Description <code>InstanceSpec</code> <p>The metadata for this instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If this is not a valid MMC-like Minecraft instance</p>"},{"location":"reference/enderchest/gather/#enderchest.gather.gather_metadata_for_mmc_instance--notes","title":"Notes","text":"<p>If this method is failing to find the appropriate files, you may want to try ensuring that minecraft_folder is an absolute path.</p> Source code in <code>enderchest/gather.py</code> <pre><code>def gather_metadata_for_mmc_instance(\n    minecraft_folder: Path, instgroups_file: Path | None = None\n) -&gt; InstanceSpec:\n    \"\"\"Parse files to generate metadata for a MultiMC-like instance\n\n    Parameters\n    ----------\n    minecraft_folder : Path\n        The path to the installation's .minecraft folder\n    instgroups_file : Path\n        The path to instgroups.json. If None is provided, this method will\n        look for it two directories up from the minecraft folder\n\n    Returns\n    -------\n    InstanceSpec\n        The metadata for this instance\n\n    Raises\n    ------\n    ValueError\n        If this is not a valid MMC-like Minecraft instance\n\n    Notes\n    -----\n    If this method is failing to find the appropriate files, you may want\n    to try ensuring that minecraft_folder is an absolute path.\n    \"\"\"\n    mmc_pack_file = minecraft_folder.parent / \"mmc-pack.json\"\n    try:\n        with mmc_pack_file.open() as mmc_json:\n            components: list[dict] = json.load(mmc_json)[\"components\"]\n\n        version: str | None = None\n        modloader: str | None = None\n\n        for component in components:\n            match component.get(\"uid\"), component.get(\"cachedName\", \"\"):\n                case \"net.minecraft\", _:\n                    version = parse_version(component[\"version\"])\n                case \"net.fabricmc.fabric-loader\", _:\n                    modloader = \"Fabric Loader\"\n                case \"org.quiltmc.quilt-loader\", _:\n                    modloader = \"Quilt Loader\"\n                case (\"net.minecraftforge\", _) | (_, \"Forge\"):\n                    modloader = \"Forge\"\n                case _, name if name.endswith(\"oader\"):\n                    modloader = name\n                case _:\n                    continue\n            modloader = normalize_modloader(modloader)[0]\n        if version is None:\n            raise KeyError(\"Could not find a net.minecraft component\")\n    except FileNotFoundError as no_json:\n        raise ValueError(f\"Could not find {mmc_pack_file}\") from no_json\n    except json.JSONDecodeError as bad_json:\n        raise ValueError(\n            f\"{mmc_pack_file} is corrupt and could not be parsed\"\n        ) from bad_json\n    except KeyError as weird_json:\n        raise ValueError(\n            f\"Could not parse metadata from {mmc_pack_file}\"\n        ) from weird_json\n\n    name = minecraft_folder.parent.name\n\n    instance_groups: list[str] = []\n\n    if name == \"\":\n        GATHER_LOGGER.warning(\n            \"Could not resolve the name of the parent folder\"\n            \" and thus could not load tags.\"\n        )\n    else:\n        instgroups_file = (\n            instgroups_file or minecraft_folder.parent.parent / \"instgroups.json\"\n        )\n\n        try:\n            with instgroups_file.open() as groups_json:\n                groups: dict[str, dict] = json.load(groups_json)[\"groups\"]\n            for group, metadata in groups.items():\n                # interestingly this comes from the folder name, not the actual name\n                if name in metadata.get(\"instances\", ()):\n                    instance_groups.append(group)\n\n        except FileNotFoundError as no_json:\n            GATHER_LOGGER.warning(\n                f\"Could not find {instgroups_file} and thus could not load tags\"\n            )\n        except json.JSONDecodeError as bad_json:\n            GATHER_LOGGER.warning(\n                f\"{instgroups_file} is corrupt and could not be parsed for tags\"\n            )\n        except KeyError as weird_json:\n            GATHER_LOGGER.warning(f\"Could not parse tags from {instgroups_file}\")\n\n    instance_cfg = minecraft_folder.parent / \"instance.cfg\"\n\n    try:\n        parser = ConfigParser(allow_no_value=True, interpolation=None)\n        parser.read_string(\"[instance]\\n\" + instance_cfg.read_text())\n        name = parser[\"instance\"][\"name\"]\n    except FileNotFoundError as no_cfg:\n        GATHER_LOGGER.warning(\n            f\"Could not find {instance_cfg} and thus could not load the instance name\"\n        )\n    except ParsingError as no_cfg:\n        GATHER_LOGGER.warning(\n            f\"{instance_cfg} is corrupt and could not be parsed the instance name\"\n        )\n    except KeyError as weird_json:\n        GATHER_LOGGER.warning(f\"Could not parse instance name from {instance_cfg}\")\n\n    if name == \"\":\n        raise ValueError(\"Could not determine the name of the instance.\")\n\n    return InstanceSpec(\n        name,\n        minecraft_folder,\n        (version,),\n        modloader or \"\",\n        tuple(instance_groups),\n        (),\n    )\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.gather_metadata_for_official_instance","title":"<code>gather_metadata_for_official_instance(minecraft_folder, name='official')</code>","text":"<p>Parse files to generate metadata for an official Minecraft installation</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_folder</code> <code>Path</code> <p>The path to the installation's .minecraft folder</p> required <code>name</code> <code>str</code> <p>A name or alias to give to the instance. If None is provided, the default name is \"official\"</p> <code>'official'</code> <p>Returns:</p> Type Description <code>InstanceSpec</code> <p>The metadata for this instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If this is not a valid official Minecraft installation</p>"},{"location":"reference/enderchest/gather/#enderchest.gather.gather_metadata_for_official_instance--notes","title":"Notes","text":"<p>This method will always consider this instance to be vanilla, with no modloader. If a Forge or Fabric executable is installed inside this instance, the precise name of that version of that modded minecraft will be included in the version list.</p> Source code in <code>enderchest/gather.py</code> <pre><code>def gather_metadata_for_official_instance(\n    minecraft_folder: Path, name: str = \"official\"\n) -&gt; InstanceSpec:\n    \"\"\"Parse files to generate metadata for an official Minecraft installation\n\n    Parameters\n    ----------\n    minecraft_folder : Path\n        The path to the installation's .minecraft folder\n    name : str, optional\n        A name or alias to give to the instance. If None is provided, the\n        default name is \"official\"\n\n    Returns\n    -------\n    InstanceSpec\n        The metadata for this instance\n\n    Raises\n    ------\n    ValueError\n        If this is not a valid official Minecraft installation\n\n    Notes\n    -----\n    This method will always consider this instance to be vanilla, with no\n    modloader. If a Forge or Fabric executable is installed inside this\n    instance, the precise name of that version of that modded minecraft\n    will be included in the version list.\n    \"\"\"\n    launcher_profile_file = minecraft_folder / \"launcher_profiles.json\"\n    try:\n        with launcher_profile_file.open() as lp_json:\n            launcher_profiles = json.load(lp_json)\n        raw_versions: list[str] = [\n            profile[\"lastVersionId\"]\n            for profile in launcher_profiles[\"profiles\"].values()\n        ]\n    except FileNotFoundError as no_json:\n        raise ValueError(f\"Could not find {launcher_profile_file}\") from no_json\n    except json.JSONDecodeError as bad_json:\n        raise ValueError(\n            f\"{launcher_profile_file} is corrupt and could not be parsed\"\n        ) from bad_json\n    except KeyError as weird_json:\n        raise ValueError(\n            f\"Could not parse metadata from {launcher_profile_file}\"\n        ) from weird_json\n\n    version_manifest_file = minecraft_folder / \"versions\" / \"version_manifest_v2.json\"\n    try:\n        with version_manifest_file.open() as vm_json:\n            version_lookup: dict[str, str] = json.load(vm_json)[\"latest\"]\n    except FileNotFoundError as no_json:\n        raise ValueError(f\"Could not find {version_manifest_file}\") from no_json\n    except json.JSONDecodeError as bad_json:\n        raise ValueError(\n            f\"{version_manifest_file} is corrupt and could not be parsed\"\n        ) from bad_json\n    except KeyError as weird_json:\n        GATHER_LOGGER.warning(\n            f\"{version_manifest_file} has no latest-version lookup.\"\n            \"\\nPlease check the parsed metadata to ensure that it's accurate.\",\n        )\n        version_lookup = {}\n\n    versions: list[str] = []\n    groups: list[str] = [\"vanilla\"]\n    for version in raw_versions:\n        if version.startswith(\"latest-\"):\n            mapped_version = version_lookup.get(version[len(\"latest-\") :])\n            if mapped_version is not None:\n                versions.append(parse_version(mapped_version))\n                groups.append(version)\n                continue\n        versions.append(parse_version(version))\n\n    return InstanceSpec(name, minecraft_folder, tuple(versions), \"\", tuple(groups), ())\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.gather_minecraft_instances","title":"<code>gather_minecraft_instances(minecraft_root, search_path, official)</code>","text":"<p>Search the specified directory for Minecraft installations and return any that are can be found and parsed</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder). This will be used to construct relative paths.</p> required <code>search_path</code> <code>Path</code> <p>The path to search</p> required <code>official</code> <code>bool or None</code> <p>Whether we expect that the instances found in this location will be:   - from the official launcher (official=True)   - from a MultiMC-style launcher (official=False)   - a mix / unsure (official=None)</p> required <p>Returns:</p> Type Description <code>list of InstanceSpec</code> <p>A list of parsed instances</p>"},{"location":"reference/enderchest/gather/#enderchest.gather.gather_minecraft_instances--notes","title":"Notes","text":"<ul> <li>If a minecraft installation is found but cannot be parsed   (or parsed as specified) this method will report that failure but then   continue on.</li> <li>As a corollary, if no valid Minecraft installations can be found, this   method will return an empty list.</li> </ul> Source code in <code>enderchest/gather.py</code> <pre><code>def gather_minecraft_instances(\n    minecraft_root: Path, search_path: Path, official: bool | None\n) -&gt; list[InstanceSpec]:\n    \"\"\"Search the specified directory for Minecraft installations and return\n    any that are can be found and parsed\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder). This will be used to\n        construct relative paths.\n    search_path : Path\n        The path to search\n    official : bool or None\n        Whether we expect that the instances found in this location will be:\n          - from the official launcher (official=True)\n          - from a MultiMC-style launcher (official=False)\n          - a mix / unsure (official=None)\n\n    Returns\n    -------\n    list of InstanceSpec\n        A list of parsed instances\n\n    Notes\n    -----\n    - If a minecraft installation is found but cannot be parsed\n      (or parsed as specified) this method will report that failure but then\n      continue on.\n    - As a corollary, if _no_ valid Minecraft installations can be found, this\n      method will return an empty list.\n    \"\"\"\n    try:\n        ender_chest = load_ender_chest(minecraft_root)\n    except FileNotFoundError:\n        # because this method can be called during crafting\n        ender_chest = EnderChest(minecraft_root)\n    GATHER_LOGGER.debug(f\"Searching for Minecraft folders inside {search_path}\")\n    instances: list[InstanceSpec] = []\n    for folder in fs.minecraft_folders(search_path):\n        folder_path = folder.absolute()\n        GATHER_LOGGER.debug(f\"Found minecraft installation at {folder}\")\n        if official is not False:\n            try:\n                instances.append(gather_metadata_for_official_instance(folder_path))\n                GATHER_LOGGER.info(\n                    f\"Gathered official Minecraft installation from {folder}\"\n                )\n                _check_for_allowed_symlinks(ender_chest, instances[-1])\n                continue\n            except ValueError as not_official:\n                GATHER_LOGGER.log(\n                    logging.DEBUG if official is None else logging.WARNING,\n                    (f\"{folder} is not an official instance:\" f\"\\n{not_official}\",),\n                )\n        if official is not True:\n            try:\n                instances.append(gather_metadata_for_mmc_instance(folder_path))\n                GATHER_LOGGER.info(\n                    f\"Gathered MMC-like Minecraft installation from {folder}\"\n                )\n                _check_for_allowed_symlinks(ender_chest, instances[-1])\n                continue\n            except ValueError as not_mmc:\n                GATHER_LOGGER.log(\n                    logging.DEBUG if official is None else logging.WARNING,\n                    f\"{folder} is not an MMC-like instance:\\n{not_mmc}\",\n                )\n        GATHER_LOGGER.warning(\n            f\"{folder_path} does not appear to be a valid Minecraft instance\"\n        )\n    for i, mc_instance in enumerate(instances):\n        try:\n            instances[i] = mc_instance._replace(\n                root=mc_instance.root.relative_to(minecraft_root.resolve())\n            )\n        except ValueError:\n            # TODO: if not Windows, try making relative to \"~\"\n            pass  # instance isn't inside the minecraft root\n    if not instances:\n        GATHER_LOGGER.warning(\n            f\"Could not find any Minecraft instances inside {search_path}\"\n        )\n    return instances\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.get_instances_matching_shulker_box","title":"<code>get_instances_matching_shulker_box(minecraft_root, shulker_box_name)</code>","text":"<p>Get the list of registered instances that link to the specified shulker box</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>shulker_box_name</code> <code>str</code> <p>The name of the shulker box you're asking about</p> required <p>Returns:</p> Type Description <code>list of InstanceSpec</code> <p>The instances that are / should be linked to the specified shulker box</p> Source code in <code>enderchest/gather.py</code> <pre><code>def get_instances_matching_shulker_box(\n    minecraft_root: Path, shulker_box_name: str\n) -&gt; list[InstanceSpec]:\n    \"\"\"Get the list of registered instances that link to the specified shulker box\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    shulker_box_name : str\n        The name of the shulker box you're asking about\n\n    Returns\n    -------\n    list of InstanceSpec\n        The instances that are / should be linked to the specified shulker box\n    \"\"\"\n    try:\n        config_file = fs.shulker_box_config(minecraft_root, shulker_box_name)\n    except FileNotFoundError:\n        GATHER_LOGGER.error(f\"No EnderChest is installed in {minecraft_root}\")\n        return []\n    try:\n        shulker_box = _load_shulker_box(config_file)\n    except (FileNotFoundError, ValueError) as bad_box:\n        GATHER_LOGGER.error(\n            f\"Could not load shulker box {shulker_box_name}\\n  {bad_box}\"\n        )\n        return []\n\n    chest = load_ender_chest(minecraft_root)\n\n    if not shulker_box.matches_host(chest.name):\n        GATHER_LOGGER.warning(\n            \"This shulker box will not link to any instances on this machine\"\n        )\n        return []\n\n    if not chest.instances:\n        GATHER_LOGGER.warning(\n            \"This EnderChest does not have any instances registered.\"\n            \" To register some, run the command:\"\n            \"\\nenderchest gather minecraft\",\n        )\n        return []\n\n    GATHER_LOGGER.debug(\n        \"These are the instances that are currently registered\"\n        f\" to the {minecraft_root} EnderChest:\\n%s\",\n        \"\\n\".join(\n            [\n                f\"  {i + 1}. {_render_instance(instance)}\"\n                for i, instance in enumerate(chest.instances)\n            ]\n        ),\n    )\n\n    matches = [\n        instance for instance in chest.instances if shulker_box.matches(instance)\n    ]\n\n    if len(matches) == 0:\n        report = \"is not linked to by any registered instances\"\n    else:\n        report = \"is linked to by the following instances:\\n\" + \"\\n\".join(\n            f\"  - {_render_instance(instance)}\" for instance in matches\n        )\n\n    GATHER_LOGGER.info(f\"The shulker box {_render_shulker_box(shulker_box)} {report}\")\n\n    return matches\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.get_shulker_boxes_matching_instance","title":"<code>get_shulker_boxes_matching_instance(minecraft_root, instance_name)</code>","text":"<p>Get the list of shulker boxes that the specified instance links to</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>instance_name</code> <code>str</code> <p>The name of the instance you're asking about</p> required <p>Returns:</p> Type Description <code>list of ShulkerBox</code> <p>The shulker boxes that are linked to by the specified instance</p> Source code in <code>enderchest/gather.py</code> <pre><code>def get_shulker_boxes_matching_instance(\n    minecraft_root: Path, instance_name: str\n) -&gt; list[ShulkerBox]:\n    \"\"\"Get the list of shulker boxes that the specified instance links to\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    instance_name : str\n        The name of the instance you're asking about\n\n    Returns\n    -------\n    list of ShulkerBox\n        The shulker boxes that are linked to by the specified instance\n    \"\"\"\n    try:\n        chest = load_ender_chest(minecraft_root)\n    except (FileNotFoundError, ValueError) as bad_chest:\n        GATHER_LOGGER.error(\n            f\"Could not load EnderChest from {minecraft_root}:\\n  {bad_chest}\"\n        )\n        return []\n    for mc in chest.instances:\n        if mc.name == instance_name:\n            break\n    else:\n        GATHER_LOGGER.error(\n            \"No instance named %s is registered to this EnderChest\", instance_name\n        )\n        return []\n\n    matches = [\n        box\n        for box in load_shulker_boxes(minecraft_root, log_level=logging.DEBUG)\n        if box.matches(mc) and box.matches_host(chest.name)\n    ]\n\n    if len(matches) == 0:\n        report = \"does not link to any shulker boxes in this chest\"\n    else:\n        report = \"links to the following shulker boxes:\\n\" + \"\\n\".join(\n            f\"  - {_render_shulker_box(box)}\" for box in matches\n        )\n\n    GATHER_LOGGER.info(f\"The instance {_render_instance(mc)} {report}\")\n\n    return matches\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_ender_chest","title":"<code>load_ender_chest(minecraft_root)</code>","text":"<p>Load the configuration from the enderchest.cfg file in the EnderChest folder.</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <p>Returns:</p> Type Description <code>EnderChest</code> <p>The EnderChest configuration</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If no EnderChest folder exists in the given minecraft root or if no enderchest.cfg file exists within that EnderChest folder</p> <code>ValueError</code> <p>If the EnderChest configuration is invalid and could not be parsed</p> Source code in <code>enderchest/gather.py</code> <pre><code>def load_ender_chest(minecraft_root: Path) -&gt; EnderChest:\n    \"\"\"Load the configuration from the enderchest.cfg file in the EnderChest\n    folder.\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n\n    Returns\n    -------\n    EnderChest\n        The EnderChest configuration\n\n    Raises\n    ------\n    FileNotFoundError\n        If no EnderChest folder exists in the given minecraft root or if no\n        enderchest.cfg file exists within that EnderChest folder\n    ValueError\n        If the EnderChest configuration is invalid and could not be parsed\n    \"\"\"\n    config_path = fs.ender_chest_config(minecraft_root)\n    GATHER_LOGGER.debug(f\"Loading {config_path}\")\n    ender_chest = EnderChest.from_cfg(config_path)\n    GATHER_LOGGER.debug(f\"Parsed EnderChest installation from {minecraft_root}\")\n    return ender_chest\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_ender_chest_instances","title":"<code>load_ender_chest_instances(minecraft_root, log_level=logging.INFO)</code>","text":"<p>Get the list of instances registered with the EnderChest located in the minecraft root</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>log_level</code> <code>int</code> <p>By default, this method will report out the minecraft instances it finds at the INFO level. You can optionally pass in a lower (or higher) level if this method is being called from another method where that information is redundant or overly verbose.</p> <code>INFO</code> <p>Returns:</p> Type Description <code>list of InstanceSpec</code> <p>The instances registered with the EnderChest</p>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_ender_chest_instances--notes","title":"Notes","text":"<p>If no EnderChest is installed in the given location, then this will return an empty list rather than failing outright.</p> Source code in <code>enderchest/gather.py</code> <pre><code>def load_ender_chest_instances(\n    minecraft_root: Path, log_level: int = logging.INFO\n) -&gt; Sequence[InstanceSpec]:\n    \"\"\"Get the list of instances registered with the EnderChest located in the\n    minecraft root\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    log_level : int, optional\n        By default, this method will report out the minecraft instances it\n        finds at the INFO level. You can optionally pass in a lower (or higher)\n        level if this method is being called from another method where that\n        information is redundant or overly verbose.\n\n    Returns\n    -------\n    list of InstanceSpec\n        The instances registered with the EnderChest\n\n    Notes\n    -----\n    If no EnderChest is installed in the given location, then this will return\n    an empty list rather than failing outright.\n    \"\"\"\n    try:\n        ender_chest = load_ender_chest(minecraft_root)\n        instances: Sequence[InstanceSpec] = ender_chest.instances\n    except (FileNotFoundError, ValueError) as bad_chest:\n        GATHER_LOGGER.error(\n            f\"Could not load EnderChest from {minecraft_root}:\\n  {bad_chest}\"\n        )\n        instances = []\n    if len(instances) == 0:\n        GATHER_LOGGER.warning(\n            f\"There are no instances registered to the {minecraft_root} EnderChest\",\n        )\n    else:\n        GATHER_LOGGER.log(\n            log_level,\n            \"These are the instances that are currently registered\"\n            f\" to the {minecraft_root} EnderChest:\\n%s\",\n            \"\\n\".join(\n                [\n                    f\"  {i + 1}. {_render_instance(instance)}\"\n                    for i, instance in enumerate(instances)\n                ]\n            ),\n        )\n    return instances\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_ender_chest_remotes","title":"<code>load_ender_chest_remotes(minecraft_root, log_level=logging.INFO)</code>","text":"<p>Load all remote EnderChest installations registered with this one</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>log_level</code> <code>int</code> <p>By default, this method will report out the minecraft instances it finds at the INFO level. You can optionally pass in a lower (or higher) level if this method is being called from another method where that information is redundant or overly verbose.</p> <code>INFO</code> <p>Returns:</p> Type Description <code>list of (URI, str) tuples</code> <p>The URIs of the remote EnderChests, paired with their aliases</p>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_ender_chest_remotes--notes","title":"Notes","text":"<p>If no EnderChest is installed in the given location, then this will return an empty list rather than failing outright.</p> Source code in <code>enderchest/gather.py</code> <pre><code>def load_ender_chest_remotes(\n    minecraft_root: Path, log_level: int = logging.INFO\n) -&gt; list[tuple[ParseResult, str]]:\n    \"\"\"Load all remote EnderChest installations registered with this one\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    log_level : int, optional\n        By default, this method will report out the minecraft instances it\n        finds at the INFO level. You can optionally pass in a lower (or higher)\n        level if this method is being called from another method where that\n        information is redundant or overly verbose.\n\n    Returns\n    -------\n    list of (URI, str) tuples\n        The URIs of the remote EnderChests, paired with their aliases\n\n    Notes\n    -----\n    If no EnderChest is installed in the given location, then this will return\n    an empty list rather than failing outright.\n    \"\"\"\n    try:\n        ender_chest = load_ender_chest(minecraft_root)\n        remotes: Sequence[tuple[ParseResult, str]] = ender_chest.remotes\n    except (FileNotFoundError, ValueError) as bad_chest:\n        GATHER_LOGGER.error(\n            f\"Could not load EnderChest from {minecraft_root}:\\n  {bad_chest}\"\n        )\n        remotes = ()\n\n    if len(remotes) == 0:\n        if log_level &gt;= logging.INFO:\n            GATHER_LOGGER.warning(\n                f\"There are no remotes registered to the {minecraft_root} EnderChest\"\n            )\n        return []\n\n    report = (\n        \"These are the remote EnderChest installations registered\"\n        f\" to the one installed at {minecraft_root}\"\n    )\n    remote_list: list[tuple[ParseResult, str]] = []\n    log_args: list[str] = []\n    for remote, alias in remotes:\n        report += \"\\n  - %s\"\n        log_args.append(render_remote(alias, remote))\n        remote_list.append((remote, alias))\n    GATHER_LOGGER.log(log_level, report, *log_args)\n    return remote_list\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_shulker_boxes","title":"<code>load_shulker_boxes(minecraft_root, log_level=logging.INFO)</code>","text":"<p>Load all shulker boxes in the EnderChest folder and return them in the order in which they should be linked.</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>log_level</code> <code>int</code> <p>By default, this method will report out the minecraft instances it finds at the INFO level. You can optionally pass in a lower (or higher) level if this method is being called from another method where that information is redundant or overly verbose.</p> <code>INFO</code> <p>Returns:</p> Type Description <code>list of ShulkerBoxes</code> <p>The shulker boxes found in the EnderChest folder, ordered in terms of the sequence in which they should be linked</p>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_shulker_boxes--notes","title":"Notes","text":"<p>If no EnderChest is installed in the given location, then this will return an empty list rather than failing outright.</p> Source code in <code>enderchest/gather.py</code> <pre><code>def load_shulker_boxes(\n    minecraft_root: Path, log_level: int = logging.INFO\n) -&gt; list[ShulkerBox]:\n    \"\"\"Load all shulker boxes in the EnderChest folder and return them in the\n    order in which they should be linked.\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    log_level : int, optional\n        By default, this method will report out the minecraft instances it\n        finds at the INFO level. You can optionally pass in a lower (or higher)\n        level if this method is being called from another method where that\n        information is redundant or overly verbose.\n\n    Returns\n    -------\n    list of ShulkerBoxes\n        The shulker boxes found in the EnderChest folder, ordered in terms of\n        the sequence in which they should be linked\n\n    Notes\n    -----\n    If no EnderChest is installed in the given location, then this will return\n    an empty list rather than failing outright.\n    \"\"\"\n    shulker_boxes: list[ShulkerBox] = []\n\n    try:\n        for shulker_config in fs.shulker_box_configs(minecraft_root):\n            try:\n                shulker_boxes.append(_load_shulker_box(shulker_config))\n            except (FileNotFoundError, ValueError) as bad_shulker:\n                GATHER_LOGGER.warning(\n                    f\"{bad_shulker}\\n  Skipping shulker box {shulker_config.parent.name}\"\n                )\n\n    except FileNotFoundError:\n        GATHER_LOGGER.error(f\"There is no EnderChest installed within {minecraft_root}\")\n        return []\n\n    shulker_boxes = sorted(shulker_boxes)\n\n    if len(shulker_boxes) == 0:\n        if log_level &gt;= logging.INFO:\n            GATHER_LOGGER.warning(\n                f\"There are no shulker boxes within the {minecraft_root} EnderChest\"\n            )\n    else:\n        _report_shulker_boxes(\n            shulker_boxes, log_level, f\"the {minecraft_root} EnderChest\"\n        )\n    return shulker_boxes\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.update_ender_chest","title":"<code>update_ender_chest(minecraft_root, search_paths=None, official=None, remotes=None)</code>","text":"<p>Orchestration method that coordinates the onboarding of new instances or EnderChest installations</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder).</p> required <code>search_paths</code> <code>list of Paths</code> <p>The local search paths to look for Minecraft installations within. Be warned that this search is performed recursively.</p> <code>None</code> <code>official</code> <code>bool | None</code> <p>Optionally specify whether the Minecraft instances you expect to find are from the official launcher (<code>official=True</code>) or a MultiMC-derivative (<code>official=False</code>).</p> <code>None</code> <code>remotes</code> <code>list of URIs or (URI, str) tuples</code> <p>Any remotes you wish to register to this instance. When a (URI, str) tuple is provided, the second value will be used as the name/alias of the remote. If there is already a remote specified with the given alias, this method will replace it.</p> <code>None</code> Source code in <code>enderchest/gather.py</code> <pre><code>def update_ender_chest(\n    minecraft_root: Path,\n    search_paths: Iterable[str | Path] | None = None,\n    official: bool | None = None,\n    remotes: Iterable[str | ParseResult | tuple[str, str] | tuple[ParseResult, str]]\n    | None = None,\n) -&gt; None:\n    \"\"\"Orchestration method that coordinates the onboarding of new instances or\n    EnderChest installations\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder).\n    search_paths : list of Paths, optional\n        The local search paths to look for Minecraft installations within.\n        Be warned that this search is performed recursively.\n    official : bool | None, optional\n        Optionally specify whether the Minecraft instances you expect to find\n        are from the official launcher (`official=True`) or a MultiMC-derivative\n        (`official=False`).\n    remotes : list of URIs or (URI, str) tuples, optional\n        Any remotes you wish to register to this instance. When a (URI, str) tuple\n        is provided, the second value will be used as the name/alias of the remote.\n        If there is already a remote specified with the given alias, this method will\n        replace it.\n    \"\"\"\n    try:\n        ender_chest = load_ender_chest(minecraft_root)\n    except (FileNotFoundError, ValueError) as bad_chest:\n        GATHER_LOGGER.error(\n            f\"Could not load EnderChest from {minecraft_root}:\\n  {bad_chest}\"\n        )\n        return\n    for search_path in search_paths or ():\n        for instance in gather_minecraft_instances(\n            minecraft_root, Path(search_path), official=official\n        ):\n            _ = ender_chest.register_instance(instance)\n    for remote in remotes or ():\n        try:\n            if isinstance(remote, (str, ParseResult)):\n                ender_chest.register_remote(remote)\n            else:\n                ender_chest.register_remote(*remote)\n        except ValueError as bad_remote:\n            GATHER_LOGGER.warning(bad_remote)\n\n    create_ender_chest(minecraft_root, ender_chest)\n</code></pre>"},{"location":"reference/enderchest/instance/","title":"instance","text":"<p>Specification of a Minecraft instance</p>"},{"location":"reference/enderchest/instance/#enderchest.instance.InstanceSpec","title":"<code>InstanceSpec</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Specification of a Minecraft instance</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The \"display name\" for the instance</p> required <code>root</code> <code>Path</code> <p>The path to its \".minecraft\" folder</p> required <code>minecraft_versions</code> <code>list-like of str</code> <p>The minecraft versions of this instance. This is typically a 1-tuple, but some loaders (such as the official one) will just comingle all your assets together across all profiles</p> required <code>modloader</code> <code>str</code> <p>The (display) name of the modloader (vanilla corresponds to \"\")</p> required <code>tags</code> <code>list-like of str</code> <p>The tags assigned to this instance, including both the ones assigned in the launcher (groups) and the ones assigned by hand.</p> required Source code in <code>enderchest/instance.py</code> <pre><code>class InstanceSpec(NamedTuple):\n    \"\"\"Specification of a Minecraft instance\n\n    Parameters\n    ----------\n    name : str\n        The \"display name\" for the instance\n    root : Path\n        The path to its \".minecraft\" folder\n    minecraft_versions : list-like of str\n        The minecraft versions of this instance. This is typically a 1-tuple,\n        but some loaders (such as the official one) will just comingle all\n        your assets together across all profiles\n    modloader : str\n        The (display) name of the modloader (vanilla corresponds to \"\")\n    tags : list-like of str\n        The tags assigned to this instance, including both the ones assigned\n        in the launcher (groups) and the ones assigned by hand.\n    \"\"\"\n\n    name: str\n    root: Path\n    minecraft_versions: tuple[str, ...]\n    modloader: str\n    groups_: tuple[str, ...]\n    tags_: tuple[str, ...]\n\n    @classmethod\n    def from_cfg(cls, section: SectionProxy) -&gt; \"InstanceSpec\":\n        \"\"\"Parse an instance spec as read in from the enderchest config file\n\n        Parameters\n        ----------\n        section : dict-like of str to str\n            The section in the enderchest config as parsed by a ConfigParser\n\n        Returns\n        -------\n        InstanceSpec\n            The resulting InstanceSpec\n\n        Raises\n        ------\n        KeyError\n            If a required key is absent\n        ValueError\n            If a required entry cannot be parsed\n        \"\"\"\n        return cls(\n            section.name,\n            Path(section[\"root\"]),\n            tuple(\n                parse_version(version.strip())\n                for version in cfg.parse_ini_list(\n                    section.get(\"minecraft-version\", section.get(\"minecraft_version\"))\n                )\n            ),\n            normalize_modloader(section.get(\"modloader\", None))[0],\n            tuple(cfg.parse_ini_list(section.get(\"groups\", \"\"))),\n            tuple(cfg.parse_ini_list(section.get(\"tags\", \"\"))),\n        )\n\n    @property\n    def tags(self):\n        return tuple(sorted({*self.groups_, *self.tags_}))\n</code></pre>"},{"location":"reference/enderchest/instance/#enderchest.instance.InstanceSpec.from_cfg","title":"<code>from_cfg(section)</code>  <code>classmethod</code>","text":"<p>Parse an instance spec as read in from the enderchest config file</p> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>dict-like of str to str</code> <p>The section in the enderchest config as parsed by a ConfigParser</p> required <p>Returns:</p> Type Description <code>InstanceSpec</code> <p>The resulting InstanceSpec</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If a required key is absent</p> <code>ValueError</code> <p>If a required entry cannot be parsed</p> Source code in <code>enderchest/instance.py</code> <pre><code>@classmethod\ndef from_cfg(cls, section: SectionProxy) -&gt; \"InstanceSpec\":\n    \"\"\"Parse an instance spec as read in from the enderchest config file\n\n    Parameters\n    ----------\n    section : dict-like of str to str\n        The section in the enderchest config as parsed by a ConfigParser\n\n    Returns\n    -------\n    InstanceSpec\n        The resulting InstanceSpec\n\n    Raises\n    ------\n    KeyError\n        If a required key is absent\n    ValueError\n        If a required entry cannot be parsed\n    \"\"\"\n    return cls(\n        section.name,\n        Path(section[\"root\"]),\n        tuple(\n            parse_version(version.strip())\n            for version in cfg.parse_ini_list(\n                section.get(\"minecraft-version\", section.get(\"minecraft_version\"))\n            )\n        ),\n        normalize_modloader(section.get(\"modloader\", None))[0],\n        tuple(cfg.parse_ini_list(section.get(\"groups\", \"\"))),\n        tuple(cfg.parse_ini_list(section.get(\"tags\", \"\"))),\n    )\n</code></pre>"},{"location":"reference/enderchest/instance/#enderchest.instance.equals","title":"<code>equals(minecraft_root, instance, other_instance)</code>","text":"<p>Determine whether two instances point to the same location</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The starting location (the parent of where your EnderChest folder lives)</p> required <code>instance</code> <code>InstanceSpec</code> <p>the first instance</p> required <code>other_instance</code> <code>InstanceSpec</code> <p>the instance to compare it against</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if and only if the two instances have the same root, with regards to the provided <code>minecraft_root</code></p> Source code in <code>enderchest/instance.py</code> <pre><code>def equals(\n    minecraft_root: Path, instance: InstanceSpec, other_instance: InstanceSpec\n) -&gt; bool:\n    \"\"\"Determine whether two instances point to the same location\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The starting location (the parent of where your EnderChest folder lives)\n    instance : InstanceSpec\n        the first instance\n    other_instance : InstanceSpec\n        the instance to compare it against\n\n    Returns\n    -------\n    bool\n        True if and only if the two instances have the same root, with regards\n        to the provided `minecraft_root`\n    \"\"\"\n    path = minecraft_root / instance.root.expanduser()\n    other_path = minecraft_root / other_instance.root.expanduser()\n    return path.expanduser().resolve() == other_path.expanduser().resolve()\n</code></pre>"},{"location":"reference/enderchest/instance/#enderchest.instance.merge","title":"<code>merge(*instances)</code>","text":"<p>Merge multiple instances, layering information from the ones provided later on top of the ones provided earlier</p> <p>Parameters:</p> Name Type Description Default <code>*instances</code> <code>InstanceSpec</code> <p>The instances to combine</p> <code>()</code> <p>Returns:</p> Type Description <code>InstanceSpec</code> <p>The merged instance</p>"},{"location":"reference/enderchest/instance/#enderchest.instance.merge--notes","title":"Notes","text":"<p>The resulting merged instance will use:   - the first instance's name   - the union of all non-group tags   - all other data from the last instance</p> Source code in <code>enderchest/instance.py</code> <pre><code>def merge(*instances: InstanceSpec) -&gt; InstanceSpec:\n    \"\"\"Merge multiple instances, layering information from the ones provided later\n    on top of the ones provided earlier\n\n    Parameters\n    ----------\n    *instances : InstanceSpec\n        The instances to combine\n\n    Returns\n    -------\n    InstanceSpec\n        The merged instance\n\n    Notes\n    -----\n    The resulting merged instance will use:\n      - the first instance's name\n      - the union of all non-group tags\n      - all other data from the last instance\n    \"\"\"\n    try:\n        combined_instance = instances[-1]\n    except IndexError as nothing_to_merge:\n        raise ValueError(\n            \"Must provide at least one instance to merge\"\n        ) from nothing_to_merge\n    tags = tuple(sorted(set(sum((instance.tags_ for instance in instances), ()))))\n    return combined_instance._replace(name=instances[0].name, tags_=tags)\n</code></pre>"},{"location":"reference/enderchest/instance/#enderchest.instance.normalize_modloader","title":"<code>normalize_modloader(loader)</code>","text":"<p>Implement common modloader aliases</p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>str</code> <p>User-provided modloader name</p> required <p>Returns:</p> Type Description <code>list of str</code> <p>The modloader values that should be checked against to match the user's intent</p> Source code in <code>enderchest/instance.py</code> <pre><code>def normalize_modloader(loader: str | None) -&gt; list[str]:\n    \"\"\"Implement common modloader aliases\n\n    Parameters\n    ----------\n    loader : str\n        User-provided modloader name\n\n    Returns\n    -------\n    list of str\n        The modloader values that should be checked against to match the user's\n        intent\n    \"\"\"\n    if loader is None:  # this would be from the instance spec\n        return [\"\"]\n    match loader.lower().replace(\" \", \"\").replace(\"-\", \"\").replace(\"_\", \"\").replace(\n        \"/\", \"\"\n    ):\n        case \"none\" | \"vanilla\":\n            return [\"\"]\n        case \"fabric\" | \"fabricloader\":\n            return [\"Fabric Loader\"]\n        case \"quilt\" | \"quiltloader\":\n            return [\"Quilt Loader\"]\n        case \"fabricquilt\" | \"quiltfabric\" | \"fabriclike\" | \"fabriccompatible\":\n            return [\"Fabric Loader\", \"Quilt Loader\"]\n        case \"forge\" | \"forgeloader\" | \"minecraftforge\":\n            return [\"Forge\"]\n        case _:\n            return [loader]\n</code></pre>"},{"location":"reference/enderchest/instance/#enderchest.instance.parse_version","title":"<code>parse_version(version_string)</code>","text":"<p>The first release of each major Minecraft version doesn't follow strict major.minor.patch semver. This method appends the \".0\" so that our version matcher doesn't mess up</p> <p>Parameters:</p> Name Type Description Default <code>version_string</code> <code>str</code> <p>The version read in from the Minecraft instance's config</p> required <p>Returns:</p> Type Description <code>str</code> <p>Either the original version string or the original version string with \".0\" tacked onto the end of it</p>"},{"location":"reference/enderchest/instance/#enderchest.instance.parse_version--notes","title":"Notes","text":"<p>Regex adapted straight from https://semver.org</p> Source code in <code>enderchest/instance.py</code> <pre><code>def parse_version(version_string: str) -&gt; str:\n    \"\"\"The first release of each major Minecraft version doesn't follow strict\n    major.minor.patch semver. This method appends the \".0\" so that our version\n    matcher doesn't mess up\n\n    Parameters\n    ----------\n    version_string : str\n        The version read in from the Minecraft instance's config\n\n    Returns\n    -------\n    str\n        Either the original version string or the original version string with\n        \".0\" tacked onto the end of it\n\n    Notes\n    -----\n    Regex adapted straight from https://semver.org\n    \"\"\"\n    if re.match(r\"^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)$\", version_string):\n        return version_string + \".0\"\n    return version_string\n</code></pre>"},{"location":"reference/enderchest/loggers/","title":"loggers","text":"<p>Loggers for the various EnderChest actions</p>"},{"location":"reference/enderchest/loggers/#enderchest.loggers.CLIFormatter","title":"<code>CLIFormatter</code>","text":"<p>             Bases: <code>Formatter</code></p> <p>Colorful formatter for the CLI</p> <p>h/t https://stackoverflow.com/a/56944256</p> Source code in <code>enderchest/loggers.py</code> <pre><code>class CLIFormatter(logging.Formatter):\n    \"\"\"Colorful formatter for the CLI\n\n    h/t https://stackoverflow.com/a/56944256\"\"\"\n\n    grey = \"\\x1b[2;20m\"\n    yellow = \"\\x1b[33;20m\"\n    bold_red = \"\\x1b[31;1m\"\n    reset = \"\\x1b[0m\"\n\n    FORMATS = {\n        logging.DEBUG: grey + \"%(message)s\" + reset,\n        logging.INFO: \"%(message)s\",\n        IMPORTANT: \"%(message)s\",\n        logging.WARNING: yellow + \"%(message)s\" + reset,\n        logging.ERROR: bold_red + \"%(message)s\" + reset,\n        logging.CRITICAL: bold_red + \"%(message)s\" + reset,\n    }\n\n    def format(self, record: logging.LogRecord) -&gt; str:\n        return logging.Formatter(self.FORMATS.get(record.levelno)).format(record)\n</code></pre>"},{"location":"reference/enderchest/loggers/#enderchest.loggers.verbosity_to_log_level","title":"<code>verbosity_to_log_level(verbosity)</code>","text":"<p>Convert a verbosity level (number of <code>-v</code>s minus number of <code>-q</code>s) to a logging level</p> <p>Parameters:</p> Name Type Description Default <code>verbosity</code> <code>int</code> <p>A verbosity level usually specified by the number of <code>-v</code> flags a user provides minus the number of <code>-q</code> flags. As a baseline, a verbosity of 0 will set the level to handle all INFO-level messages and above.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The corresponding log level that should be set</p>"},{"location":"reference/enderchest/loggers/#enderchest.loggers.verbosity_to_log_level--notes","title":"Notes","text":"<p>Technically the default logging level is set just high enough to exclude DEBUG by default. This allows us to capture intermediate log levels (read: <code>IMPORTANT</code>) at the <code>verbosity = -1</code> (<code>-q</code>) level.</p> Source code in <code>enderchest/loggers.py</code> <pre><code>def verbosity_to_log_level(verbosity: int) -&gt; int:\n    \"\"\"Convert a verbosity level (number of `-v`s minus number of `-q`s) to\n    a logging level\n\n    Parameters\n    ----------\n    verbosity: int\n        A verbosity level usually specified by the number of `-v` flags a user\n        provides minus the number of `-q` flags. As a baseline, a verbosity of\n        0 will set the level to handle all INFO-level messages and above.\n\n    Returns\n    -------\n    int\n        The corresponding log level that should be set\n\n    Notes\n    -----\n    Technically the default logging level is set just high enough to exclude\n    DEBUG by default. This allows us to capture intermediate log levels (read:\n    `IMPORTANT`) at the `verbosity = -1` (`-q`) level.\n    \"\"\"\n    return logging.DEBUG + 1 - 10 * verbosity\n</code></pre>"},{"location":"reference/enderchest/place/","title":"place","text":"<p>Symlinking functionality</p>"},{"location":"reference/enderchest/place/#enderchest.place.cache_placements","title":"<code>cache_placements(minecraft_root, placements)</code>","text":"<p>Write placement record to file</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>placements</code> <code>dict</code> <p>A record of placed links, as generated by <code>place_ender_chest</code></p> required Source code in <code>enderchest/place.py</code> <pre><code>def cache_placements(\n    minecraft_root: Path, placements: dict[str, dict[Path, list[str]]]\n) -&gt; None:\n    \"\"\"Write placement record to file\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    placements : dict\n        A record of placed links, as generated by `place_ender_chest`\n    \"\"\"\n    cache_file = fs.place_cache(minecraft_root)\n    cache_file.write_text(\n        json.dumps(\n            {\n                instance_name: {\n                    str(resource_path): shulker_boxes\n                    for resource_path, shulker_boxes in instance_placements.items()\n                }\n                for instance_name, instance_placements in placements.items()\n            },\n            indent=4,\n            sort_keys=False,\n        )\n    )\n    PLACE_LOGGER.debug(\"Placement cache written to %s\", cache_file)\n</code></pre>"},{"location":"reference/enderchest/place/#enderchest.place.link_resource","title":"<code>link_resource(resource_path, shulker_root, instance_root, relative)</code>","text":"<p>Create a symlink for the specified resource from an instance's space pointing to the tagged file / folder living inside a shulker box.</p> <p>Parameters:</p> Name Type Description Default <code>resource_path</code> <code>str or Path</code> <p>Location of the resource relative to the instance's \".minecraft\" folder</p> required <code>shulker_root</code> <code>Path</code> <p>The path to the shulker box</p> required <code>instance_root</code> <code>Path</code> <p>The path to the instance's \".minecraft\" folder</p> required <code>relative</code> <code>bool</code> <p>If True, the link will be use a relative path if possible. Otherwise, an absolute path will be used, regardless of whether a relative or absolute path was provided.</p> required <p>Raises:</p> Type Description <code>OSError</code> <p>If a file or non-empty directory already exists where you're attempting to place the symlink</p>"},{"location":"reference/enderchest/place/#enderchest.place.link_resource--notes","title":"Notes","text":"<ul> <li>This method will create any folders that do not exist within an instance</li> <li>This method will overwrite existing symlinks and empty folders   but will not overwrite or delete any actual files.</li> </ul> Source code in <code>enderchest/place.py</code> <pre><code>def link_resource(\n    resource_path: str | Path,\n    shulker_root: Path,\n    instance_root: Path,\n    relative: bool,\n) -&gt; None:\n    \"\"\"Create a symlink for the specified resource from an instance's space\n    pointing to the tagged file / folder living inside a shulker box.\n\n    Parameters\n    ----------\n    resource_path : str or Path\n        Location of the resource relative to the instance's \".minecraft\" folder\n    shulker_root : Path\n        The path to the shulker box\n    instance_root : Path\n        The path to the instance's \".minecraft\" folder\n    relative : bool\n        If True, the link will be use a relative path if possible. Otherwise,\n        an absolute path will be used, regardless of whether a relative or\n        absolute path was provided.\n\n    Raises\n    ------\n    OSError\n        If a file or non-empty directory already exists where you're attempting\n        to place the symlink\n\n    Notes\n    -----\n    - This method will create any folders that do not exist within an instance\n    - This method will overwrite existing symlinks and empty folders\n      but will not overwrite or delete any actual files.\n    \"\"\"\n    instance_path = (instance_root / resource_path).expanduser().absolute()\n    instance_path.parent.mkdir(parents=True, exist_ok=True)\n\n    target: str | Path = (shulker_root / resource_path).expanduser().absolute()\n    if relative:\n        target = os.path.relpath(target, instance_path.parent)\n    else:\n        target = target.resolve()  # type: ignore\n\n    if instance_path.is_symlink():\n        # remove previous symlink in this spot\n        instance_path.unlink()\n        PLACE_LOGGER.debug(f\"Removed previous link at {instance_path}\")\n    else:\n        try:\n            os.rmdir(instance_path)\n            PLACE_LOGGER.debug(f\"Removed empty directory at {instance_path}\")\n        except FileNotFoundError:\n            pass  # A-OK\n\n    PLACE_LOGGER.debug(f\"Linking {instance_path} to {target}\")\n    os.symlink(\n        target,\n        instance_path,\n        target_is_directory=(shulker_root / resource_path).is_dir(),\n    )\n</code></pre>"},{"location":"reference/enderchest/place/#enderchest.place.list_placements","title":"<code>list_placements(minecraft_root, pattern, instance_name=None)</code>","text":"<p>Report all shulker boxes that provide files matching the given pattern</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>pattern</code> <code>filename, path or glob pattern</code> <p>The pattern of the resource to trace</p> required <code>instance_name</code> <code>str</code> <p>The name of the instance to search. This variable is case-sensitive. If None is given, all instances will be searched.</p> <code>None</code> Source code in <code>enderchest/place.py</code> <pre><code>def list_placements(\n    minecraft_root: Path, pattern: str, instance_name: str | None = None\n) -&gt; None:\n    \"\"\"Report all shulker boxes that provide files matching the given pattern\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    pattern : filename, path or glob pattern\n        The pattern of the resource to trace\n    instance_name : str, optional\n        The name of the instance to search. This variable is case-sensitive.\n        If None is given, all instances will be searched.\n    \"\"\"\n    try:\n        placements = load_placement_cache(minecraft_root)\n    except OSError as no_cache:\n        PLACE_LOGGER.error(\n            \"The placement cache could not be loaded:\"\n            \"\\n  %s\"\n            \"\\nPlease run enderchest place again to regenerate the cache.\",\n            no_cache,\n        )\n        return\n    try:\n        matches = trace_resource(\n            minecraft_root, pattern, placements, instance_name=instance_name\n        )\n    except KeyError:\n        PLACE_LOGGER.error(\n            \"No instance named %s is registered to this EnderChest\", instance_name\n        )\n        return\n    if len(matches) == 0:\n        PLACE_LOGGER.warning(\n            \"Could not find any placed resources matching the pattern %s%s.\"\n            \"\\n\\nNote: this command does not check inside linked folders.\",\n            pattern,\n            f\"\\nin the instance {instance_name}\" if instance_name else \"\",\n        )\n        return\n    for match in matches:\n        report_resource_trace(minecraft_root, *match)\n</code></pre>"},{"location":"reference/enderchest/place/#enderchest.place.load_placement_cache","title":"<code>load_placement_cache(minecraft_root)</code>","text":"<p>Load the placement cache from file</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A record of the placed symlinks, structured as a nested dict, matching the schema of one generated by <code>place_ender_chest</code></p> <p>Raises</p> <code>------</code> <code>OSError</code> <p>If the placement cache could not be found, read or parsed</p> Source code in <code>enderchest/place.py</code> <pre><code>def load_placement_cache(minecraft_root: Path) -&gt; dict[str, dict[Path, list[str]]]:\n    \"\"\"Load the placement cache from file\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n\n    Returns\n    -------\n    dict\n        A record of the placed symlinks, structured as a nested dict, matching\n        the schema of one generated by `place_ender_chest`\n\n        Raises\n    ------\n    OSError\n        If the placement cache could not be found, read or parsed\n    \"\"\"\n    try:\n        cache_file = fs.place_cache(minecraft_root)\n        PLACE_LOGGER.debug(\n            f\"Loading placement cache from %s\", fs.place_cache(minecraft_root)\n        )\n        raw_dict: dict[str, dict[str, list[str]]] = json.loads(\n            cache_file.read_text(\"UTF-8\")\n        )\n    except json.JSONDecodeError as decode_error:\n        raise OSError(\n            f\"{fs.place_cache(minecraft_root)} is corrupted and could not be parsed:\"\n            f\"\\n{decode_error}\"\n        )\n    return {\n        instance_name: {\n            Path(resource_path): shulker_boxes\n            for resource_path, shulker_boxes in instance_placements.items()\n        }\n        for instance_name, instance_placements in raw_dict.items()\n    }\n</code></pre>"},{"location":"reference/enderchest/place/#enderchest.place.place_ender_chest","title":"<code>place_ender_chest(minecraft_root, keep_broken_links=False, keep_stale_links=False, error_handling='abort', relative=True, rollback=False)</code>","text":"<p>Link all instance files and folders to all shulker boxes</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>keep_broken_links</code> <code>bool</code> <p>By default, this method will remove any broken links in your instances and servers folders. To disable this behavior, pass in <code>keep_broken_links=True</code>.</p> <code>False</code> <code>keep_stale_links</code> <code>bool</code> <p>By default, this method will remove any links into your EnderChest folder that are no longer specified by any shulker box (such as because the instance spec or shulker box configuration changed). To disable this behavior, pass in <code>keep_stale_links=True</code>.</p> <code>False</code> <code>error_handling</code> <code>str</code> <p>By default, if a linking failure occurs, this method will terminate immediately (<code>error_handling=abort</code>). Alternatively,   - pass in <code>error_handling=\"ignore\"</code> to continue as if the link failure     hadn't occurred   - pass in <code>error_handling=\"skip\"</code> to abort linking the current instance     to the current shulker box but otherwise continue on   - pass in <code>error_handling=\"skip-instance\"</code> to abort linking the current     instance altogether but to otherwise continue on with other instances   - pass in <code>error_handling=\"skip-shulker-box\"</code> to abort linking to the current     shulker box altogether but to otherwise continue on with other boxes   - pass in <code>error_handling=\"prompt\"</code> to ask what to do on each failure</p> <code>'abort'</code> <code>relative</code> <code>bool</code> <p>By default, links will use relative paths when possible. To use absolute paths instead (see: https://bugs.mojang.com/projects/MC/issues/MC-263046), pass in <code>relative=False</code>. See note below.</p> <code>True</code> <code>rollback</code> <code>bool</code> <p>In the future in the event of linking errors passing in <code>rollback=True</code> can be used to roll back any changes that have already been applied based on the error-handling method specified.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A record of the placed symlinks, structured as a nested dict:</p> <ul> <li>the top-level keys are the instance names, with the values being a map   of the links placed within those instances:<ul> <li>the keys of those mappings are the relative paths of the placed   symlinks inside the instance folder</li> <li>the values are the list of shulker boxes, sorted in ascending   priority, into which that symlink was linked (explicitly, the   last entry in each list corresponds to the shulker box inside   which that link currently points)</li> </ul> </li> </ul>"},{"location":"reference/enderchest/place/#enderchest.place.place_ender_chest--notes","title":"Notes","text":"<ul> <li>If one of the files or folders being placed is itself a symlink, relative   links will be created as nested links (a link pointing to the link),   whereas in \"absolute\" mode (<code>relative=False</code>), the link that will be   placed will point directly to the final target.</li> <li>This can lead to the stale-link cleanup behavior not correctly removing   an outdated symlink if the fully resolved target of a link falls outside   the EnderChest folder.</li> </ul> Source code in <code>enderchest/place.py</code> <pre><code>def place_ender_chest(\n    minecraft_root: Path,\n    keep_broken_links: bool = False,\n    keep_stale_links: bool = False,\n    error_handling: str = \"abort\",\n    relative: bool = True,\n    rollback: bool = False,\n) -&gt; dict[str, dict[Path, list[str]]]:\n    \"\"\"Link all instance files and folders to all shulker boxes\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    keep_broken_links : bool, optional\n        By default, this method will remove any broken links in your instances\n        and servers folders. To disable this behavior, pass in\n        `keep_broken_links=True`.\n    keep_stale_links : bool, optional\n        By default, this method will remove any links into your EnderChest folder\n        that are no longer specified by any shulker box (such as because the\n        instance spec or shulker box configuration changed). To disable this\n        behavior, pass in `keep_stale_links=True`.\n    error_handling : str, optional\n        By default, if a linking failure occurs, this method will terminate\n        immediately (`error_handling=abort`). Alternatively,\n          - pass in `error_handling=\"ignore\"` to continue as if the link failure\n            hadn't occurred\n          - pass in `error_handling=\"skip\"` to abort linking the current instance\n            to the current shulker box but otherwise continue on\n          - pass in `error_handling=\"skip-instance\"` to abort linking the current\n            instance altogether but to otherwise continue on with other instances\n          - pass in `error_handling=\"skip-shulker-box\"` to abort linking to the current\n            shulker box altogether but to otherwise continue on with other boxes\n          - pass in `error_handling=\"prompt\"` to ask what to do on each failure\n    relative : bool, optional\n        By default, links will use relative paths when possible. To use absolute\n        paths instead (see: https://bugs.mojang.com/projects/MC/issues/MC-263046),\n        pass in `relative=False`. See note below.\n    rollback: bool, optional\n        In the future in the event of linking errors passing in `rollback=True`\n        can be used to roll back any changes that have already been applied\n        based on the error-handling method specified.\n\n    Returns\n    -------\n    dict\n        A record of the placed symlinks, structured as a nested dict:\n\n        - the top-level keys are the instance names, with the values being a map\n          of the links placed within those instances:\n            - the keys of those mappings are the relative paths of the placed\n              symlinks inside the instance folder\n            - the values are the list of shulker boxes, sorted in ascending\n              priority, into which that symlink was linked (explicitly, the\n              _last_ entry in each list corresponds to the shulker box inside\n              which that link currently points)\n\n    Notes\n    -----\n    - If one of the files or folders being placed is itself a symlink, relative\n      links will be created as *nested* links (a link pointing to the link),\n      whereas in \"absolute\" mode (`relative=False`), the link that will be\n      placed will point **directly** to the final target.\n    - This can lead to the stale-link cleanup behavior not correctly removing\n      an outdated symlink if the fully resolved target of a link falls outside\n      the EnderChest folder.\n    \"\"\"\n    placements: dict[str, dict[Path, list[str]]] = {}\n\n    if rollback is not False:  # pragma: no cover\n        raise NotImplementedError(\"Rollbacks are not currently supported\")\n\n    try:\n        host = load_ender_chest(minecraft_root).name\n    except (FileNotFoundError, ValueError) as bad_chest:\n        PLACE_LOGGER.error(\n            f\"Could not load EnderChest from {minecraft_root}:\\n  {bad_chest}\"\n        )\n        return {}\n\n    instances = load_ender_chest_instances(minecraft_root, log_level=logging.DEBUG)\n\n    shulker_boxes: list[ShulkerBox] = []\n\n    for shulker_box in load_shulker_boxes(minecraft_root, log_level=logging.DEBUG):\n        if not shulker_box.matches_host(host):\n            PLACE_LOGGER.debug(\n                f\"{shulker_box.name} is not intended for linking to this host ({host})\"\n            )\n            continue\n        shulker_boxes.append(shulker_box)\n\n    skip_boxes: list[ShulkerBox] = []\n\n    def handle_error(shulker_box: ShulkerBox | None) -&gt; str:\n        \"\"\"Centralized error-handling\n\n        Parameters\n        ----------\n        shulker_box:\n            The current shulker box (in case it needs to be added to the skip list)\n\n        Returns\n        -------\n        str\n            Instructions on what to do next. Options are:\n              - retry\n              - return\n              - break\n              - continue\n              - pass\n        \"\"\"\n        if error_handling == \"prompt\":\n            proceed_how = (\n                prompt(\n                    \"How would you like to proceed?\"\n                    \"\\n[Q]uit; [R]etry; [C]ontinue; skip linking the rest of this:\"\n                    \"\\n[I]nstance, [S]hulker box, shulker/instance [M]atch?\",\n                    suggestion=\"R\",\n                )\n                .lower()\n                .replace(\" \", \"\")\n                .replace(\"-\", \"\")\n                .replace(\"_\", \"\")\n            )\n            match proceed_how:\n                case \"\" | \"r\":\n                    proceed_how = \"retry\"\n                case \"\" | \"i\" | \"instance\" | \"skipinstance\":\n                    proceed_how = \"skip-instance\"\n                case \"q\" | \"quit\" | \"abort\" | \"exit\" | \"stop\":\n                    proceed_how = \"abort\"\n                case \"c\" | \"continue\" | \"ignore\":\n                    proceed_how = \"ignore\"\n                case \"m\" | \"match\" | \"skip\":\n                    proceed_how = \"skip\"\n                case \"s\" | \"shulker\" | \"shulkerbox\" | \"skipshulker\":\n                    proceed_how = \"skip-shulker\"\n                case _:\n                    PLACE_LOGGER.error(\"Invalid selection.\")\n                    return handle_error(shulker_box)\n        else:\n            proceed_how = error_handling\n\n        match proceed_how:\n            case \"retry\":\n                return \"retry\"\n            case \"abort\" | \"stop\" | \"quit\" | \"exit\":\n                PLACE_LOGGER.error(\"Aborting\")\n                return \"return\"\n            case \"ignore\":\n                PLACE_LOGGER.debug(\"Ignoring\")\n                return \"pass\"\n            case \"skip\":\n                PLACE_LOGGER.warning(\"Skipping the rest of this match\")\n                return \"continue\"\n            case \"skip-instance\":\n                PLACE_LOGGER.warning(\"Skipping any more linking from this instance\")\n\n                return \"break\"\n            case \"skip-shulker-box\" | \"skip-shulkerbox\" | \"skip-shulker\":\n                PLACE_LOGGER.warning(\"Skipping any more linking into this shulker box\")\n                if shulker_box:\n                    skip_boxes.append(shulker_box)\n                return \"continue\"\n            case _:\n                raise ValueError(\n                    f\"Unrecognized error-handling method: {error_handling}\"\n                )\n\n    for instance in instances:\n        instance_root = (minecraft_root / instance.root.expanduser()).expanduser()\n        placements[instance.name] = defaultdict(list)\n\n        handling: str | None = \"retry\"\n        while handling == \"retry\":\n            if instance_root.exists():\n                handling = None\n                break\n\n            PLACE_LOGGER.error(\n                \"No minecraft instance exists at\"\n                f\" {instance_root.expanduser().absolute()}\"\n            )\n            handling = handle_error(None)\n        if handling is not None:\n            match handling:\n                case \"return\":\n                    return placements\n                case \"break\":\n                    break\n                case _:  # nothing to link, so might as well skip the rest\n                    continue\n\n        # start by removing all existing symlinks into the EnderChest\n        if not keep_stale_links:\n            for file in instance_root.rglob(\"*\"):\n                if file.is_symlink():\n                    if fs.links_into_enderchest(minecraft_root, file):\n                        PLACE_LOGGER.debug(\n                            f\"Removing old link: {file} -&gt; {os.readlink(file)}\"\n                        )\n                        file.unlink()\n\n        for shulker_box in shulker_boxes:\n            if not shulker_box.matches(instance):\n                continue\n            if shulker_box in skip_boxes:\n                continue\n\n            box_root = shulker_box.root.expanduser().absolute()\n\n            PLACE_LOGGER.info(f\"Linking {instance.root} to {shulker_box.name}\")\n\n            resources = set(_rglob(box_root, shulker_box.max_link_depth))\n\n            match_exit = \"pass\"\n            for link_folder in shulker_box.link_folders:\n                resources -= {box_root / link_folder}\n                resources -= set((box_root / link_folder).rglob(\"*\"))\n\n                handling = \"retry\"\n                while handling == \"retry\":\n                    try:\n                        link_resource(link_folder, box_root, instance_root, relative)\n                        placements[instance.name][Path(link_folder)].append(\n                            shulker_box.name\n                        )\n                        handling = None\n                    except OSError:\n                        PLACE_LOGGER.error(\n                            f\"Error linking shulker box {shulker_box.name}\"\n                            f\" to instance {instance.name}:\"\n                            f\"\\n  {(instance.root / link_folder)} is a\"\n                            \" non-empty directory\"\n                        )\n                        handling = handle_error(shulker_box)\n                if handling is not None:\n                    match handling:\n                        case \"return\":\n                            return placements\n                        case \"break\":\n                            match_exit = \"break\"\n                            break\n                        case \"continue\":\n                            match_exit = \"continue\"\n                            break\n                        case \"pass\":\n                            continue  # or pass--it's the end of the loop\n\n            if match_exit not in (\"break\", \"continue\"):\n                for resource in resources:\n                    resource_path = resource.relative_to(box_root)\n                    for pattern in shulker_box.do_not_link:\n                        if fnmatch.fnmatchcase(\n                            str(resource_path), pattern\n                        ) or fnmatch.fnmatchcase(\n                            str(resource_path), os.path.join(\"*\", pattern)\n                        ):\n                            PLACE_LOGGER.debug(\n                                \"Skipping %s (matches pattern %s)\",\n                                resource_path,\n                                pattern,\n                            )\n                            break\n                    else:\n                        handling = \"retry\"\n                        while handling == \"retry\":\n                            try:\n                                link_resource(\n                                    resource_path,\n                                    box_root,\n                                    instance_root,\n                                    relative,\n                                )\n                                placements[instance.name][resource_path].append(\n                                    shulker_box.name\n                                )\n                                handling = None\n                            except OSError:\n                                PLACE_LOGGER.error(\n                                    f\"Error linking shulker box {shulker_box.name}\"\n                                    f\" to instance {instance.name}:\"\n                                    f\"\\n  {(instance.root / resource_path)}\"\n                                    \" already exists\"\n                                )\n                                handling = handle_error(shulker_box)\n                        if handling is not None:\n                            match handling:\n                                case \"return\":\n                                    return placements\n                                case \"break\":\n                                    match_exit = \"break\"\n                                    break\n                                case \"continue\":\n                                    match_exit = \"continue\"  # technically does nothing\n                                    break\n                                case \"pass\":\n                                    continue  # or pass--it's the end of the loop\n\n            # consider this a \"finally\"\n            if not keep_broken_links:\n                # we clean up as we go, just in case of a failure\n                for file in instance_root.rglob(\"*\"):\n                    if not file.exists():\n                        PLACE_LOGGER.debug(f\"Removing broken link: {file}\")\n                        file.unlink()\n\n            if match_exit == \"break\":\n                break\n    return placements\n</code></pre>"},{"location":"reference/enderchest/place/#enderchest.place.report_resource_trace","title":"<code>report_resource_trace(minecraft_root, instance_root, resource_path, boxes)</code>","text":"<p>Print (log) the shulker boxes an instance resource is linked to</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>instance_root</code> <code>Path</code> <p>The path of the EnderChest-placed symlink</p> required <code>resource_path</code> <code>Path</code> <p>The path to the symlink, relative to the instance root</p> required <code>boxes</code> <code>list of str</code> <p>The names of the shulker boxes, sorted by ascending priority, that are targeted by this symlink (technically only the last entry in this list is the actual target)</p> required Source code in <code>enderchest/place.py</code> <pre><code>def report_resource_trace(\n    minecraft_root: Path, instance_root: Path, resource_path: Path, boxes: Sequence[str]\n) -&gt; None:\n    \"\"\"Print (log) the shulker boxes an instance resource is linked to\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    instance_root : Path\n        The path of the EnderChest-placed symlink\n    resource_path : Path\n        The path to the symlink, relative to the instance root\n    boxes : list of str\n        The names of the shulker boxes, sorted by ascending priority, that are\n        targeted by this symlink (technically only the last entry in this list\n        is the actual target)\n    \"\"\"\n    symlink_location = instance_root / resource_path\n    if len(boxes) == 0:  # pragma: no cover\n        # Since defaultdicts are involved, this could happen accidentally at\n        # some point and should just be ignored\n        return\n    *other_box_names, primary_box_name = boxes\n    try:\n        PLACE_LOGGER.log(\n            IMPORTANT,\n            \"%s currently resolves to %s\",\n            symlink_location,\n            os.path.abspath(\n                (\n                    symlink_location / (minecraft_root / symlink_location).readlink()\n                ).expanduser()\n            ),\n        )\n    except OSError:\n        PLACE_LOGGER.warning(\n            \"%s no longer exists or is not a symlink\", symlink_location\n        )\n\n    PLACE_LOGGER.log(\n        IMPORTANT,\n        \"    based on being linked into shulker box: %s\",\n        primary_box_name,\n    )\n    PLACE_LOGGER.debug(\n        \"        - &gt; %s\",\n        fs.shulker_box_root(minecraft_root, primary_box_name) / resource_path,\n    )\n\n    for box_name in reversed(other_box_names):\n        PLACE_LOGGER.info(\"    which overwrote the link into shulker box: %s\", box_name)\n        PLACE_LOGGER.debug(\n            \"        - &gt; %s\",\n            fs.shulker_box_root(minecraft_root, box_name) / resource_path,\n        )\n</code></pre>"},{"location":"reference/enderchest/place/#enderchest.place.trace_resource","title":"<code>trace_resource(minecraft_root, pattern, placements, instance_name=None)</code>","text":"<p>Given a filename or glob pattern, return a list of all matching EnderChest-placed symlinks, together with a trace-back of the shulker boxes each link targets</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>pattern</code> <code>filename, path or glob pattern</code> <p>The resource to trace</p> required <code>placements</code> <code>dict</code> <p>A record of placed symlinks, such as the one generated by <code>place_ender_chest</code>.</p> required <code>instance_name</code> <code>str</code> <p>The name of the instance to search. This variable is case-sensitive. If None is given, all instances will be searched.</p> <code>None</code> <p>Returns:</p> Type Description <code>list of (Path, Path, list) tuples</code> <ul> <li>The first item in each list is the path of the instance root</li> <li>The second item in each list is the path to a linked resource   matching the provided pattern (and instance), relative to the instance   root</li> <li>The third item is the list of shulker boxes, sorted in ascending   priority, into which that symlink was linked (explicitly, the   last entry in each list corresponds to the shulker box inside   which that link currently points)</li> </ul> <p>Raises:</p> Type Description <code>OSError</code> <p>If no placement cache was provided and the placement cache file could not be found, read or parsed</p> <code>KeyError</code> <p>If there is no instance registered to this EnderChest with the specified name</p> Source code in <code>enderchest/place.py</code> <pre><code>def trace_resource(\n    minecraft_root: Path,\n    pattern: str,\n    placements: dict[str, dict[Path, list[str]]],\n    instance_name: str | None = None,\n) -&gt; list[tuple[Path, Path, list[str]]]:\n    \"\"\"Given a filename or glob pattern, return a list of all matching\n    EnderChest-placed symlinks, together with a trace-back of the shulker boxes\n    each link targets\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    pattern : filename, path or glob pattern\n        The resource to trace\n    placements : dict\n        A record of placed symlinks, such as the one generated by `place_ender_chest`.\n    instance_name : str, optional\n        The name of the instance to search. This variable is case-sensitive.\n        If None is given, all instances will be searched.\n\n    Returns\n    -------\n    list of (Path, Path, list) tuples\n        - The first item in each list is the path of the instance root\n        - The second item in each list is the path to a linked resource\n          matching the provided pattern (and instance), relative to the instance\n          root\n        - The third item is the list of shulker boxes, sorted in ascending\n          priority, into which that symlink was linked (explicitly, the\n          _last_ entry in each list corresponds to the shulker box inside\n          which that link currently points)\n\n    Raises\n    ------\n    OSError\n        If no placement cache was provided and the placement cache file could\n        not be found, read or parsed\n    KeyError\n        If there is no instance registered to this EnderChest with the specified\n        name\n    \"\"\"\n    instances = {\n        instance.name: instance\n        for instance in load_ender_chest_instances(\n            minecraft_root, log_level=logging.DEBUG\n        )\n    }\n    if instance_name is None:\n        return sum(\n            (\n                trace_resource(minecraft_root, pattern, placements, name)\n                for name in instances\n            ),\n            [],\n        )\n    instance_root = instances[instance_name].root\n    matches: list[tuple[Path, Path, list[str]]] = []\n    for resource_path, target_boxes in placements[instance_name].items():\n        if (\n            fnmatch.fnmatchcase(str(resource_path), pattern)\n            or fnmatch.fnmatchcase(str(resource_path), os.path.join(\"*\", pattern))\n            or fnmatch.fnmatchcase(\n                os.path.abspath(minecraft_root / instance_root / resource_path),\n                os.path.join(\"*\", pattern),\n            )\n        ):\n            matches.append((instance_root, resource_path, target_boxes))\n    return matches\n</code></pre>"},{"location":"reference/enderchest/prompt/","title":"prompt","text":"<p>Utilities for helping build interactive prompts</p>"},{"location":"reference/enderchest/prompt/#enderchest.prompt.confirm","title":"<code>confirm(default)</code>","text":"<p>Confirm that the user wishes to continue</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>bool</code> <p>Whether the default selection should be True (yes) or False (no)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the user has opted to continue</p> Source code in <code>enderchest/prompt.py</code> <pre><code>def confirm(default: bool) -&gt; bool:\n    \"\"\"Confirm that the user wishes to continue\n\n    Parameters\n    ----------\n    default : bool\n        Whether the default selection should be True (yes) or False (no)\n\n    Returns\n    -------\n    bool\n        Whether the user has opted to continue\n    \"\"\"\n\n    response = prompt(\"Do you wish to continue?\", \"Y/n\" if default else \"y/N\")\n\n    if response == \"\":\n        return default\n\n    if response in YES:\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/enderchest/prompt/#enderchest.prompt.prompt","title":"<code>prompt(message, suggestion=None, is_password=False)</code>","text":"<p>Prompt the user and return the response</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The prompt message</p> required <code>suggestion</code> <code>str</code> <p>A suggested input. If None is provided, no suggestion will be shown.</p> <code>None</code> <code>is_password</code> <code>bool</code> <p>If this is a prompt for a password, pass in <code>is_password = True</code> to hide the user's input</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The user-provided response</p>"},{"location":"reference/enderchest/prompt/#enderchest.prompt.prompt--notes","title":"Notes","text":"<ul> <li>The output will be stripped of trailing and leading whitespace, but no   other validation or processing will be used.</li> <li>Regardless of whether a suggestion is provided, if the user provides an   empty input, this method will return an empty string. To reiterate: the   suggestion does not serve as a default / fallback value.</li> </ul> Source code in <code>enderchest/prompt.py</code> <pre><code>def prompt(\n    message: str, suggestion: str | None = None, is_password: bool = False\n) -&gt; str:\n    \"\"\"Prompt the user and return the response\n\n    Parameters\n    ----------\n    message : str\n        The prompt message\n    suggestion : str, optional\n        A suggested input. If None is provided, no suggestion will be shown.\n    is_password : bool, optional\n        If this is a prompt for a password, pass in `is_password = True` to\n        hide the user's input\n\n    Returns\n    -------\n    str\n        The user-provided response\n\n    Notes\n    -----\n    - The output will be stripped of trailing and leading whitespace, but no\n      other validation or processing will be used.\n    - Regardless of whether a suggestion is provided, if the user provides an\n      empty input, this method will return an empty string. To reiterate: the\n      suggestion *does not serve* as a default / fallback value.\n    \"\"\"\n    lines = message.splitlines() + [\"\"]\n    message = \"\\n\".join(f\"{CURSOR}\\x1b[1m {line}\\x1b[0m\" for line in lines)\n    if suggestion is not None:\n        message += f\"\\x1b[35;1m[{suggestion}]\\x1b[0m \"\n    if is_password:\n        return getpass.getpass(prompt=message)\n    return input(message)\n</code></pre>"},{"location":"reference/enderchest/remote/","title":"remote","text":"<p>Higher-level functionality around synchronizing with different EnderCherts</p>"},{"location":"reference/enderchest/remote/#enderchest.remote.fetch_remotes_from_a_remote_ender_chest","title":"<code>fetch_remotes_from_a_remote_ender_chest(uri)</code>","text":"<p>Grab the list of EnderChests registered with the specified remote EnderChest</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>URI</code> <p>The URI to the remote Minecraft root</p> required <p>Returns:</p> Type Description <code>list of (URI, str) tuples</code> <p>The URIs of the remote EnderChests, paired with their aliases</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the remote list could not be pulled</p> Source code in <code>enderchest/remote.py</code> <pre><code>def fetch_remotes_from_a_remote_ender_chest(\n    uri: str | ParseResult,\n) -&gt; list[tuple[ParseResult, str]]:\n    \"\"\"Grab the list of EnderChests registered with the specified remote EnderChest\n\n    Parameters\n    ----------\n    uri : URI\n        The URI to the remote Minecraft root\n\n    Returns\n    -------\n    list of (URI, str) tuples\n        The URIs of the remote EnderChests, paired with their aliases\n\n    Raises\n    ------\n    RuntimeError\n        If the remote list could not be pulled\n    \"\"\"\n    remote_chest = load_remote_ender_chest(uri)\n    remotes: list[tuple[ParseResult, str]] = [\n        (urlparse(uri) if isinstance(uri, str) else uri, remote_chest.name)\n    ]\n\n    remotes.extend(remote_chest.remotes)\n    SYNC_LOGGER.info(\n        \"Loaded the following remotes:\\n %s\",\n        \"\\n\".join(f\"  - {render_remote(alias, uri)}\" for uri, alias in remotes),\n    )\n\n    if len(set(alias for _, alias in remotes)) != len(remotes):\n        raise RuntimeError(\n            f\"There are duplicates aliases in the list of remotes pulled from {uri}\"\n        )\n    return remotes\n</code></pre>"},{"location":"reference/enderchest/remote/#enderchest.remote.load_remote_ender_chest","title":"<code>load_remote_ender_chest(uri)</code>","text":"<p>Load an EnderChest configuration from another machine</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>URI</code> <p>The URI to the remote Minecraft root</p> required <p>Returns:</p> Type Description <code>EnderChest</code> <p>The remote EnderChest configuration</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided URI is invalid</p> <code>RuntimeError</code> <p>If the config from the remote EnderChest could not be parsed</p> Source code in <code>enderchest/remote.py</code> <pre><code>def load_remote_ender_chest(uri: str | ParseResult) -&gt; EnderChest:\n    \"\"\"Load an EnderChest configuration from another machine\n\n    Parameters\n    ----------\n    uri : URI\n        The URI to the remote Minecraft root\n\n    Returns\n    -------\n    EnderChest\n        The remote EnderChest configuration\n\n    Raises\n    ------\n    ValueError\n        If the provided URI is invalid\n    RuntimeError\n        If the config from the remote EnderChest could not be parsed\n    \"\"\"\n    try:\n        uri = uri if isinstance(uri, ParseResult) else urlparse(uri)\n    except AttributeError as bad_uri:\n        raise ValueError(f\"{uri} is not a valid URI\") from bad_uri\n\n    remote_root = Path(uri.path)\n    remote_config_path = fs.ender_chest_config(remote_root, check_exists=False)\n    uri = uri._replace(path=remote_config_path.as_posix())\n\n    with remote_file(uri) as remote_config:\n        try:\n            return EnderChest.from_cfg(remote_config)\n        except ValueError as bad_chest:\n            raise RuntimeError(\n                \"The remote EnderChest config downloaded\"\n                f\"from {uri.geturl()} could not be parsed.\"\n            ) from bad_chest\n</code></pre>"},{"location":"reference/enderchest/remote/#enderchest.remote.sync_with_remotes","title":"<code>sync_with_remotes(minecraft_root, pull_or_push, dry_run=False, sync_confirm_wait=None, **sync_kwargs)</code>","text":"<p>Pull changes from or push changes to remote EnderChests</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder). This will be used to construct relative paths.</p> required <code>pull_or_push</code> <code>str</code> <p>\"pull\" or \"push\"</p> required <code>dry_run</code> <code>bool</code> <p>Perform a dry run of the sync operation, reporting the operations         that will be performed but not actually carrying them out</p> <code>False</code> <code>sync_confirm_wait</code> <code>bool or int</code> <p>The default behavior when syncing EnderChests is to first perform a dry run of every sync operation and then wait 5 seconds before proceeding with the real sync. The idea is to give the user time to interrupt the sync if the dry run looks wrong. This can be changed by either raising or lowering the value of confirm, by disabling the dry-run-first behavior entirely (<code>confirm=False</code>) or by requiring that the user explicitly confirms the sync (<code>confirm=True</code>). This default behavior can also be modified in the EnderChest config. This parameter will be ignored when performing a dry run.</p> <code>None</code> <code>sync_kwargs</code> <p>Any additional arguments that should be passed into the syncing operation</p> <code>{}</code>"},{"location":"reference/enderchest/remote/#enderchest.remote.sync_with_remotes--notes","title":"Notes","text":"<ul> <li>When pulling changes, this method will try each remote in the order they   are configured and stop once it has successfully pulled from a remote.</li> </ul> <p>This method will attempt to push local changes to every remote</p> Source code in <code>enderchest/remote.py</code> <pre><code>def sync_with_remotes(\n    minecraft_root: Path,\n    pull_or_push: str,\n    dry_run: bool = False,\n    sync_confirm_wait: bool | int | None = None,\n    **sync_kwargs,\n) -&gt; None:\n    \"\"\"Pull changes from or push changes to remote EnderChests\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder). This will be used to\n        construct relative paths.\n    pull_or_push : str\n        \"pull\" or \"push\"\n    dry_run: bool, optional\n         Perform a dry run of the sync operation, reporting the operations\\\n         that will be performed but not actually carrying them out\n    sync_confirm_wait : bool or int, optional\n        The default behavior when syncing EnderChests is to first perform a dry\n        run of every sync operation and then wait 5 seconds before proceeding with the\n        real sync. The idea is to give the user time to interrupt the sync if\n        the dry run looks wrong. This can be changed by either raising or lowering\n        the value of confirm, by disabling the dry-run-first behavior entirely\n        (`confirm=False`) or by requiring that the user explicitly confirms\n        the sync (`confirm=True`). This default behavior can also be modified\n        in the EnderChest config. This parameter will be ignored when performing\n        a dry run.\n    sync_kwargs\n        Any additional arguments that should be passed into the syncing\n        operation\n\n    Notes\n    -----\n    - When pulling changes, this method will try each remote in the order they\n      are configured and stop once it has successfully pulled from a remote.\n\n    This method will attempt to push local changes to *every* remote\n    \"\"\"\n    if pull_or_push not in (\"pull\", \"push\"):\n        raise ValueError(\n            'Invalid choice for sync operation. Choices are \"pull\" and \"push\"'\n        )\n    try:\n        if sync_confirm_wait is None:\n            sync_confirm_wait = gather.load_ender_chest(\n                minecraft_root\n            ).sync_confirm_wait\n        this_chest = gather.load_ender_chest(minecraft_root)\n\n        # I know this is redundant, but we want those logs\n        remotes = gather.load_ender_chest_remotes(\n            minecraft_root, log_level=logging.DEBUG\n        )\n    except (FileNotFoundError, ValueError) as bad_chest:\n        SYNC_LOGGER.error(\n            f\"Could not load EnderChest from {minecraft_root}:\\n  {bad_chest}\"\n        )\n        return\n    if not remotes:\n        SYNC_LOGGER.error(\"EnderChest has no remotes. Aborting.\")\n        return  # kinda unnecessary\n\n    synced_somewhere = False\n    for remote_uri, alias in remotes:\n        if dry_run:\n            runs: tuple[bool, ...] = (True,)\n        elif sync_confirm_wait is False or sync_confirm_wait &lt;= 0:\n            runs = (False,)\n        else:\n            runs = (True, False)\n        for do_dry_run in runs:\n            if dry_run:\n                prefix = \"Simulating an attempt\"\n            else:\n                prefix = \"Attempting\"\n            try:\n                if pull_or_push == \"pull\":\n                    SYNC_LOGGER.log(\n                        IMPORTANT,\n                        f\"{prefix} to pull changes from %s\",\n                        render_remote(alias, remote_uri),\n                    )\n                    remote_chest = remote_uri._replace(\n                        path=urlparse(\n                            (\n                                fs.ender_chest_folder(\n                                    abspath_from_uri(remote_uri),\n                                    check_exists=False,\n                                )\n                            ).as_uri()\n                        ).path\n                    )\n                    pull(\n                        remote_chest,\n                        minecraft_root,\n                        exclude=[\n                            *this_chest.do_not_sync,\n                            *(sync_kwargs.pop(\"exclude\", None) or ()),\n                        ],\n                        dry_run=do_dry_run,\n                        **sync_kwargs,\n                    )\n                else:\n                    SYNC_LOGGER.log(\n                        IMPORTANT,\n                        f\"{prefix} to push changes\"\n                        f\" to {render_remote(alias, remote_uri)}\",\n                    )\n                    local_chest = fs.ender_chest_folder(minecraft_root)\n                    push(\n                        local_chest,\n                        remote_uri,\n                        exclude=[\n                            *this_chest.do_not_sync,\n                            *(sync_kwargs.pop(\"exclude\", None) or ()),\n                        ],\n                        dry_run=do_dry_run,\n                        **sync_kwargs,\n                    )\n            except (\n                FileNotFoundError,\n                ValueError,\n                NotImplementedError,\n                TimeoutError,\n                RuntimeError,\n            ) as sync_fail:\n                SYNC_LOGGER.warning(\n                    f\"Could not sync changes with {render_remote(alias, remote_uri)}:\"\n                    f\"\\n  {sync_fail}\"\n                )\n                break\n            if do_dry_run == runs[-1]:\n                continue\n            if sync_confirm_wait is True:\n                if not confirm(default=True):\n                    SYNC_LOGGER.error(\"Aborting\")\n                    return\n            else:\n                SYNC_LOGGER.debug(f\"Waiting for {sync_confirm_wait} seconds\")\n                sleep(sync_confirm_wait)\n        else:\n            synced_somewhere = True\n            if pull_or_push == \"pull\":\n                if this_chest.place_after_open and not dry_run:\n                    place.place_ender_chest(\n                        minecraft_root,\n                        keep_broken_links=False,\n                        keep_stale_links=False,\n                        error_handling=\"abort\",\n                        relative=False,\n                    )\n                break\n    if not synced_somewhere:\n        SYNC_LOGGER.error(\"Could not sync with any remote EnderChests\")\n</code></pre>"},{"location":"reference/enderchest/shulker_box/","title":"shulker_box","text":"<p>Specification and configuration of a shulker box</p>"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.ShulkerBox","title":"<code>ShulkerBox</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Specification of a shulker box</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>The priority for linking assets in the shulker box (higher priority boxes are linked last)</p> required <code>name</code> <code>str</code> <p>The name of the shulker box (which is incidentally used to break priority ties)</p> required <code>root</code> <code>Path</code> <p>The path to the root of the shulker box</p> required <code>match_criteria</code> <code>list-like of tuples</code> <p>The parameters for matching instances to this shulker box. Each element consists of:</p> <ul> <li>the name of the condition</li> <li>the matching values for that condition</li> </ul> <p>The logic applied is that an instance must match at least one value for each condition (so it's ANDing a collection of ORs)</p> required <code>link_folders</code> <code>list-like of str</code> <p>The folders that should be linked in their entirety</p> required <code>max_link_depth</code> <code>int</code> <p>By default, non-root-level folders (that is, folders inside of folders) will be treated as files for the purpose of linking. Put another way, only files with a depth of 2 or less from the shulker root will be linked. This behavior can be overridden by explicitly setting the <code>max_link_depth</code> value, but this feature is highly experimental, so use it at your own risk.</p> required <code>do_not_link</code> <code>list-like of str</code> <p>Glob patterns of files that should not be linked. By default, this list comprises <code>shulkerbox.cfg</code> and <code>.DS_Store</code> (for all you mac gamers).</p> required"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.ShulkerBox--notes","title":"Notes","text":"<p>A shulker box specification is immutable, so making changes (such as updating the match criteria) can only be done on copies created via the <code>_replace</code> method, inherited from the NamedTuple parent class.</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>class ShulkerBox(NamedTuple):\n    \"\"\"Specification of a shulker box\n\n    Parameters\n    ----------\n    priority : int\n        The priority for linking assets in the shulker box (higher priority\n        boxes are linked last)\n    name : str\n        The name of the shulker box (which is incidentally used to break\n        priority ties)\n    root : Path\n        The path to the root of the shulker box\n    match_criteria : list-like of tuples\n        The parameters for matching instances to this shulker box. Each element\n        consists of:\n\n          - the name of the condition\n          - the matching values for that condition\n\n        The logic applied is that an instance must match at least one value\n        for each condition (so it's ANDing a collection of ORs)\n    link_folders : list-like of str\n        The folders that should be linked in their entirety\n    max_link_depth : int, optional\n        By default, non-root-level folders (that is, folders inside of folders)\n        will be treated as files for the purpose of linking. Put another way,\n        only files with a depth of 2 or less from the shulker root will be\n        linked. This behavior can be overridden by explicitly setting\n        the `max_link_depth` value, but **this feature is highly experimental**,\n        so use it at your own risk.\n    do_not_link : list-like of str, optional\n        Glob patterns of files that should not be linked. By default, this list\n        comprises `shulkerbox.cfg` and `.DS_Store` (for all you mac gamers).\n\n    Notes\n    -----\n    A shulker box specification is immutable, so making changes (such as\n    updating the match criteria) can only be done on copies created via the\n    `_replace` method, inherited from the NamedTuple parent class.\n    \"\"\"\n\n    priority: int\n    name: str\n    root: Path\n    match_criteria: tuple[tuple[str, tuple[str, ...]], ...]\n    link_folders: tuple[str, ...]\n    max_link_depth: int = _DEFAULT_LINK_DEPTH\n    do_not_link: tuple[str, ...] = _DEFAULT_DO_NOT_LINK\n\n    @classmethod\n    def from_cfg(cls, config_file: Path) -&gt; \"ShulkerBox\":\n        \"\"\"Parse a shulker box from its config file\n\n        Parameters\n        ----------\n        config_file : Path\n            The path to the config file\n\n        Returns\n        -------\n        ShulkerBox\n            The resulting ShulkerBox\n\n        Raises\n        ------\n        ValueError\n            If the config file at that location cannot be parsed\n        FileNotFoundError\n            If there is no config file at the specified location\n        \"\"\"\n        priority = 0\n        max_link_depth = 2\n        root = config_file.parent\n        name = root.name\n        config = cfg.read_cfg(config_file)\n\n        match_criteria: dict[str, tuple[str, ...]] = {}\n\n        for section in config.sections():\n            normalized = (\n                section.lower().replace(\" \", \"\").replace(\"-\", \"\").replace(\"_\", \"\")\n            )\n            if normalized.endswith(\"s\"):\n                normalized = normalized[:-1]  # lazy de-pluralization\n            if normalized in (\"linkfolder\", \"folder\"):\n                normalized = \"link-folders\"\n            if normalized in (\"donotlink\",):\n                normalized = \"do-not-link\"\n            if normalized in (\"minecraft\", \"version\", \"minecraftversion\"):\n                normalized = \"minecraft\"\n            if normalized in (\"modloader\", \"loader\"):\n                normalized = \"modloader\"\n            if normalized in (\"instance\", \"tag\", \"host\"):\n                normalized += \"s\"  # lazy re-pluralization\n\n            if normalized == \"propertie\":  # lulz\n                # TODO check to make sure properties hasn't been read before\n                # most of this section gets ignored\n                priority = config[section].getint(\"priority\", _DEFAULT_PRIORITY)\n                max_link_depth = config[section].getint(\n                    \"max-link-depth\", _DEFAULT_LINK_DEPTH\n                )\n                # TODO: support specifying filters (and link-folders) in the properties section\n                continue\n            if normalized in match_criteria:\n                raise ValueError(f\"{config_file} specifies {normalized} more than once\")\n\n            if normalized == \"minecraft\":\n                minecraft_versions = []\n                for key, value in config[section].items():\n                    if value is None:\n                        minecraft_versions.append(key)\n                    elif key.lower().strip().startswith(\"version\"):\n                        minecraft_versions.append(value)\n                    else:  # what happens if you specify \"&gt;=1.19\" or \"=1.12\"\n                        minecraft_versions.append(\"=\".join((key, value)))\n                match_criteria[normalized] = tuple(minecraft_versions)\n            elif normalized == \"modloader\":\n                modloaders: set[str] = set()\n                for loader in config[section].keys():\n                    modloaders.update(normalize_modloader(loader))\n                match_criteria[normalized] = tuple(sorted(modloaders))\n            else:\n                # really hoping delimiter shenanigans doesn't show up anywhere else\n                match_criteria[normalized] = tuple(config[section].keys())\n\n        link_folders = match_criteria.pop(\"link-folders\", ())\n        do_not_link = match_criteria.pop(\"do-not-link\", _DEFAULT_DO_NOT_LINK)\n\n        return cls(\n            priority,\n            name,\n            root,\n            tuple(match_criteria.items()),\n            link_folders,\n            max_link_depth=max_link_depth,\n            do_not_link=do_not_link,\n        )\n\n    def write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n        \"\"\"Write this box's configuration to INI\n\n        Parameters\n        ----------\n        config_file : Path, optional\n            The path to the config file, assuming you'd like to write the\n            contents to file\n\n        Returns\n        -------\n        str\n            An INI-syntax rendering of this shulker box's config\n\n        Notes\n        -----\n        The \"root\" attribute is ignored for this method\n        \"\"\"\n        properties: dict[str, Any] = {\"priority\": self.priority}\n        if self.max_link_depth != _DEFAULT_LINK_DEPTH:\n            properties[\"max-link-depth\"] = self.max_link_depth\n\n        config = cfg.dumps(\n            os.path.join(self.name, fs.SHULKER_BOX_CONFIG_NAME),\n            properties,\n            **dict(self.match_criteria),\n            link_folders=self.link_folders,\n            do_not_link=self.do_not_link,\n        )\n\n        if config_file:\n            config_file.write_text(config)\n        return config\n\n    def matches(self, instance: InstanceSpec) -&gt; bool:\n        \"\"\"Determine whether the shulker box matches the given instance\n\n        Parameters\n        ----------\n        instance : InstanceSpec\n            The instance's specification\n\n        Returns\n        -------\n        bool\n            True if the instance matches the shulker box's conditions, False\n            otherwise.\n        \"\"\"\n        for condition, values in self.match_criteria:\n            match condition:  # these should have been normalized on read-in\n                case \"instances\":\n                    for value in values:\n                        if fnmatch.fnmatchcase(instance.name, value):\n                            break\n                    else:\n                        return False\n                case \"tags\":\n                    for value in values:\n                        if value == \"*\":  # in case instance.tags is empty\n                            break\n                        if fnmatch.filter(\n                            [tag.lower() for tag in instance.tags], value.lower()\n                        ):\n                            break\n                    else:\n                        return False\n                case \"modloader\":\n                    for value in values:\n                        if fnmatch.fnmatchcase(\n                            instance.modloader.lower(),\n                            value.lower(),\n                        ):\n                            break\n                    else:\n                        return False\n                case \"minecraft\":\n                    for value in values:\n                        if any(\n                            (\n                                _matches_version(value, version)\n                                for version in instance.minecraft_versions\n                            )\n                        ):\n                            break\n                    else:\n                        return False\n                case \"hosts\":\n                    # this is handled at a higher level\n                    pass\n                case _:\n                    raise NotImplementedError(\n                        f\"Don't know how to apply match condition {condition}.\"\n                    )\n        return True\n\n    def matches_host(self, hostname: str):\n        \"\"\"Determine whether the shulker box should be linked to from the\n        current host machine\n\n        Returns\n        -------\n        bool\n            True if the shulker box's hosts spec matches the host, False otherwise.\n        \"\"\"\n        for condition, values in self.match_criteria:\n            if condition == \"hosts\":\n                if not any(\n                    fnmatch.fnmatchcase(hostname.lower(), host_spec.lower())\n                    for host_spec in values\n                ):\n                    return False\n        return True\n</code></pre>"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.ShulkerBox.from_cfg","title":"<code>from_cfg(config_file)</code>  <code>classmethod</code>","text":"<p>Parse a shulker box from its config file</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path</code> <p>The path to the config file</p> required <p>Returns:</p> Type Description <code>ShulkerBox</code> <p>The resulting ShulkerBox</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the config file at that location cannot be parsed</p> <code>FileNotFoundError</code> <p>If there is no config file at the specified location</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>@classmethod\ndef from_cfg(cls, config_file: Path) -&gt; \"ShulkerBox\":\n    \"\"\"Parse a shulker box from its config file\n\n    Parameters\n    ----------\n    config_file : Path\n        The path to the config file\n\n    Returns\n    -------\n    ShulkerBox\n        The resulting ShulkerBox\n\n    Raises\n    ------\n    ValueError\n        If the config file at that location cannot be parsed\n    FileNotFoundError\n        If there is no config file at the specified location\n    \"\"\"\n    priority = 0\n    max_link_depth = 2\n    root = config_file.parent\n    name = root.name\n    config = cfg.read_cfg(config_file)\n\n    match_criteria: dict[str, tuple[str, ...]] = {}\n\n    for section in config.sections():\n        normalized = (\n            section.lower().replace(\" \", \"\").replace(\"-\", \"\").replace(\"_\", \"\")\n        )\n        if normalized.endswith(\"s\"):\n            normalized = normalized[:-1]  # lazy de-pluralization\n        if normalized in (\"linkfolder\", \"folder\"):\n            normalized = \"link-folders\"\n        if normalized in (\"donotlink\",):\n            normalized = \"do-not-link\"\n        if normalized in (\"minecraft\", \"version\", \"minecraftversion\"):\n            normalized = \"minecraft\"\n        if normalized in (\"modloader\", \"loader\"):\n            normalized = \"modloader\"\n        if normalized in (\"instance\", \"tag\", \"host\"):\n            normalized += \"s\"  # lazy re-pluralization\n\n        if normalized == \"propertie\":  # lulz\n            # TODO check to make sure properties hasn't been read before\n            # most of this section gets ignored\n            priority = config[section].getint(\"priority\", _DEFAULT_PRIORITY)\n            max_link_depth = config[section].getint(\n                \"max-link-depth\", _DEFAULT_LINK_DEPTH\n            )\n            # TODO: support specifying filters (and link-folders) in the properties section\n            continue\n        if normalized in match_criteria:\n            raise ValueError(f\"{config_file} specifies {normalized} more than once\")\n\n        if normalized == \"minecraft\":\n            minecraft_versions = []\n            for key, value in config[section].items():\n                if value is None:\n                    minecraft_versions.append(key)\n                elif key.lower().strip().startswith(\"version\"):\n                    minecraft_versions.append(value)\n                else:  # what happens if you specify \"&gt;=1.19\" or \"=1.12\"\n                    minecraft_versions.append(\"=\".join((key, value)))\n            match_criteria[normalized] = tuple(minecraft_versions)\n        elif normalized == \"modloader\":\n            modloaders: set[str] = set()\n            for loader in config[section].keys():\n                modloaders.update(normalize_modloader(loader))\n            match_criteria[normalized] = tuple(sorted(modloaders))\n        else:\n            # really hoping delimiter shenanigans doesn't show up anywhere else\n            match_criteria[normalized] = tuple(config[section].keys())\n\n    link_folders = match_criteria.pop(\"link-folders\", ())\n    do_not_link = match_criteria.pop(\"do-not-link\", _DEFAULT_DO_NOT_LINK)\n\n    return cls(\n        priority,\n        name,\n        root,\n        tuple(match_criteria.items()),\n        link_folders,\n        max_link_depth=max_link_depth,\n        do_not_link=do_not_link,\n    )\n</code></pre>"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.ShulkerBox.matches","title":"<code>matches(instance)</code>","text":"<p>Determine whether the shulker box matches the given instance</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>InstanceSpec</code> <p>The instance's specification</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the instance matches the shulker box's conditions, False otherwise.</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>def matches(self, instance: InstanceSpec) -&gt; bool:\n    \"\"\"Determine whether the shulker box matches the given instance\n\n    Parameters\n    ----------\n    instance : InstanceSpec\n        The instance's specification\n\n    Returns\n    -------\n    bool\n        True if the instance matches the shulker box's conditions, False\n        otherwise.\n    \"\"\"\n    for condition, values in self.match_criteria:\n        match condition:  # these should have been normalized on read-in\n            case \"instances\":\n                for value in values:\n                    if fnmatch.fnmatchcase(instance.name, value):\n                        break\n                else:\n                    return False\n            case \"tags\":\n                for value in values:\n                    if value == \"*\":  # in case instance.tags is empty\n                        break\n                    if fnmatch.filter(\n                        [tag.lower() for tag in instance.tags], value.lower()\n                    ):\n                        break\n                else:\n                    return False\n            case \"modloader\":\n                for value in values:\n                    if fnmatch.fnmatchcase(\n                        instance.modloader.lower(),\n                        value.lower(),\n                    ):\n                        break\n                else:\n                    return False\n            case \"minecraft\":\n                for value in values:\n                    if any(\n                        (\n                            _matches_version(value, version)\n                            for version in instance.minecraft_versions\n                        )\n                    ):\n                        break\n                else:\n                    return False\n            case \"hosts\":\n                # this is handled at a higher level\n                pass\n            case _:\n                raise NotImplementedError(\n                    f\"Don't know how to apply match condition {condition}.\"\n                )\n    return True\n</code></pre>"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.ShulkerBox.matches_host","title":"<code>matches_host(hostname)</code>","text":"<p>Determine whether the shulker box should be linked to from the current host machine</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the shulker box's hosts spec matches the host, False otherwise.</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>def matches_host(self, hostname: str):\n    \"\"\"Determine whether the shulker box should be linked to from the\n    current host machine\n\n    Returns\n    -------\n    bool\n        True if the shulker box's hosts spec matches the host, False otherwise.\n    \"\"\"\n    for condition, values in self.match_criteria:\n        if condition == \"hosts\":\n            if not any(\n                fnmatch.fnmatchcase(hostname.lower(), host_spec.lower())\n                for host_spec in values\n            ):\n                return False\n    return True\n</code></pre>"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.ShulkerBox.write_to_cfg","title":"<code>write_to_cfg(config_file=None)</code>","text":"<p>Write this box's configuration to INI</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path</code> <p>The path to the config file, assuming you'd like to write the contents to file</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>An INI-syntax rendering of this shulker box's config</p>"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.ShulkerBox.write_to_cfg--notes","title":"Notes","text":"<p>The \"root\" attribute is ignored for this method</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>def write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n    \"\"\"Write this box's configuration to INI\n\n    Parameters\n    ----------\n    config_file : Path, optional\n        The path to the config file, assuming you'd like to write the\n        contents to file\n\n    Returns\n    -------\n    str\n        An INI-syntax rendering of this shulker box's config\n\n    Notes\n    -----\n    The \"root\" attribute is ignored for this method\n    \"\"\"\n    properties: dict[str, Any] = {\"priority\": self.priority}\n    if self.max_link_depth != _DEFAULT_LINK_DEPTH:\n        properties[\"max-link-depth\"] = self.max_link_depth\n\n    config = cfg.dumps(\n        os.path.join(self.name, fs.SHULKER_BOX_CONFIG_NAME),\n        properties,\n        **dict(self.match_criteria),\n        link_folders=self.link_folders,\n        do_not_link=self.do_not_link,\n    )\n\n    if config_file:\n        config_file.write_text(config)\n    return config\n</code></pre>"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.create_shulker_box","title":"<code>create_shulker_box(minecraft_root, shulker_box, folders)</code>","text":"<p>Create a shulker box folder based on the provided configuration</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>shulker_box</code> <code>ShulkerBox</code> <p>The spec of the box to create</p> required <code>folders</code> <code>list-like of str</code> <p>The folders to create inside the shulker box (not including link folders)</p> required"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.create_shulker_box--notes","title":"Notes","text":"<ul> <li>The \"root\" attribute of the ShulkerBox config will be ignored--instead   the shulker box will be created at   /EnderChest/ <li>This method will fail if there is no EnderChest set up in the minecraft   root</li> <li>This method does not check to see if there is already a shulker box   set up at the specified location--if one exists, its config will   be overwritten</li> Source code in <code>enderchest/shulker_box.py</code> <pre><code>def create_shulker_box(\n    minecraft_root: Path, shulker_box: ShulkerBox, folders: Iterable[str]\n) -&gt; None:\n    \"\"\"Create a shulker box folder based on the provided configuration\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    shulker_box : ShulkerBox\n        The spec of the box to create\n    folders : list-like of str\n        The folders to create inside the shulker box (not including link folders)\n\n    Notes\n    -----\n    - The \"root\" attribute of the ShulkerBox config will be ignored--instead\n      the shulker box will be created at\n      &lt;minecraft_root&gt;/EnderChest/&lt;shulker box name&gt;\n    - This method will fail if there is no EnderChest set up in the minecraft\n      root\n    - This method does not check to see if there is already a shulker box\n      set up at the specified location--if one exists, its config will\n      be overwritten\n    \"\"\"\n    root = fs.shulker_box_root(minecraft_root, shulker_box.name)\n    root.mkdir(exist_ok=True)\n\n    for folder in (*folders, *shulker_box.link_folders):\n        CRAFT_LOGGER.debug(f\"Creating {root / folder}\")\n        (root / folder).mkdir(exist_ok=True, parents=True)\n\n    config_path = fs.shulker_box_config(minecraft_root, shulker_box.name)\n    shulker_box.write_to_cfg(config_path)\n    CRAFT_LOGGER.info(f\"Shulker box configuration written to {config_path}\")\n</code></pre>"},{"location":"reference/enderchest/sync/","title":"sync","text":"<p>Low-level functionality for synchronizing across different machines</p>"},{"location":"reference/enderchest/sync/#enderchest.sync.abspath_from_uri","title":"<code>abspath_from_uri(uri)</code>","text":"<p>Extract and unquote the path component of a URI to turn it into an unambiguous absolute <code>pathlib.Path</code></p> <p>h/t https://stackoverflow.com/a/61922504</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>ParseResult</code> <p>The parsed URI to extract the path from</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The path part of the URI as a Path</p> Source code in <code>enderchest/sync/utils.py</code> <pre><code>def abspath_from_uri(uri: ParseResult) -&gt; Path:\n    \"\"\"Extract and unquote the path component of a URI to turn it into an\n    unambiguous absolute `pathlib.Path`\n\n    h/t https://stackoverflow.com/a/61922504\n\n    Parameters\n    ----------\n    uri : ParseResult\n        The parsed URI to extract the path from\n\n    Returns\n    -------\n    Path\n        The path part of the URI as a Path\n    \"\"\"\n    host = \"{0}{0}{mnt}{0}\".format(os.path.sep, mnt=uri.netloc)\n    return Path(os.path.abspath(os.path.join(host, url2pathname(unquote(uri.path)))))\n</code></pre>"},{"location":"reference/enderchest/sync/#enderchest.sync.get_default_netloc","title":"<code>get_default_netloc()</code>","text":"<p>Compile a netloc from environment variables, etc.</p> <p>Returns:</p> Type Description <code>str</code> <p>The default netloc, which is {user}@{hostname}</p> Source code in <code>enderchest/sync/utils.py</code> <pre><code>def get_default_netloc() -&gt; str:\n    \"\"\"Compile a netloc from environment variables, etc.\n\n    Returns\n    -------\n    str\n        The default netloc, which is {user}@{hostname}\n    \"\"\"\n    return f\"{getpass.getuser()}@{socket.gethostname()}\".lower()\n</code></pre>"},{"location":"reference/enderchest/sync/#enderchest.sync.pull","title":"<code>pull(remote_uri, local_path, exclude=None, dry_run=False, **kwargs)</code>","text":"<p>Pull all upstream changes from a remote into the specified location</p> <p>Parameters:</p> Name Type Description Default <code>remote_uri</code> <code>ParseResult</code> <p>The URI for the remote resource to pull</p> required <code>local_path</code> <code>Path</code> <p>The local destination</p> required <code>exclude</code> <code>list of str</code> <p>Any patterns that should be excluded from the sync</p> <code>None</code> <code>dry_run</code> <code>bool</code> <p>Whether to only simulate this sync (report the operations to be performed but not actually perform them). Default is False.</p> <code>False</code> <code>**kwargs</code> <p>Any additional options to pass into the sync command</p> <code>{}</code> Source code in <code>enderchest/sync/__init__.py</code> <pre><code>def pull(\n    remote_uri: ParseResult,\n    local_path: Path,\n    exclude: Collection[str] | None = None,\n    dry_run: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Pull all upstream changes from a remote into the specified location\n\n    Parameters\n    ----------\n    remote_uri : ParseResult\n        The URI for the remote resource to pull\n    local_path : Path\n        The local destination\n    exclude : list of str, optional\n        Any patterns that should be excluded from the sync\n    dry_run : bool, optional\n        Whether to only simulate this sync (report the operations to be performed\n        but not actually perform them). Default is False.\n    **kwargs\n        Any additional options to pass into the sync command\n    \"\"\"\n    try:\n        protocol = importlib.import_module(f\"{__package__}.{remote_uri.scheme.lower()}\")\n        protocol.pull(remote_uri, local_path, exclude or (), dry_run, **kwargs)\n    except ModuleNotFoundError as not_installed:  # pragma: no cover\n        raise NotImplementedError(\n            f\"Protocol {remote_uri.scheme} is not currently implemented\"\n        ) from not_installed\n</code></pre>"},{"location":"reference/enderchest/sync/#enderchest.sync.push","title":"<code>push(local_path, remote_uri, exclude=None, dry_run=False, **kwargs)</code>","text":"<p>Push all local changes in the specified directory into the specified remote</p> <p>Parameters:</p> Name Type Description Default <code>local_path</code> <code>Path</code> <p>The local path to push</p> required <code>remote_uri</code> <code>ParseResult</code> <p>The URI for the remote destination</p> required <code>exclude</code> <code>list of str</code> <p>Any patterns that should be excluded from the sync</p> <code>None</code> <code>dry_run</code> <code>bool</code> <p>Whether to only simulate this sync (report the operations to be performed but not actually perform them). Default is False.</p> <code>False</code> <code>**kwargs</code> <p>Any additional options to pass into the sync command</p> <code>{}</code> Source code in <code>enderchest/sync/__init__.py</code> <pre><code>def push(\n    local_path: Path,\n    remote_uri: ParseResult,\n    exclude: Collection[str] | None = None,\n    dry_run: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Push all local changes in the specified directory into the specified remote\n\n    Parameters\n    ----------\n    local_path\n        The local path to push\n    remote_uri : ParseResult\n        The URI for the remote destination\n    exclude : list of str, optional\n        Any patterns that should be excluded from the sync\n    dry_run : bool, optional\n        Whether to only simulate this sync (report the operations to be performed\n        but not actually perform them). Default is False.\n    **kwargs\n        Any additional options to pass into the sync command\n    \"\"\"\n    try:\n        protocol = importlib.import_module(f\"{__package__}.{remote_uri.scheme.lower()}\")\n        protocol.push(local_path, remote_uri, exclude or (), dry_run, **kwargs)\n    except ModuleNotFoundError as not_installed:\n        raise NotImplementedError(\n            f\"Protocol {remote_uri.scheme} is not currently implemented\"\n        ) from not_installed\n</code></pre>"},{"location":"reference/enderchest/sync/#enderchest.sync.remote_file","title":"<code>remote_file(uri)</code>","text":"<p>Grab a file from a remote filesystem by its URI and read its contents</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>parsed URI</code> <p>The URI of the file to read</p> required <p>Yields:</p> Type Description <code>Path</code> <p>A path to a local (temp) copy of the file</p> Source code in <code>enderchest/sync/__init__.py</code> <pre><code>@contextmanager\ndef remote_file(uri: ParseResult) -&gt; Generator[Path, None, None]:\n    \"\"\"Grab a file from a remote filesystem by its URI and read its contents\n\n    Parameters\n    ----------\n    uri : parsed URI\n        The URI of the file to read\n\n    Yields\n    ------\n    Path\n        A path to a local (temp) copy of the file\n    \"\"\"\n    with TemporaryDirectory(ignore_cleanup_errors=True) as tmpdir:\n        pull(uri, Path(tmpdir), verbosity=-1)\n        yield Path(tmpdir) / Path(uri.path).name\n</code></pre>"},{"location":"reference/enderchest/sync/#enderchest.sync.render_remote","title":"<code>render_remote(alias, uri)</code>","text":"<p>Render a remote to a descriptive string</p> <p>Parameters:</p> Name Type Description Default <code>alias</code> <code>str</code> <p>The name of the remote</p> required <code>uri</code> <code>ParseResult</code> <p>The parsed URI for the remote</p> required <p>Returns:</p> Type Description <code>str</code> <p><code>{uri_string} [({alias})]}</code>     (alias is omitted if it's the same as the URI's hostname)</p> Source code in <code>enderchest/sync/utils.py</code> <pre><code>def render_remote(alias: str, uri: ParseResult) -&gt; str:\n    \"\"\"Render a remote to a descriptive string\n\n    Parameters\n    ----------\n    alias : str\n        The name of the remote\n    uri : ParseResult\n        The parsed URI for the remote\n\n    Returns\n    -------\n    str\n        `{uri_string} [({alias})]}`\n            (alias is omitted if it's the same as the URI's hostname)\n    \"\"\"\n    uri_string = uri.geturl()\n\n    if uri.hostname != alias:\n        uri_string += f\" ({alias})\"\n    return uri_string\n</code></pre>"},{"location":"reference/enderchest/sync/#enderchest.sync.uri_to_ssh","title":"<code>uri_to_ssh(uri)</code>","text":"<p>Convert a URI to an SSH address</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>ParseResult</code> <p>The URI to convert</p> required <p>Returns:</p> Type Description <code>str</code> <p>The SSH-format address</p> Source code in <code>enderchest/sync/utils.py</code> <pre><code>def uri_to_ssh(uri: ParseResult) -&gt; str:\n    \"\"\"Convert a URI to an SSH address\n\n    Parameters\n    ----------\n    uri: ParseResult\n        The URI to convert\n\n    Returns\n    -------\n    str\n        The SSH-format address\n    \"\"\"\n    return \"{user}{host}:{path}\".format(\n        user=f\"{uri.username}@\" if uri.username else \"\",\n        host=(uri.hostname or \"localhost\") + (f\":{uri.port}\" if uri.port else \"\"),\n        path=uri.path,\n    )\n</code></pre>"},{"location":"reference/enderchest/sync/file/","title":"file","text":"<p>shutil-based sync implementation</p>"},{"location":"reference/enderchest/sync/file/#enderchest.sync.file.clean","title":"<code>clean(root, ignore, dry_run)</code>","text":"<p>Recursively remove all files and symlinks from the root path while respecting the provided ignore pattern</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Path</code> <p>The root directory. And this should absolutely be a directory.</p> required <code>ignore</code> <code>Callable</code> <p>The ignore pattern created by <code>ignore_pattern</code> that specifies which files to ignore.</p> required <code>dry_run</code> <code>bool</code> <p>Whether to only simulate this sync (report the operations to be performed but not actually perform them)</p> required Source code in <code>enderchest/sync/file.py</code> <pre><code>def clean(\n    root: Path,\n    ignore: Callable[[str, Collection[str]], set[str]],\n    dry_run: bool,\n) -&gt; None:\n    \"\"\"Recursively remove all files and symlinks from the root path while\n    respecting the provided ignore pattern\n\n    Parameters\n    ----------\n    root : Path\n        The root directory. And this should absolutely be a directory.\n    ignore : Callable\n        The ignore pattern created by `ignore_pattern` that specifies\n        which files to ignore.\n    dry_run : bool\n        Whether to only simulate this sync (report the operations to be performed\n        but not actually perform them)\n    \"\"\"\n    log_level = logging.INFO if dry_run else logging.DEBUG\n    contents = list(root.iterdir())\n    ignore_me = ignore(\n        os.fspath(root),\n        [path.name for path in contents],\n    )\n\n    for path in contents:\n        if path.name in ignore_me:\n            SYNC_LOGGER.debug(f\"Skipping {path}\")\n            continue\n        if path.is_symlink():\n            SYNC_LOGGER.log(log_level, f\"Removing symlink {path}\")\n            if not dry_run:\n                path.unlink()\n        elif path.is_dir():\n            clean(path, ignore, dry_run)\n        else:\n            SYNC_LOGGER.log(log_level, f\"Deleting {path}\")\n            if not dry_run:\n                path.unlink()\n\n    # check if folder is now empty\n    if not list(root.iterdir()):\n        SYNC_LOGGER.log(log_level, f\"Removing empty {root}\")\n        if not dry_run:\n            root.rmdir()\n</code></pre>"},{"location":"reference/enderchest/sync/file/#enderchest.sync.file.copy","title":"<code>copy(source_path, destination_folder, exclude, delete, dry_run)</code>","text":"<p>Copy the specified source file or folder to the provided destination, overwriting any existing files and deleting any that weren't in the source</p> <p>Parameters:</p> Name Type Description Default <code>source_path</code> <code>ParseResult</code> <p>The file or folder to copy</p> required <code>destination_folder</code> <code>Path</code> <p>The destination to put the source file(s)</p> required <code>exclude</code> <code>list of str</code> <p>Any patterns that should be excluded from the sync (and sync)</p> required <code>delete</code> <code>bool</code> <p>Whether part of the syncing should include deleting files at the destination that aren't at the source.</p> required <code>dry_run</code> <code>bool</code> <p>Whether to only simulate this sync (report the operations to be performed but not actually perform them)</p> required"},{"location":"reference/enderchest/sync/file/#enderchest.sync.file.copy--notes","title":"Notes","text":"<p>If the source file does not exist, the destination file will simply be deleted (if it exists)</p> Source code in <code>enderchest/sync/file.py</code> <pre><code>def copy(\n    source_path: Path,\n    destination_folder: Path,\n    exclude: Collection[str],\n    delete: bool,\n    dry_run: bool,\n) -&gt; None:\n    \"\"\"Copy the specified source file or folder to the provided destination,\n    overwriting any existing files and deleting any that weren't in the source\n\n    Parameters\n    ----------\n    source_path : ParseResult\n        The file or folder to copy\n    destination_folder : Path\n        The destination to put the source file(s)\n    exclude : list of str\n        Any patterns that should be excluded from the sync (and sync)\n    delete : bool\n        Whether part of the syncing should include deleting files at the destination\n        that aren't at the source.\n    dry_run : bool\n        Whether to only simulate this sync (report the operations to be performed\n        but not actually perform them)\n\n    Notes\n    -----\n    If the source file does not exist, the destination file will simply be deleted\n    (if it exists)\n    \"\"\"\n\n    ignore = ignore_patterns(*exclude)\n    SYNC_LOGGER.debug(f\"Ignoring patterns: {exclude}\")\n\n    destination_path = destination_folder / source_path.name\n    if destination_path.is_symlink() and not destination_path.is_dir():\n        SYNC_LOGGER.warning(\"Removing symlink %s\", destination_path)\n        if not dry_run:\n            destination_path.unlink()\n        else:\n            SYNC_LOGGER.debug(\"And replacing it entirely with %s\", source_path)\n            return\n    elif destination_path.exists() and not destination_path.is_dir():\n        SYNC_LOGGER.warning(\"Deleting file %s\", destination_path)\n        if not dry_run:\n            destination_path.unlink()\n        else:\n            SYNC_LOGGER.debug(\"And replacing it entirely with %s\", source_path)\n            return\n    else:\n        if not dry_run:\n            destination_folder.mkdir(parents=True, exist_ok=True)\n\n    SYNC_LOGGER.debug(f\"Copying {source_path} into {destination_folder}\")\n\n    if source_path.exists() and not source_path.is_dir():\n        if destination_path.exists() and is_identical(\n            source_path.stat(), destination_path.stat()\n        ):\n            SYNC_LOGGER.warning(\n                \"%s and %s are identical. No copy needed.\",\n                source_path,\n                destination_path,\n            )\n            return\n        SYNC_LOGGER.debug(\n            \"Copying file %s to %s\",\n            source_path,\n            destination_path,\n        )\n        if not dry_run:\n            shutil.copy2(source_path, destination_path, follow_symlinks=False)\n        return\n\n    source_contents = filter_contents(\n        get_contents(source_path), exclude, prefix=source_path\n    )\n    destination_contents = filter_contents(\n        get_contents(destination_path), exclude, prefix=destination_path\n    )\n\n    sync_diff = diff(source_contents, destination_contents)\n\n    if dry_run:\n        generate_sync_report(sync_diff)\n        return\n\n    for path, path_stat, operation in sync_diff:\n        match (operation, stat.S_ISDIR(path_stat.st_mode or 0)):\n            case (Op.CREATE, True):\n                SYNC_LOGGER.debug(\"Creating directory %s\", destination_path / path)\n                (destination_path / path).mkdir(parents=True, exist_ok=True)\n            case (Op.CREATE, False) | (Op.REPLACE, False):\n                SYNC_LOGGER.debug(\n                    \"Copying file %s to %s\",\n                    source_path / path,\n                    destination_path / path,\n                )\n                (destination_path / path).unlink(missing_ok=True)\n                if (source_path / path).is_symlink():\n                    (destination_path / path).symlink_to(\n                        (source_path / path).readlink()\n                    )\n                else:\n                    shutil.copy2(\n                        source_path / path,\n                        destination_path / path,\n                        follow_symlinks=False,\n                    )\n            case (Op.REPLACE, True):\n                # this would be replacing a file with a directory\n                SYNC_LOGGER.debug(\"Deleting file %s\", destination_path / path)\n                (destination_path / path).unlink()\n                SYNC_LOGGER.debug(\n                    \"Copying directory %s to %s\",\n                    source_path / path,\n                    destination_path / path,\n                )\n                shutil.copytree(\n                    source_path / path,\n                    destination_path / path,\n                    symlinks=True,\n                    ignore=ignore,\n                    dirs_exist_ok=True,\n                )\n            case (Op.DELETE, True):\n                # recall that for deletions, it's the *destination's* stats\n                if delete:\n                    clean(destination_path / path, ignore, dry_run)\n            case (Op.DELETE, False):\n                if delete:\n                    SYNC_LOGGER.debug(\"Deleting file %s\", destination_path / path)\n                    (destination_path / path).unlink()\n            case op, is_dir:  # pragma: no cover\n                raise NotImplementedError(\n                    f\"Don't know how to handle {op} of {'directory' if is_dir else 'file'}\"\n                )\n</code></pre>"},{"location":"reference/enderchest/sync/file/#enderchest.sync.file.get_contents","title":"<code>get_contents(path)</code>","text":"<p>Recursively list the contents of a local directory</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to scan</p> required <p>Returns:</p> Type Description <code>list of filenames and attributes</code> <p>The attributes of all files, folders and symlinks found under the specified path</p>"},{"location":"reference/enderchest/sync/file/#enderchest.sync.file.get_contents--notes","title":"Notes","text":"<ul> <li>This list will be sorted from shortest path to longest (so that parent   directories come before their children)</li> <li>The paths returned are all relative to the provided path</li> </ul> Source code in <code>enderchest/sync/file.py</code> <pre><code>def get_contents(path: Path) -&gt; list[tuple[Path, os.stat_result]]:\n    \"\"\"Recursively list the contents of a local directory\n\n    Parameters\n    ----------\n    path : Path\n        The path to scan\n\n    Returns\n    -------\n    list of filenames and attributes\n        The attributes of all files, folders and symlinks found under the\n        specified path\n\n    Notes\n    -----\n    - This list will be sorted from shortest path to longest (so that parent\n      directories come before their children)\n    - The paths returned are all relative to the provided path\n    \"\"\"\n    SYNC_LOGGER.debug(f\"Getting contents of {path}\")\n    return sorted(\n        ((p.relative_to(path), p.lstat()) for p in path.rglob(\"**/*\")),\n        key=lambda x: len(str(x[0])),\n    )\n</code></pre>"},{"location":"reference/enderchest/sync/file/#enderchest.sync.file.ignore_patterns","title":"<code>ignore_patterns(*patterns)</code>","text":"<p>shutil.ignore_patterns doesn't support checking absolute paths, so we gotta roll our own.</p> <p>This implementation is adapted from https://github.com/python/cpython/blob/3.11/Lib/shutil.py#L440-L450 and https://stackoverflow.com/a/7842224</p> <p>Parameters:</p> Name Type Description Default <code>*patterns</code> <code>str</code> <p>The patterns to match</p> <code>()</code> <p>Returns:</p> Type Description <code>Callable</code> <p>An \"ignore\" filter suitable for use in <code>shutil.copytree</code></p> Source code in <code>enderchest/sync/file.py</code> <pre><code>def ignore_patterns(*patterns: str) -&gt; Callable[[str, Collection[str]], set[str]]:\n    \"\"\"shutil.ignore_patterns doesn't support checking absolute paths,\n    so we gotta roll our own.\n\n    This implementation is adapted from\n    https://github.com/python/cpython/blob/3.11/Lib/shutil.py#L440-L450 and\n    https://stackoverflow.com/a/7842224\n\n    Parameters\n    ----------\n    *patterns : str\n        The patterns to match\n\n    Returns\n    -------\n    Callable\n        An \"ignore\" filter suitable for use in `shutil.copytree`\n    \"\"\"\n\n    def _ignore_patterns(path: str, names: Collection[str]) -&gt; set[str]:\n        ignored_names: set[str] = set()\n        for pattern in patterns:\n            path_parts: list[str] = os.path.normpath(path).split(os.sep)\n            pattern_depth = len(os.path.normpath(pattern).split(os.sep)) - 1\n            if pattern_depth == 0:\n                match_paths: Collection[str] = names\n            else:\n                match_paths = [\n                    os.path.join(*path_parts[-pattern_depth:], name) for name in names\n                ]\n            ignored_names.update(\n                os.path.split(match)[-1]\n                for match in fnmatch.filter(match_paths, pattern)\n            )\n        return ignored_names\n\n    return _ignore_patterns\n</code></pre>"},{"location":"reference/enderchest/sync/file/#enderchest.sync.file.pull","title":"<code>pull(remote_uri, local_path, exclude, dry_run, delete=True, **unsupported_kwargs)</code>","text":"<p>Copy an upstream file or folder into the specified location, where the remote is another folder on this machine. This will overwrite any files and folders already at the destination.</p> <p>Parameters:</p> Name Type Description Default <code>remote_uri</code> <code>ParseResult</code> <p>The URI for the remote resource to copy from. See notes.</p> required <code>local_path</code> <code>Path</code> <p>The destination folder</p> required <code>exclude</code> <code>list of str</code> <p>Any patterns that should be excluded from the sync</p> required <code>dry_run</code> <code>bool</code> <p>Whether to only simulate this sync (report the operations to be performed but not actually perform them)</p> required <code>delete</code> <code>bool</code> <p>Whether part of the syncing should include deleting files at the destination that aren't at the source. Default is True.</p> <code>True</code> <code>**unsupported_kwargs</code> <p>Any other provided options will be ignored</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the destination folder does not exist</p>"},{"location":"reference/enderchest/sync/file/#enderchest.sync.file.pull--notes","title":"Notes","text":"<ul> <li>This method is only meant to be used for local files specified using   the file:// protocol, but it does not perform any validation on the URI to   ensure that the schema is correct or that the hostname corresponds to this   machine. This method does not support user authentication   (running the copy as a different user).</li> <li>If the destination folder does not already exist, this method will not   create it or its parent directories.</li> </ul> Source code in <code>enderchest/sync/file.py</code> <pre><code>def pull(\n    remote_uri: ParseResult,\n    local_path: Path,\n    exclude: Collection[str],\n    dry_run: bool,\n    delete: bool = True,\n    **unsupported_kwargs,\n) -&gt; None:\n    \"\"\"Copy an upstream file or folder into the specified location, where the remote\n    is another folder on this machine. This will overwrite any files and folders\n    already at the destination.\n\n    Parameters\n    ----------\n    remote_uri : ParseResult\n        The URI for the remote resource to copy from. See notes.\n    local_path : Path\n        The destination folder\n    exclude : list of str\n        Any patterns that should be excluded from the sync\n    dry_run : bool\n        Whether to only simulate this sync (report the operations to be performed\n        but not actually perform them)\n    delete : bool, optional\n        Whether part of the syncing should include deleting files at the destination\n        that aren't at the source. Default is True.\n    **unsupported_kwargs\n        Any other provided options will be ignored\n\n    Raises\n    ------\n    FileNotFoundError\n        If the destination folder does not exist\n\n    Notes\n    -----\n    - This method is only meant to be used for local files specified using\n      the file:// protocol, but it does not perform any validation on the URI to\n      ensure that the schema is correct or that the hostname corresponds to this\n      machine. This method does not support user authentication\n      (running the copy as a different user).\n    - If the destination folder does not already exist, this method will not\n      create it or its parent directories.\n    \"\"\"\n    source_path = abspath_from_uri(remote_uri).expanduser()\n    destination_folder = local_path\n\n    if not destination_folder.exists():\n        raise FileNotFoundError(f\"{local_path} does not exist\")\n    if not source_path.exists():\n        raise FileNotFoundError(f\"{remote_uri.geturl()} does not exist\")\n    if unsupported_kwargs:\n        SYNC_LOGGER.debug(\n            \"The following command-line options are ignored for this protocol:\\n%s\",\n            \"\\n\".join(\"  {}: {}\".format(*item) for item in unsupported_kwargs.items()),\n        )\n\n    copy(source_path, destination_folder, exclude, delete=delete, dry_run=dry_run)\n</code></pre>"},{"location":"reference/enderchest/sync/file/#enderchest.sync.file.push","title":"<code>push(local_path, remote_uri, exclude, dry_run, delete=True, **unsupported_kwargs)</code>","text":"<p>Copy a local file or folder into the specified location, where the remote is another folder on this machine. This will overwrite any files and folders already at the destination.</p> <p>Parameters:</p> Name Type Description Default <code>local_path</code> <code>Path</code> <p>The file or folder to copy</p> required <code>remote_uri</code> <code>ParseResult</code> <p>The URI for the remote location to copy into. See notes.</p> required <code>exclude</code> <code>list of str</code> <p>Any patterns that should be excluded from the sync</p> required <code>dry_run</code> <code>bool</code> <p>Whether to only simulate this sync (report the operations to be performed but not actually perform them)</p> required <code>delete</code> <code>bool</code> <p>Whether part of the syncing should include deleting files at the destination that aren't at the source. Default is True.</p> <code>True</code> <code>**unsupported_kwargs</code> <p>Any other provided options will be ignored</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the destination folder does not exist</p>"},{"location":"reference/enderchest/sync/file/#enderchest.sync.file.push--notes","title":"Notes","text":"<ul> <li>This method is only meant to be used for local files specified using   the file:// protocol, but it does not perform any validation on the URI to   ensure that the schema is correct or that the hostname corresponds to this   machine. This method does not support user authentication   (running the copy as a different user).</li> <li>If the destination folder does not already exist, this method will not   create it or its parent directories.</li> </ul> Source code in <code>enderchest/sync/file.py</code> <pre><code>def push(\n    local_path: Path,\n    remote_uri: ParseResult,\n    exclude: Collection[str],\n    dry_run: bool,\n    delete: bool = True,\n    **unsupported_kwargs,\n) -&gt; None:\n    \"\"\"Copy a local file or folder into the specified location, where the remote\n    is another folder on this machine. This will overwrite any files and folders\n    already at the destination.\n\n    Parameters\n    ----------\n    local_path : Path\n        The file or folder to copy\n    remote_uri : ParseResult\n        The URI for the remote location to copy into. See notes.\n    exclude : list of str\n        Any patterns that should be excluded from the sync\n    dry_run : bool\n        Whether to only simulate this sync (report the operations to be performed\n        but not actually perform them)\n    delete : bool, optional\n        Whether part of the syncing should include deleting files at the destination\n        that aren't at the source. Default is True.\n    **unsupported_kwargs\n        Any other provided options will be ignored\n\n    Raises\n    ------\n    FileNotFoundError\n        If the destination folder does not exist\n\n    Notes\n    -----\n    - This method is only meant to be used for local files specified using\n      the file:// protocol, but it does not perform any validation on the URI to\n      ensure that the schema is correct or that the hostname corresponds to this\n      machine. This method does not support user authentication\n      (running the copy as a different user).\n    - If the destination folder does not already exist, this method will not\n      create it or its parent directories.\n    \"\"\"\n    source_path = local_path\n    destination_folder = abspath_from_uri(remote_uri).expanduser()\n\n    if not destination_folder.exists():\n        raise FileNotFoundError(f\"{remote_uri.geturl()} does not exist\")\n    if not source_path.exists():\n        raise FileNotFoundError(f\"{source_path} does not exist\")\n    if unsupported_kwargs:\n        SYNC_LOGGER.debug(\n            \"The following command-line options are ignored for this protocol:\\n%s\",\n            \"\\n\".join(\"  {}: {}\".format(*item) for item in unsupported_kwargs.items()),\n        )\n\n    copy(source_path, destination_folder, exclude, delete=delete, dry_run=dry_run)\n</code></pre>"},{"location":"reference/enderchest/sync/rsync/","title":"rsync","text":"<p>rsync sync implementation. Relies on the user having rsync installed on their system</p>"},{"location":"reference/enderchest/sync/rsync/#enderchest.sync.rsync.pull","title":"<code>pull(remote_uri, local_path, exclude, dry_run, use_daemon=False, timeout=None, delete=True, verbosity=0, rsync_args=None)</code>","text":"<p>Sync an upstream file or folder into the specified location using rsync. This will overwrite any files and folders already at the destination.</p> <p>Parameters:</p> Name Type Description Default <code>remote_uri</code> <code>ParseResult</code> <p>The URI for the remote resource to copy from</p> required <code>local_path</code> <code>Path</code> <p>The destination folder</p> required <code>exclude</code> <code>list of str</code> <p>Any patterns that should be excluded from the sync</p> required <code>dry_run</code> <code>bool</code> <p>Whether to only simulate this sync (report the operations to be performed but not actually perform them)</p> required <code>use_daemon</code> <code>bool</code> <p>By default, the rsync is performed over ssh. If you happen to have an rsync daemon running on your system, however, you're welcome to leverage it instead by passing in <code>use_daemon=True</code></p> <code>False</code> <code>timeout</code> <code>int</code> <p>The number of seconds to wait before timing out the sync operation. If None is provided, no explicit timeout value will be set.</p> <code>None</code> <code>delete</code> <code>bool</code> <p>Whether part of the syncing should include deleting files at the destination that aren't at the source. Default is True.</p> <code>True</code> <code>verbosity</code> <code>int</code> <p>A modifier for how much info to output either to stdout or the INFO-level logs. Defaults to 0.</p> <code>0</code> <code>rsync_args</code> <code>Iterable[str] | None</code> <p>Any additional arguments to pass into rsync. Note that rsync is run by default with the flags: <code>-shaz</code></p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the destination folder does not exist</p>"},{"location":"reference/enderchest/sync/rsync/#enderchest.sync.rsync.pull--notes","title":"Notes","text":"<ul> <li>This method does not provide for interactive authentication. If using   rsync over SSH, you'll need to be set up for password-less (key-based)   access.</li> <li>If the destination folder does not already exist, this method will not   create it or its parent directories.</li> </ul> Source code in <code>enderchest/sync/rsync.py</code> <pre><code>def pull(\n    remote_uri: ParseResult,\n    local_path: Path,\n    exclude: Iterable[str],\n    dry_run: bool,\n    use_daemon: bool = False,\n    timeout: int | None = None,\n    delete: bool = True,\n    verbosity: int = 0,\n    rsync_args: Iterable[str] | None = None,\n) -&gt; None:\n    \"\"\"Sync an upstream file or folder into the specified location using rsync.\n    This will overwrite any files and folders already at the destination.\n\n    Parameters\n    ----------\n    remote_uri : ParseResult\n        The URI for the remote resource to copy from\n    local_path : Path\n        The destination folder\n    exclude : list of str\n        Any patterns that should be excluded from the sync\n    dry_run : bool\n        Whether to only simulate this sync (report the operations to be performed\n        but not actually perform them)\n    use_daemon : bool, optional\n        By default, the rsync is performed over ssh. If you happen to have an\n        rsync daemon running on your system, however, you're welcome to leverage\n        it instead by passing in `use_daemon=True`\n    timeout : int, optional\n        The number of seconds to wait before timing out the sync operation.\n        If None is provided, no explicit timeout value will be set.\n    delete : bool, optional\n        Whether part of the syncing should include deleting files at the destination\n        that aren't at the source. Default is True.\n    verbosity : int\n        A modifier for how much info to output either to stdout or the INFO-level\n        logs. Defaults to 0.\n    rsync_args: list of str, optional\n        Any additional arguments to pass into rsync. Note that rsync is run by\n        default with the flags: `-shaz`\n\n    Raises\n    ------\n    FileNotFoundError\n        If the destination folder does not exist\n\n    Notes\n    -----\n    - This method does not provide for interactive authentication. If using\n      rsync over SSH, you'll need to be set up for password-less (key-based)\n      access.\n    - If the destination folder does not already exist, this method will not\n      create it or its parent directories.\n    \"\"\"\n    if not local_path.exists():\n        raise FileNotFoundError(f\"{local_path} does not exist\")\n\n    if remote_uri.netloc == get_default_netloc():\n        SYNC_LOGGER.debug(\"Performing sync as a local transfer\")\n        remote_path: str = unquote(remote_uri.path)\n    elif use_daemon:\n        remote_path = remote_uri.geturl()\n    else:\n        remote_path = uri_to_ssh(remote_uri)\n\n    if rsync_args:  # pragma: no cover\n        raise NotImplementedError\n\n    run_rsync(\n        local_path.parent,\n        remote_path,\n        local_path.name,\n        delete,\n        dry_run,\n        exclude,\n        *(rsync_args or ()),\n        timeout=timeout,\n        verbosity=verbosity,\n    )\n</code></pre>"},{"location":"reference/enderchest/sync/rsync/#enderchest.sync.rsync.push","title":"<code>push(local_path, remote_uri, exclude, dry_run, use_daemon=False, timeout=None, delete=True, verbosity=0, rsync_args=None)</code>","text":"<p>Sync a local file or folder into the specified location using rsync. This will overwrite any files and folders already at the destination.</p> <p>Parameters:</p> Name Type Description Default <code>local_path</code> <code>Path</code> <p>The file or folder to copy</p> required <code>remote_uri</code> <code>ParseResult</code> <p>The URI for the remote location to copy into</p> required <code>exclude</code> <code>list of str</code> <p>Any patterns that should be excluded from the sync</p> required <code>dry_run</code> <code>bool</code> <p>Whether to only simulate this sync (report the operations to be performed but not actually perform them)</p> required <code>use_daemon</code> <code>bool</code> <p>By default, the rsync is performed over ssh. If you happen to have an rsync daemon running on your system, however, you're welcome to leverage it instead by passing in <code>use_daemon=True</code></p> <code>False</code> <code>timeout</code> <code>int</code> <p>The number of seconds to wait before timing out the sync operation. If None is provided, no explicit timeout value will be set.</p> <code>None</code> <code>delete</code> <code>bool</code> <p>Whether part of the syncing should include deleting files at the destination that aren't at the source. Default is True.</p> <code>True</code> <code>verbosity</code> <code>int</code> <p>A modifier for how much info to output either to stdout or the INFO-level logs. Defaults to 0.</p> <code>0</code> <code>rsync_args</code> <code>Iterable[str] | None</code> <p>Any additional arguments to pass into rsync. Note that rsync is run by default with the flags: <code>-shaz</code></p> <code>None</code>"},{"location":"reference/enderchest/sync/rsync/#enderchest.sync.rsync.push--notes","title":"Notes","text":"<ul> <li>This method does not provide for interactive authentication. If using   rsync over SSH, you'll need to be set up for password-less (key-based)   access.</li> <li>If the destination folder does not already exist, this method will very   likely fail.</li> </ul> Source code in <code>enderchest/sync/rsync.py</code> <pre><code>def push(\n    local_path: Path,\n    remote_uri: ParseResult,\n    exclude: Iterable[str],\n    dry_run: bool,\n    use_daemon: bool = False,\n    timeout: int | None = None,\n    delete: bool = True,\n    verbosity: int = 0,\n    rsync_args: Iterable[str] | None = None,\n) -&gt; None:\n    \"\"\"Sync a local file or folder into the specified location using rsync.\n    This will overwrite any files and folders already at the destination.\n\n    Parameters\n    ----------\n    local_path : Path\n        The file or folder to copy\n    remote_uri : ParseResult\n        The URI for the remote location to copy into\n    exclude : list of str\n        Any patterns that should be excluded from the sync\n    dry_run : bool\n        Whether to only simulate this sync (report the operations to be performed\n        but not actually perform them)\n    use_daemon : bool, optional\n        By default, the rsync is performed over ssh. If you happen to have an\n        rsync daemon running on your system, however, you're welcome to leverage\n        it instead by passing in `use_daemon=True`\n    timeout : int, optional\n        The number of seconds to wait before timing out the sync operation.\n        If None is provided, no explicit timeout value will be set.\n    delete : bool, optional\n        Whether part of the syncing should include deleting files at the destination\n        that aren't at the source. Default is True.\n    verbosity : int\n        A modifier for how much info to output either to stdout or the INFO-level\n        logs. Defaults to 0.\n    rsync_args: list of str, optional\n        Any additional arguments to pass into rsync. Note that rsync is run by\n        default with the flags: `-shaz`\n\n    Notes\n    -----\n    - This method does not provide for interactive authentication. If using\n      rsync over SSH, you'll need to be set up for password-less (key-based)\n      access.\n    - If the destination folder does not already exist, this method will very\n      likely fail.\n    \"\"\"\n    if remote_uri.netloc == get_default_netloc():\n        SYNC_LOGGER.debug(\"Performing sync as a local transfer\")\n        remote_path: str = unquote(remote_uri.path)\n    elif use_daemon:\n        remote_path = remote_uri.geturl()\n    else:\n        remote_path = uri_to_ssh(remote_uri)\n\n    if rsync_args:  # pragma: no cover\n        raise NotImplementedError\n\n    run_rsync(\n        local_path.parent,\n        local_path.name,\n        remote_path,\n        delete,\n        dry_run,\n        exclude,\n        *(rsync_args or ()),\n        timeout=timeout,\n        verbosity=verbosity,\n    )\n</code></pre>"},{"location":"reference/enderchest/sync/rsync/#enderchest.sync.rsync.run_rsync","title":"<code>run_rsync(working_directory, source, destination_folder, delete, dry_run, exclude, *additional_args, timeout=None, verbosity=0, rsync_flags=None)</code>","text":"<p>Run an operation with rsync</p> <p>Parameters:</p> Name Type Description Default <code>working_directory</code> <code>Path</code> <p>The working directory to run the sync command from</p> required <code>source</code> <code>str</code> <p>The source file or folder to sync, specified as either a URI string, an ssh address or a path relative to the working directory</p> required <code>destination_folder</code> <code>str</code> <p>The destination folder where the file or folder should be synced to, with the same formats available as for source</p> required <code>delete</code> <code>bool</code> <p>Whether part of the syncing should include deleting files at the destination that aren't at the source</p> required <code>dry_run</code> <code>bool</code> <p>Whether to only simulate this sync (report the operations to be performed but not actually perform them)</p> required <code>exclude</code> <code>list of str</code> <p>Any patterns that should be excluded from the sync (and sync)</p> required <code>*additional_args</code> <code>str</code> <p>Any additional arguments to pass into the rsync command</p> <code>()</code> <code>timeout</code> <code>int</code> <p>The number of seconds to wait before timing out the sync operation. If None is provided, no explicit timeout value will be set.</p> <code>None</code> <code>verbosity</code> <code>int</code> <p>A modifier for how much info to output either to stdout or the INFO-level logs. At...</p> <ul> <li>verbosity = -2 : No information will be printed, even on dry runs</li> <li>verbosity = -1 : The sync itself will be silent. Dry runs will only                      report the sync statistics.</li> <li>verbosity =  0 : Actual syncs will display a progress bar. Dry run                      reports will summarize the changes to each shulker                      box in addition to reporting the sync statistics .</li> <li>verbosity =  1 : Actual syncs will report the progress of each file                      transfer. Dry runs will report on each file to                      be created, updated or deleted.</li> <li>verbosity =  2 : Dry runs and syncs will print or log the output                      of rsync run using the <code>-vv</code> modifier</li> </ul> <p>Verbosity values outside of this range will simply be capped / floored to [-2, 2].</p> <code>0</code> <code>rsync_flags</code> <code>str</code> <p>By default, rsync will be run using the flags \"shaz\" which means:</p> <ul> <li>no space splitting</li> <li>use output (file sizes, mostly) human-readable</li> <li>archive mode (see: https://www.baeldung.com/linux/rsync-archive-mode)</li> <li>compress data during transfer</li> </ul> <p>Advanced users may choose to override these options, but you do so at your own peril.</p> <code>None</code> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the rsync operation times out before completion</p> <code>RuntimeError</code> <p>If the rsync operation fails for any other reason</p>"},{"location":"reference/enderchest/sync/rsync/#enderchest.sync.rsync.run_rsync--notes","title":"Notes","text":"<p>This method does not perform any validation or normalization of the source, destination, exclude-list, additional arguments or rsync options.</p> Source code in <code>enderchest/sync/rsync.py</code> <pre><code>def run_rsync(\n    working_directory: Path,\n    source: str,\n    destination_folder: str,\n    delete: bool,\n    dry_run: bool,\n    exclude: Iterable[str],\n    *additional_args: str,\n    timeout: int | None = None,\n    verbosity: int = 0,\n    rsync_flags: str | None = None,\n) -&gt; None:\n    \"\"\"Run an operation with rsync\n\n    Parameters\n    ----------\n    working_directory : Path\n        The working directory to run the sync command from\n    source : str\n        The source file or folder to sync, specified as either a URI string,\n        an ssh address or a path relative to the working directory\n    destination_folder : str\n        The destination folder where the file or folder should be synced to,\n        with the same formats available as for source\n    delete : bool\n        Whether part of the syncing should include deleting files at the destination\n        that aren't at the source\n    dry_run : bool\n        Whether to only simulate this sync (report the operations to be performed\n        but not actually perform them)\n    exclude : list of str\n        Any patterns that should be excluded from the sync (and sync)\n    *additional_args : str\n        Any additional arguments to pass into the rsync command\n    timeout : int, optional\n        The number of seconds to wait before timing out the sync operation.\n        If None is provided, no explicit timeout value will be set.\n    verbosity : int\n        A modifier for how much info to output either to stdout or the INFO-level\n        logs. At...\n\n          - verbosity = -2 : No information will be printed, even on dry runs\n          - verbosity = -1 : The sync itself will be silent. Dry runs will only\n                             report the sync statistics.\n          - verbosity =  0 : Actual syncs will display a progress bar. Dry run\n                             reports will summarize the changes to each shulker\n                             box in addition to reporting the sync statistics .\n          - verbosity =  1 : Actual syncs will report the progress of each file\n                             transfer. Dry runs will report on each file to\n                             be created, updated or deleted.\n          - verbosity =  2 : Dry runs and syncs will print or log the output\n                             of rsync run using the `-vv` modifier\n\n        Verbosity values outside of this range will simply be capped / floored\n        to [-2, 2].\n    rsync_flags : str, optional\n        By default, rsync will be run using the flags \"shaz\" which means:\n\n          - no space splitting\n          - use output (file sizes, mostly) human-readable\n          - archive mode (see: https://www.baeldung.com/linux/rsync-archive-mode)\n          - compress data during transfer\n\n        Advanced users may choose to override these options, but **you do so\n        at your own peril**.\n\n    Raises\n    ------\n    TimeoutError\n        If the rsync operation times out before completion\n    RuntimeError\n        If the rsync operation fails for any other reason\n\n    Notes\n    -----\n    This method does not perform any validation or normalization of the source,\n    destination, exclude-list, additional arguments or rsync options.\n    \"\"\"\n    rsync_flags = rsync_flags or \"shaz\"\n\n    args: list[str] = [RSYNC, f\"-{rsync_flags}\"]  # type: ignore[list-item]\n    if delete:\n        args.append(\"--delete\")\n    if dry_run:\n        args.extend((\"--dry-run\", \"--stats\"))\n        if verbosity &lt; 1:\n            # at 1+ we don't need it to be machine-parseable\n            args.append(\"--out-format=%i %n\")\n    else:\n        if verbosity &gt;= 0:\n            args.append(\"--stats\")\n        if verbosity == 0:\n            args.append(\"--info=progress2\")\n        if verbosity &gt;= 1:\n            args.append(\"--progress\")\n    if verbosity &gt; 0:\n        args.append(\"-\" + \"v\" * verbosity)\n\n    for pattern in exclude:\n        args.extend((\"--exclude\", pattern))\n    args.extend(additional_args)\n    args.extend((source, destination_folder))\n\n    SYNC_LOGGER.debug(\n        \"Executing the following command:\\n %s\",\n        \" \".join(args),\n    )\n\n    with subprocess.Popen(\n        args,\n        stdout=subprocess.PIPE if dry_run else None,\n        stderr=subprocess.PIPE,\n        cwd=working_directory,\n    ) as proc:\n        if timeout:\n            try:\n                proc.wait(timeout)\n            except subprocess.TimeoutExpired as times_up:\n                proc.kill()\n                if proc.stdout is not None:\n                    if output_log := proc.stdout.read().decode(\"UTF-8\"):\n                        SYNC_LOGGER.warning(output_log)\n                if proc.stderr is not None:\n                    if error_log := proc.stderr.read().decode(\"UTF-8\"):\n                        SYNC_LOGGER.error(error_log)\n                raise TimeoutError(\"Timeout reached.\") from times_up\n\n        if proc.stdout is not None:\n            if output_log := proc.stdout.read().decode(\"UTF-8\"):\n                if verbosity &gt; 0:\n                    dry_run_output = output_log.splitlines()\n                else:\n                    dry_run_output = summarize_rsync_report(output_log)\n                    SYNC_LOGGER.info(\"\\nSUMMARY\\n-------\")\n                for line in dry_run_output:\n                    if _is_important_stats_line(line):\n                        SYNC_LOGGER.log(25, line)\n                    else:\n                        SYNC_LOGGER.debug(line)\n\n        if proc.stderr is not None:\n            if error_log := proc.stderr.read().decode(\"UTF-8\"):\n                if \"No such file or directory\" in error_log:\n                    raise FileNotFoundError(error_log)\n                raise RuntimeError(error_log)  # pragma: no cover\n</code></pre>"},{"location":"reference/enderchest/sync/rsync/#enderchest.sync.rsync.summarize_rsync_report","title":"<code>summarize_rsync_report(raw_output, depth=2)</code>","text":"<p>Take the captured output from running <code>rsync -ha --out-format=\"%i %n\"</code> and report a high-level summary to the logging.INFO level</p> <p>Parameters:</p> Name Type Description Default <code>raw_output</code> <code>str</code> <p>The raw output captured from running the rsync command</p> required <code>depth</code> <code>int</code> <p>How many directories to go down from the root to generate the summary. Default is 2 (just report on top-level files and folders within the source folder).</p> <code>2</code> <p>Returns:</p> Type Description <code>list of str</code> <p>Any lines that weren't part of the rsync report (and were probably part of <code>--stats</code>?)</p>"},{"location":"reference/enderchest/sync/rsync/#enderchest.sync.rsync.summarize_rsync_report--notes","title":"Notes","text":"<p>The rsync man page (https://linux.die.net/man/1/rsync) describes the output format as... \"cryptic,\" which I find rather charitable. The relevant bits are that <code>--out-format=\"%i %n\"</code> produces: - <code>%i</code> : a string of 11 characters that gives various metadata about the file   transfer operation (is it a file, a directory or a link? Is it being   sent or received? Created, updated or deleted?) - <code>%n</code>: the path of the file (or whatever), unquoted, un-escaped</p> Source code in <code>enderchest/sync/rsync.py</code> <pre><code>def summarize_rsync_report(raw_output: str, depth: int = 2) -&gt; list[str]:\n    \"\"\"Take the captured output from running\n    `rsync -ha --out-format=\"%i %n\"`\n    and report a high-level summary to the logging.INFO level\n\n    Parameters\n    ----------\n    raw_output : str\n        The raw output captured from running the rsync command\n    depth : int, optional\n        How many directories to go down from the root to generate the summary.\n        Default is 2 (just report on top-level files and folders within the\n        source folder).\n\n    Returns\n    -------\n    list of str\n        Any lines that weren't part of the rsync report (and were probably\n        part of `--stats`?)\n\n    Notes\n    -----\n    The rsync man page (https://linux.die.net/man/1/rsync) describes the output\n    format as... \"cryptic,\" which I find rather charitable. The relevant bits\n    are that `--out-format=\"%i %n\"` produces:\n    - `%i` : a string of 11 characters that gives various metadata about the file\n      transfer operation (is it a file, a directory or a link? Is it being\n      sent or received? Created, updated or deleted?)\n    - `%n`: the path of the file (or whatever), unquoted, un-escaped\n    \"\"\"\n    summary: dict[str, dict[str, int] | str] = defaultdict(\n        lambda: {\"create\": 0, \"update\": 0, \"delete\": 0}\n    )\n    stats: list[str] = []\n    for line in raw_output.splitlines():\n        if line == \"\":  # skip empty lines\n            continue\n\n        info = line.split()[0]\n        full_path = os.path.normpath(\" \".join(line.split()[1:]))\n        path_key = os.sep.join(full_path.split(os.sep)[:depth])\n\n        if info.startswith(\"*deleting\"):\n            if full_path == path_key:\n                summary[path_key] = \"delete\"\n            else:\n                entry = summary[path_key]\n                if not isinstance(entry, str):\n                    entry[\"delete\"] += 1\n                # otherwise the whole thing is being deleted\n        elif info[2:5] == \"+++\":  # this is a creation\n            if full_path == path_key:\n                summary[path_key] = \"create\"\n            else:\n                if info[1] != \"d\":  # don't count directories\n                    entry = summary[path_key]\n                    if isinstance(entry, str):\n                        # then this is described by the top-level op\n                        pass\n                    else:\n                        entry[\"create\"] += 1\n                    # otherwise the whole key is being created\n        elif info[:2] in (\"&lt;f\", \"&gt;f\"):  # file transfer\n            # and remember that creates were caught above, so this must be an update\n            if full_path == path_key:\n                summary[path_key] = \"update\"\n            else:\n                entry = summary[path_key]\n                if isinstance(entry, str):  # pragma: no cover\n                    # this should never happen, but still\n                    pass\n                else:\n                    entry[\"update\"] += 1\n        elif info[:2] == \"cL\":  # this is replacing a link, as far as I can tell\n            if full_path == path_key:\n                summary[path_key] = \"update\"\n            else:\n                entry = summary[path_key]\n                if isinstance(entry, str):  # pragma: no cover\n                    # this should never happen, but still\n                    pass\n                else:\n                    entry[\"update\"] += 1\n        elif info[:1] == \".\":  # pragma: no cover\n            # this just means permissions or dates are being updated or something\n            pass\n        else:  # then hopefully this is part of the stats report\n            stats.append(line)\n            continue\n\n        SYNC_LOGGER.debug(line)\n\n    for path_key, report in sorted(summary.items()):\n        if isinstance(report, str):\n            # nice that these verbs follow the same pattern\n            SYNC_LOGGER.info(f\"{report[:-1].title()}ing {path_key}\")\n        else:\n            SYNC_LOGGER.info(\n                f\"Within {path_key}...\\n%s\",\n                \"\\n\".join(\n                    f\"  - {op[:-1].title()}ing {count} file{'' if count == 1 else 's'}\"\n                    for op, count in report.items()\n                ),\n            )\n    return stats\n</code></pre>"},{"location":"reference/enderchest/sync/sftp/","title":"sftp","text":"<p>paramiko-based sftp sync implementation</p>"},{"location":"reference/enderchest/sync/sftp/#enderchest.sync.sftp.connect","title":"<code>connect(uri, timeout=None)</code>","text":"<p>Yield an SFTPClient connected to the server specified by the given URI</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>ParseResult</code> <p>The URI of the EnderChest to connect to</p> required <code>timeout</code> <code>float</code> <p>The number of seconds to wait before timing out the sync operation. If None is provided, no explicit timeout value will be set.</p> <code>None</code> <p>Yields:</p> Type Description <code>SFTPClient</code> <p>A Paramiko SFTP client connected to the specified server</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URI is invalid or the credentials are incorrect</p> <code>RuntimeError</code> <p>If the server cannot be reached</p> Source code in <code>enderchest/sync/sftp.py</code> <pre><code>@contextmanager\ndef connect(\n    uri: ParseResult, timeout: float | None = None\n) -&gt; Generator[paramiko.sftp_client.SFTPClient, None, None]:\n    \"\"\"Yield an SFTPClient connected to the server specified by the given URI\n\n    Parameters\n    ----------\n    uri : ParseResult\n        The URI of the EnderChest to connect to\n    timeout : float, optional\n        The number of seconds to wait before timing out the sync operation.\n        If None is provided, no explicit timeout value will be set.\n\n    Yields\n    ------\n    SFTPClient\n        A Paramiko SFTP client connected to the specified server\n\n    Raises\n    ------\n    ValueError\n        If the URI is invalid or the credentials are incorrect\n    RuntimeError\n        If the server cannot be reached\n    \"\"\"\n    ssh_client = paramiko.client.SSHClient()\n    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\n    extra_kwargs: dict[str, Any] = {}\n    if timeout is not None:\n        extra_kwargs[\"timeout\"] = timeout\n\n    try:\n        ssh_client.connect(\n            uri.hostname or \"localhost\",\n            port=uri.port or 22,\n            username=uri.username,\n            # note: passing in password is explicitly unsupported\n            **extra_kwargs,\n        )\n    except paramiko.AuthenticationException:\n        target = ((uri.username + \"@\") if uri.username else \"\") + (\n            uri.hostname or \"localhost\"\n        )\n\n        SYNC_LOGGER.warning(\n            f\"This machine is not set up for passwordless login to {target}\"\n            \"\\nFor instructions on setting up public key-based authentication,\"\n            \" which is both\"\n            \"\\nmore convenient and more secure, see:\"\n            \"\\nhttps://openbagtwo.github.io/EnderChest\"\n            \"/dev/suggestions/#passwordless-ssh-authentication\"\n        )\n        password = prompt(f\"Please enter the password for {target}\", is_password=True)\n        try:\n            ssh_client.connect(\n                uri.hostname or \"localhost\",\n                port=uri.port or 22,\n                username=uri.username,\n                password=password,\n                **extra_kwargs,\n            )\n        except paramiko.AuthenticationException as bad_login:\n            raise ValueError(\n                \"Authentication failed.\"\n                \" Did you supply the correct username and password?\"\n            ) from bad_login\n\n    try:\n        sftp_client = ssh_client.open_sftp()\n        yield sftp_client\n        sftp_client.close()\n    finally:\n        ssh_client.close()\n</code></pre>"},{"location":"reference/enderchest/sync/sftp/#enderchest.sync.sftp.download_file","title":"<code>download_file(client, remote_loc, local_path, remote_stat)</code>","text":"<p>Download a file from a remote SFTP server and save it at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Paramiko SFTP client</code> <p>An authenticated client connected to the remote server</p> required <code>remote_loc</code> <code>str</code> <p>The POSIX path of the file to download</p> required <code>local_path</code> <code>Path</code> <p>The path to locally save the file</p> required <code>remote_stat</code> <code>stat - like</code> <p>The <code>os.stat_result</code>-like properties of the remote object</p> required"},{"location":"reference/enderchest/sync/sftp/#enderchest.sync.sftp.download_file--notes","title":"Notes","text":"<p>This is a wrapper around <code>client.get()</code> that can handle symlinks and updating timestamps. It does not check if either path is valid, points to a file, lives in an existing folder, etc.</p> Source code in <code>enderchest/sync/sftp.py</code> <pre><code>def download_file(\n    client: paramiko.sftp_client.SFTPClient,\n    remote_loc: str,\n    local_path: Path,\n    remote_stat: paramiko.SFTPAttributes,\n) -&gt; None:\n    \"\"\"Download a file from a remote SFTP server and save it at the specified\n    location.\n\n    Parameters\n    ----------\n    client : Paramiko SFTP client\n        An authenticated client connected to the remote server\n    remote_loc : str\n        The POSIX path of the file to download\n    local_path : Path\n        The path to locally save the file\n    remote_stat : stat-like\n        The `os.stat_result`-like properties of the remote object\n\n    Notes\n    -----\n    This is a wrapper around `client.get()` that can handle symlinks and\n    updating timestamps. It does not check if either path is valid, points\n    to a file, lives in an existing folder, etc.\n    \"\"\"\n    if stat.S_ISLNK(remote_stat.st_mode or 0):\n        local_path.symlink_to(Path((client.readlink(remote_loc) or \"\")))\n    else:\n        client.get(remote_loc, local_path)\n        if remote_stat.st_atime and remote_stat.st_mtime:\n            os.utime(\n                local_path,\n                times=(remote_stat.st_atime, remote_stat.st_mtime),\n            )\n</code></pre>"},{"location":"reference/enderchest/sync/sftp/#enderchest.sync.sftp.get_contents","title":"<code>get_contents(client, path)</code>","text":"<p>Recursively fetch the contents of a remote directory</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Paramiko SFTP client</code> <p>An authenticated client connected to the remote server</p> required <code>path</code> <code>str</code> <p>The absolute path to scan</p> required <p>Returns:</p> Type Description <code>list of (Path, SFTPAttributes) tuples</code> <p>The attributes of all files, folders and symlinks found under the specified path</p>"},{"location":"reference/enderchest/sync/sftp/#enderchest.sync.sftp.get_contents--notes","title":"Notes","text":"<ul> <li>This list is generated via a depth-first search so that all parent   directories appear before their children</li> <li>The paths returned are relative to the provided path</li> </ul> Source code in <code>enderchest/sync/sftp.py</code> <pre><code>def get_contents(\n    client: paramiko.sftp_client.SFTPClient, path: str\n) -&gt; list[tuple[Path, paramiko.sftp_attr.SFTPAttributes]]:\n    \"\"\"Recursively fetch the contents of a remote directory\n\n    Parameters\n    ----------\n    client : Paramiko SFTP client\n        An authenticated client connected to the remote server\n    path : str\n        The absolute path to scan\n\n    Returns\n    -------\n    list of (Path, SFTPAttributes) tuples\n        The attributes of all files, folders and symlinks found under the\n        specified path\n\n    Notes\n    -----\n    - This list is generated via a depth-first search so that all parent\n      directories appear before their children\n    - The paths returned are relative to the provided path\n    \"\"\"\n    return [\n        (p.relative_to(url2pathname(path)), path_stat)\n        for p, path_stat in rglob(client, path)\n    ]\n</code></pre>"},{"location":"reference/enderchest/sync/sftp/#enderchest.sync.sftp.pull","title":"<code>pull(remote_uri, local_path, exclude, dry_run, timeout=None, delete=True, **unsupported_kwargs)</code>","text":"<p>Sync an upstream file or folder into the specified location SFTP. This will overwrite any files and folders already at the destination.</p> <p>Parameters:</p> Name Type Description Default <code>remote_uri</code> <code>ParseResult</code> <p>The URI for the remote resource to copy from</p> required <code>local_path</code> <code>Path</code> <p>The destination folder</p> required <code>exclude</code> <code>list of str</code> <p>Any patterns that should be excluded from the sync</p> required <code>dry_run</code> <code>bool</code> <p>Whether to only simulate this sync (report the operations to be performed but not actually perform them)</p> required <code>timeout</code> <code>float</code> <p>The number of seconds to wait before timing out the sync operation. If None is provided, no explicit timeout value will be set.</p> <code>None</code> <code>delete</code> <code>bool</code> <p>Whether part of the syncing should include deleting files at the destination that aren't at the source. Default is True.</p> <code>True</code> <code>**unsupported_kwargs</code> <p>Any other provided options will be ignored</p> <code>{}</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the destination folder does not exist, or if the remote path does not exist</p> <code>OSError</code> <p>If the remote path cannot be accessed for any other reason (permissions, most likely)</p>"},{"location":"reference/enderchest/sync/sftp/#enderchest.sync.sftp.pull--notes","title":"Notes","text":"<ul> <li>If the destination folder does not already exist, this method will not   create it or its parent directories.</li> </ul> Source code in <code>enderchest/sync/sftp.py</code> <pre><code>def pull(\n    remote_uri: ParseResult,\n    local_path: Path,\n    exclude: Collection[str],\n    dry_run: bool,\n    timeout: float | None = None,\n    delete: bool = True,\n    **unsupported_kwargs,\n) -&gt; None:\n    \"\"\"Sync an upstream file or folder into the specified location SFTP.\n    This will overwrite any files and folders already at the destination.\n\n    Parameters\n    ----------\n    remote_uri : ParseResult\n        The URI for the remote resource to copy from\n    local_path : Path\n        The destination folder\n    exclude : list of str\n        Any patterns that should be excluded from the sync\n    dry_run : bool\n        Whether to only simulate this sync (report the operations to be performed\n        but not actually perform them)\n    timeout : float, optional\n        The number of seconds to wait before timing out the sync operation.\n        If None is provided, no explicit timeout value will be set.\n    delete : bool\n        Whether part of the syncing should include deleting files at the destination\n        that aren't at the source. Default is True.\n    **unsupported_kwargs\n        Any other provided options will be ignored\n\n    Raises\n    ------\n    FileNotFoundError\n        If the destination folder does not exist, or if the remote path\n        does not exist\n    OSError\n        If the remote path cannot be accessed for any other reason (permissions,\n        most likely)\n\n    Notes\n    -----\n    - If the destination folder does not already exist, this method will not\n      create it or its parent directories.\n    \"\"\"\n    if not local_path.exists():\n        raise FileNotFoundError(f\"{local_path} does not exist\")\n    if unsupported_kwargs:\n        SYNC_LOGGER.debug(\n            \"The following command-line options are ignored for this protocol:\\n%s\",\n            \"\\n\".join(\"  {}: {}\".format(*item) for item in unsupported_kwargs.items()),\n        )\n\n    remote_loc = posixpath.normpath(unquote(remote_uri.path))\n    destination_path = local_path / posixpath.basename(remote_loc)\n\n    if destination_path.is_symlink() and not destination_path.is_dir():\n        SYNC_LOGGER.warning(\"Removing symlink %s\", destination_path)\n        if not dry_run:\n            destination_path.unlink()\n        else:\n            SYNC_LOGGER.debug(\n                \"And replacing it entirely with the remote's %s\", remote_loc\n            )\n            return\n    elif destination_path.exists() and not destination_path.is_dir():\n        SYNC_LOGGER.warning(\"Deleting file %s\", destination_path)\n        if not dry_run:\n            destination_path.unlink()\n        else:\n            SYNC_LOGGER.debug(\n                \"And replacing it entirely with the remote's %s\", remote_loc\n            )\n            return\n\n    with connect(uri=remote_uri, timeout=timeout) as remote:\n        try:\n            source_target = remote.lstat(remote_loc)\n        except OSError as bad_target:\n            raise type(bad_target)(\n                f\"Could not access {remote_loc} on remote: {bad_target}\"\n            )\n        if not stat.S_ISDIR(source_target.st_mode or 0):\n            if destination_path.exists() and is_identical(\n                source_target, destination_path.stat()\n            ):\n                SYNC_LOGGER.warning(\n                    \"Remote file matches %s. No transfer needed.\",\n                    destination_path,\n                )\n                return\n            SYNC_LOGGER.debug(\n                \"Downloading file %s from remote\",\n                destination_path,\n            )\n            if not dry_run:\n                download_file(\n                    remote,\n                    remote_loc,\n                    destination_path,\n                    source_target,\n                )\n            return\n\n        if not destination_path.exists():\n            SYNC_LOGGER.debug(\n                \"Downloading the entire contents of the remote's %s\", remote_loc\n            )\n            if dry_run:\n                return\n            destination_path.mkdir()\n\n        source_contents = filter_contents(\n            get_contents(remote, remote_loc),\n            exclude,\n            prefix=remote_loc,\n        )\n        destination_contents = filter_contents(\n            file.get_contents(destination_path),\n            exclude,\n            prefix=destination_path,\n        )\n\n        sync_diff = diff(source_contents, destination_contents)\n\n        if dry_run:\n            generate_sync_report(sync_diff)\n            return\n\n        ignore = file.ignore_patterns(*exclude)\n        for path, path_stat, operation in sync_diff:\n            match (operation, stat.S_ISDIR(path_stat.st_mode or 0)):\n                case (Op.CREATE, True):\n                    SYNC_LOGGER.debug(\"Creating directory %s\", destination_path / path)\n                    (destination_path / path).mkdir(parents=True, exist_ok=True)\n                case (Op.CREATE, False) | (Op.REPLACE, False):\n                    SYNC_LOGGER.debug(\n                        \"Downloading file %s from remote\",\n                        destination_path / path,\n                    )\n                    (destination_path / path).unlink(missing_ok=True)\n                    download_file(\n                        remote,\n                        posixpath.join(remote_loc, path.as_posix()),\n                        destination_path / path,\n                        path_stat,  # type: ignore[arg-type]\n                    )\n                case (Op.DELETE, True):\n                    # recall that for deletions, it's the *destination's* stats\n                    if delete:\n                        file.clean(destination_path / path, ignore, dry_run)\n                case (Op.DELETE, False):\n                    SYNC_LOGGER.debug(\"Deleting file %s\", destination_path / path)\n                    if delete:\n                        (destination_path / path).unlink()\n                case op, is_dir:  # pragma: no cover\n                    raise NotImplementedError(\n                        f\"Don't know how to handle {op} of {'directory' if is_dir else 'file'}\"\n                    )\n</code></pre>"},{"location":"reference/enderchest/sync/sftp/#enderchest.sync.sftp.push","title":"<code>push(local_path, remote_uri, exclude, dry_run, timeout=None, delete=True, **unsupported_kwargs)</code>","text":"<p>Sync a local file or folder into the specified location using SFTP. This will overwrite any files and folders already at the destination.</p> <p>Parameters:</p> Name Type Description Default <code>local_path</code> <code>Path</code> <p>The file or folder to copy</p> required <code>remote_uri</code> <code>ParseResult</code> <p>The URI for the remote location to copy into</p> required <code>exclude</code> <code>list of str</code> <p>Any patterns that should be excluded from the sync</p> required <code>dry_run</code> <code>bool</code> <p>Whether to only simulate this sync (report the operations to be performed but not actually perform them)</p> required <code>timeout</code> <code>float</code> <p>The number of seconds to wait before timing out the sync operation. If None is provided, no explicit timeout value will be set.</p> <code>None</code> <code>delete</code> <code>bool</code> <p>Whether part of the syncing should include deleting files at the destination that aren't at the source. Default is True.</p> <code>True</code> <code>**unsupported_kwargs</code> <p>Any other provided options will be ignored</p> <code>{}</code>"},{"location":"reference/enderchest/sync/sftp/#enderchest.sync.sftp.push--notes","title":"Notes","text":"<ul> <li>If the destination folder does not already exist, this method will not   create it or its parent directories.</li> </ul> Source code in <code>enderchest/sync/sftp.py</code> <pre><code>def push(\n    local_path: Path,\n    remote_uri: ParseResult,\n    exclude: Collection[str],\n    dry_run: bool,\n    timeout: float | None = None,\n    delete: bool = True,\n    **unsupported_kwargs,\n) -&gt; None:\n    \"\"\"Sync a local file or folder into the specified location using SFTP.\n    This will overwrite any files and folders already at the destination.\n\n    Parameters\n    ----------\n    local_path : Path\n        The file or folder to copy\n    remote_uri : ParseResult\n        The URI for the remote location to copy into\n    exclude : list of str\n        Any patterns that should be excluded from the sync\n    dry_run : bool\n        Whether to only simulate this sync (report the operations to be performed\n        but not actually perform them)\n    timeout : float, optional\n        The number of seconds to wait before timing out the sync operation.\n        If None is provided, no explicit timeout value will be set.\n    delete : bool, optional\n        Whether part of the syncing should include deleting files at the destination\n        that aren't at the source. Default is True.\n    **unsupported_kwargs\n        Any other provided options will be ignored\n\n    Notes\n    -----\n    - If the destination folder does not already exist, this method will not\n      create it or its parent directories.\n    \"\"\"\n    if not local_path.exists():\n        raise FileNotFoundError(f\"{local_path} does not exist.\")\n    if unsupported_kwargs:\n        SYNC_LOGGER.debug(\n            \"The following command-line options are ignored for this protocol:\\n%s\",\n            \"\\n\".join(\"  {}: {}\".format(*item) for item in unsupported_kwargs.items()),\n        )\n\n    remote_parent = posixpath.normpath(unquote(remote_uri.path))\n\n    with connect(uri=remote_uri, timeout=timeout) as remote:\n        try:\n            remote_folder_stat = remote.lstat(remote_parent)\n        except OSError as bad_target:\n            raise type(bad_target)(\n                f\"Could not access {remote_parent} on remote: {bad_target}\"\n            )\n        if not stat.S_ISDIR(remote_folder_stat.st_mode or 0):\n            raise NotADirectoryError(f\"{remote_parent} on remote is not a directory.\")\n\n        remote_loc = posixpath.join(remote_parent, local_path.name)\n        try:\n            target_stat = remote.lstat(remote_loc)\n        except FileNotFoundError:\n            target_stat = None\n        if not stat.S_ISDIR(local_path.stat().st_mode or 0):\n            if target_stat and is_identical(local_path.stat(), target_stat):\n                SYNC_LOGGER.warning(\"Remote file matches %s\", local_path)\n                return\n\n            SYNC_LOGGER.debug(\n                \"Uploading file %s to remote\",\n                local_path,\n            )\n            if not dry_run:\n                upload_file(remote, local_path, remote_loc)\n            return\n        if not target_stat:\n            SYNC_LOGGER.debug(\"Uploading the entire contents %s\", local_path)\n            if dry_run:\n                return\n            remote.mkdir(remote_loc)\n        elif not stat.S_ISDIR(target_stat.st_mode or 0):\n            SYNC_LOGGER.warning(\n                \"Deleting remote file or symlink %s\",\n                remote_loc,\n            )\n            if dry_run:\n                SYNC_LOGGER.debug(\"And replacing it entirely with %s\", local_path)\n                return\n            remote.remove(remote_loc)\n            remote.mkdir(remote_loc)\n\n        source_contents = filter_contents(\n            file.get_contents(local_path), exclude, prefix=local_path\n        )\n        destination_contents = filter_contents(\n            get_contents(remote, remote_loc),\n            exclude,\n            prefix=remote_loc,\n        )\n\n        sync_diff = diff(source_contents, destination_contents)\n\n        if dry_run:\n            generate_sync_report(sync_diff)\n            return\n\n        for path, path_stat, operation in sync_diff:\n            posix_path = posixpath.join(remote_loc, path.as_posix())\n            match (operation, stat.S_ISDIR(path_stat.st_mode or 0)):\n                case (Op.CREATE, True):\n                    SYNC_LOGGER.debug(\"Creating remote directory %s\", posix_path)\n                    remote.mkdir(posix_path)\n                case (Op.CREATE, False) | (Op.REPLACE, False):\n                    SYNC_LOGGER.debug(\n                        \"Uploading file %s to remote\",\n                        local_path / path,\n                    )\n                    try:\n                        remote.remove(posix_path)\n                    except FileNotFoundError:\n                        pass\n                    upload_file(\n                        remote,\n                        local_path / path,\n                        posix_path,\n                    )\n                case (Op.DELETE, True):\n                    # recall that for deletions, it's the *destination's* stats\n                    if delete:\n                        remote.rmdir(posix_path)\n                case (Op.DELETE, False):\n                    if delete:\n                        SYNC_LOGGER.debug(\"Deleting remote file %s\", posix_path)\n                        remote.remove(posix_path)\n                case op, is_dir:  # pragma: no cover\n                    raise NotImplementedError(\n                        f\"Don't know how to handle {op} of {'directory' if is_dir else 'file'}\"\n                    )\n</code></pre>"},{"location":"reference/enderchest/sync/sftp/#enderchest.sync.sftp.rglob","title":"<code>rglob(client, path)</code>","text":"<p>Recursively enumerate the contents of a remote directory</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Paramiko SFTP client</code> <p>An authenticated client connected to the remote server</p> required <code>path</code> <code>str</code> <p>The absolute path to scan</p> required <p>Returns:</p> Type Description <code>list of (Path, SFTPAttributes) tuples</code> <p>The attributes of all files, folders and symlinks found under the specified path</p>"},{"location":"reference/enderchest/sync/sftp/#enderchest.sync.sftp.rglob--notes","title":"Notes","text":"<ul> <li>The paths returned are absolute</li> <li>The search is performed depth-first</li> </ul> Source code in <code>enderchest/sync/sftp.py</code> <pre><code>def rglob(\n    client: paramiko.sftp_client.SFTPClient, path: str\n) -&gt; list[tuple[Path, paramiko.sftp_attr.SFTPAttributes]]:\n    \"\"\"Recursively enumerate the contents of a remote directory\n\n    Parameters\n    ----------\n    client : Paramiko SFTP client\n        An authenticated client connected to the remote server\n    path : str\n        The absolute path to scan\n\n    Returns\n    -------\n    list of (Path, SFTPAttributes) tuples\n        The attributes of all files, folders and symlinks found under the\n        specified path\n\n    Notes\n    -----\n    - The paths returned are *absolute*\n    - The search is performed depth-first\n    \"\"\"\n    SYNC_LOGGER.debug(f\"ls {path}\")\n    top_level = client.listdir_attr(path)\n    contents: list[tuple[Path, paramiko.sftp_attr.SFTPAttributes]] = []\n    for remote_object in top_level:\n        remote_object.filename = posixpath.join(path, remote_object.filename)\n        contents.append((Path(url2pathname(remote_object.filename)), remote_object))\n        if stat.S_ISDIR(remote_object.st_mode or 0):\n            contents.extend(rglob(client, remote_object.filename))\n    return contents\n</code></pre>"},{"location":"reference/enderchest/sync/sftp/#enderchest.sync.sftp.upload_file","title":"<code>upload_file(client, local_path, remote_loc)</code>","text":"<p>Upload a local file to a remote SFTP server</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Paramiko SFTP client</code> <p>An authenticated client connected to the remote server</p> required <code>local_path</code> <code>Path</code> <p>The path of the file to upload</p> required <code>remote_loc</code> <code>str</code> <p>The POSIX path for the remote location to save the file</p> required"},{"location":"reference/enderchest/sync/sftp/#enderchest.sync.sftp.upload_file--notes","title":"Notes","text":"<p>This is just a wrapper around <code>client.put()</code> that can handle symlinks. It does not check if either path is valid, points to a file, lives in an existing folder, etc.</p> Source code in <code>enderchest/sync/sftp.py</code> <pre><code>def upload_file(\n    client: paramiko.sftp_client.SFTPClient,\n    local_path: Path,\n    remote_loc: str,\n) -&gt; None:\n    \"\"\"Upload a local file to a remote SFTP server\n\n    Parameters\n    ----------\n    client : Paramiko SFTP client\n        An authenticated client connected to the remote server\n    local_path : Path\n        The path of the file to upload\n    remote_loc : str\n        The POSIX path for the remote location to save the file\n\n    Notes\n    -----\n    This is just a wrapper around `client.put()` that can handle symlinks.\n    It does not check if either path is valid, points to a file, lives in an\n    existing folder, etc.\n    \"\"\"\n    if local_path.is_symlink():\n        client.symlink(local_path.readlink().as_posix(), remote_loc)\n    else:\n        client.put(local_path, remote_loc)\n        client.utime(\n            remote_loc, times=(local_path.stat().st_atime, local_path.stat().st_mtime)\n        )\n</code></pre>"},{"location":"reference/enderchest/sync/utils/","title":"utils","text":"<p>Non-implementation-specific syncing utilities</p>"},{"location":"reference/enderchest/sync/utils/#enderchest.sync.utils.Operation","title":"<code>Operation</code>","text":"<p>             Bases: <code>Enum</code></p> <p>The recognized sync operations</p>"},{"location":"reference/enderchest/sync/utils/#enderchest.sync.utils.Operation--notes","title":"Notes","text":"<p>There's no <code>UPDATE</code> operation because so far this class isn't used by anything that can perform a delta update on a file</p> Source code in <code>enderchest/sync/utils.py</code> <pre><code>class Operation(Enum):\n    \"\"\"The recognized sync operations\n\n    Notes\n    -----\n    There's no `UPDATE` operation because so far this class isn't used by\n    anything that _can_ perform a delta update on a file\n    \"\"\"\n\n    CREATE = auto()\n    REPLACE = auto()\n    DELETE = auto()\n</code></pre>"},{"location":"reference/enderchest/sync/utils/#enderchest.sync.utils.abspath_from_uri","title":"<code>abspath_from_uri(uri)</code>","text":"<p>Extract and unquote the path component of a URI to turn it into an unambiguous absolute <code>pathlib.Path</code></p> <p>h/t https://stackoverflow.com/a/61922504</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>ParseResult</code> <p>The parsed URI to extract the path from</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The path part of the URI as a Path</p> Source code in <code>enderchest/sync/utils.py</code> <pre><code>def abspath_from_uri(uri: ParseResult) -&gt; Path:\n    \"\"\"Extract and unquote the path component of a URI to turn it into an\n    unambiguous absolute `pathlib.Path`\n\n    h/t https://stackoverflow.com/a/61922504\n\n    Parameters\n    ----------\n    uri : ParseResult\n        The parsed URI to extract the path from\n\n    Returns\n    -------\n    Path\n        The path part of the URI as a Path\n    \"\"\"\n    host = \"{0}{0}{mnt}{0}\".format(os.path.sep, mnt=uri.netloc)\n    return Path(os.path.abspath(os.path.join(host, url2pathname(unquote(uri.path)))))\n</code></pre>"},{"location":"reference/enderchest/sync/utils/#enderchest.sync.utils.diff","title":"<code>diff(source_files, destination_files)</code>","text":"<p>Compute the \"diff\" between the source and destination, enumerating all the operations that should be performed so that the destination matches the source</p> <p>Parameters:</p> Name Type Description Default <code>source_files</code> <code>list of (Path, stat_result) tuples</code> <p>The files and file attributes at the source</p> required <code>destination_files</code> <code>list of (Path, stat_result) tuples</code> <p>The files and file attributes at the destination</p> required <p>Returns:</p> Type Description <code>Generator of (Path, stat_result, Operation) tuples</code> <p>The files, their attributes and the operations that should be performed on each file</p>"},{"location":"reference/enderchest/sync/utils/#enderchest.sync.utils.diff--notes","title":"Notes","text":"<ul> <li>The order of paths returned will match the order provided by the <code>source_files</code>   except for the deletions, which will all come at the end and will be sorted   from longest to shortest path (so that individual files are marked for deletion   before their parent folders).</li> <li>The attributes of each path will correspond to the source attributes for   creations and replacements and to the destination attributes for the deletions</li> </ul> Source code in <code>enderchest/sync/utils.py</code> <pre><code>def diff(\n    source_files: Iterable[tuple[Path, _StatLike]],\n    destination_files: Iterable[tuple[Path, _StatLike]],\n) -&gt; Generator[tuple[Path, _StatLike, Operation], None, None]:\n    \"\"\"Compute the \"diff\" between the source and destination, enumerating\n    all the operations that should be performed so that the destination\n    matches the source\n\n    Parameters\n    ----------\n    source_files : list of (Path, stat_result) tuples\n        The files and file attributes at the source\n    destination_files : list of (Path, stat_result) tuples\n        The files and file attributes at the destination\n\n    Returns\n    -------\n    Generator of (Path, stat_result, Operation) tuples\n        The files, their attributes and the operations that should be performed on each file\n\n    Notes\n    -----\n    - The order of paths returned will match the order provided by the `source_files`\n      except for the deletions, which will all come at the end and will be sorted\n      from longest to shortest path (so that individual files are marked for deletion\n      before their parent folders).\n    - The attributes of each path will correspond to the *source* attributes for\n      creations and replacements and to the *destination* attributes for the deletions\n    \"\"\"\n    destination_lookup: dict[Path, _StatLike] = dict(destination_files)\n    for file, source_stat in source_files:\n        if file not in destination_lookup:\n            yield file, source_stat, Operation.CREATE\n        else:\n            destination_stat = destination_lookup.pop(file)\n            if not is_identical(source_stat, destination_stat):\n                yield file, source_stat, Operation.REPLACE\n            # else: continue\n\n    for file, destination_stat in sorted(\n        destination_lookup.items(), key=lambda x: -len(str(x[0]))\n    ):\n        yield file, destination_stat, Operation.DELETE\n</code></pre>"},{"location":"reference/enderchest/sync/utils/#enderchest.sync.utils.filter_contents","title":"<code>filter_contents(contents, exclude, prefix=None)</code>","text":"<p>Apply an exclusion filter to a list of files</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>list of (Path, ...) tuples</code> <p>The contents to filter</p> required <code>exclude</code> <code>list of str</code> <p>The patterns to exclude</p> required <code>prefix</code> <code>Path</code> <p>If the contents are iterating over a subdirectory, providing the directory as the <code>prefix</code> will allow filtering to be performed on the full path.</p> <code>None</code> <p>Yields:</p> Type Description <code>(Path, ...) tuples</code> <p>The elements of the provided list, omitting the ones to be excluded</p> Source code in <code>enderchest/sync/utils.py</code> <pre><code>def filter_contents(\n    contents: Iterable[PathInfo],\n    exclude: Collection[str],\n    prefix: Path | str | None = None,\n) -&gt; Generator[PathInfo, None, None]:\n    \"\"\"Apply an exclusion filter to a list of files\n\n    Parameters\n    ----------\n    contents : list of (Path, ...) tuples\n        The contents to filter\n    exclude : list of str\n        The patterns to exclude\n    prefix : Path, optional\n        If the contents are iterating over a subdirectory, providing the directory\n        as the `prefix` will allow filtering to be performed on the full path.\n\n    Yields\n    ------\n    (Path, ...) tuples\n        The elements of the provided list, omitting the ones\n        to be excluded\n    \"\"\"\n    for path_info in contents:\n        if not any(\n            (\n                fnmatch.fnmatch(\n                    os.path.normpath(os.path.join(prefix or \"\", path_info[0])),\n                    os.path.join(\"*\", pattern),\n                )\n                for pattern in exclude\n            )\n        ):\n            yield path_info\n</code></pre>"},{"location":"reference/enderchest/sync/utils/#enderchest.sync.utils.generate_sync_report","title":"<code>generate_sync_report(content_diff, depth=2)</code>","text":"<p>Compile a high-level summary of the outcome of the <code>diff</code> method and report it to the logging.INFO level</p> <p>Parameters:</p> Name Type Description Default <code>content_diff</code> <code>list of (Path, Operation) tuples</code> <p>The files and the operations that are to be performed on each file, as generated by the <code>diff</code> method</p> required <code>depth</code> <code>int</code> <p>How many directories to go down from the root to generate the summary. Default is 2 (just report on top-level files and folders within the source folder).</p> <code>2</code> <p>Returns:</p> Type Description <code>None</code> Source code in <code>enderchest/sync/utils.py</code> <pre><code>def generate_sync_report(\n    content_diff: Iterable[tuple[Path, _StatLike, Operation]], depth: int = 2\n) -&gt; None:\n    \"\"\"Compile a high-level summary of the outcome of the `diff` method\n    and report it to the logging.INFO level\n\n    Parameters\n    ----------\n    content_diff : list of (Path, Operation) tuples\n        The files and the operations that are to be performed on each file, as\n        generated by the `diff` method\n    depth : int, optional\n        How many directories to go down from the root to generate the summary.\n        Default is 2 (just report on top-level files and folders within the\n        source folder).\n\n    Returns\n    -------\n    None\n    \"\"\"\n    summary: dict[Path, dict[Operation, int] | Operation] = defaultdict(\n        lambda: {Operation.CREATE: 0, Operation.REPLACE: 0, Operation.DELETE: 0}\n    )\n\n    for full_path, path_stat, operation in content_diff:\n        try:\n            path_key = full_path.parents[-depth]\n        except IndexError:  # then this doesn't go in a subdirectory\n            summary[full_path] = operation\n            continue\n\n        entry = summary[path_key]\n        if isinstance(entry, Operation):\n            # then this is described by the top-level op\n            continue\n        if operation == Operation.CREATE and stat.S_ISDIR(path_stat.st_mode or 0):\n            # don't count folder creations\n            continue\n\n        entry[operation] += 1\n\n    for path_key, report in sorted(summary.items()):\n        if isinstance(report, Operation):\n            # nice that these verbs follow the same pattern\n            SYNC_LOGGER.info(f\"{report.name[:-1].title()}ing {path_key}\")\n        else:\n            SYNC_LOGGER.info(\n                f\"Within {path_key}...\\n%s\",\n                \"\\n\".join(\n                    f\"  - {op.name[:-1].title()}ing {count} file{'' if count == 1 else 's'}\"\n                    for op, count in report.items()\n                ),\n            )\n</code></pre>"},{"location":"reference/enderchest/sync/utils/#enderchest.sync.utils.get_default_netloc","title":"<code>get_default_netloc()</code>","text":"<p>Compile a netloc from environment variables, etc.</p> <p>Returns:</p> Type Description <code>str</code> <p>The default netloc, which is {user}@{hostname}</p> Source code in <code>enderchest/sync/utils.py</code> <pre><code>def get_default_netloc() -&gt; str:\n    \"\"\"Compile a netloc from environment variables, etc.\n\n    Returns\n    -------\n    str\n        The default netloc, which is {user}@{hostname}\n    \"\"\"\n    return f\"{getpass.getuser()}@{socket.gethostname()}\".lower()\n</code></pre>"},{"location":"reference/enderchest/sync/utils/#enderchest.sync.utils.is_identical","title":"<code>is_identical(object_one, object_two)</code>","text":"<p>Determine if two objects are identical (meaning: skip when syncing)</p> <p>Parameters:</p> Name Type Description Default <code>object_one</code> <code>stat_result or similar</code> <p>The first object to compare</p> required <code>object_two</code> <code>stat_result or similar</code> <p>The second object to compare</p> required <p>Returns:</p> Type Description <code>bool</code> <p>False if the objects are conclusively different, True otherwise.</p>"},{"location":"reference/enderchest/sync/utils/#enderchest.sync.utils.is_identical--notes","title":"Notes","text":"<p>As most implementations of the SFTP protocol do not include the check-file extension, this method is limited in what it can compare. Use with caution.</p> Source code in <code>enderchest/sync/utils.py</code> <pre><code>def is_identical(object_one: _StatLike, object_two: _StatLike) -&gt; bool:\n    \"\"\"Determine if two objects are identical (meaning: skip when syncing)\n\n    Parameters\n    ----------\n    object_one : os.stat_result or similar\n        The first object to compare\n    object_two : os.stat_result or similar\n        The second object to compare\n\n    Returns\n    -------\n    bool\n        False if the objects are conclusively different, True otherwise.\n\n    Notes\n    -----\n    As most implementations of the SFTP protocol do not include the check-file\n    extension, this method is limited in what it can compare. Use with caution.\n    \"\"\"\n    if stat.S_ISDIR(object_one.st_mode or 0) != stat.S_ISDIR(object_two.st_mode or 0):\n        return False\n    if stat.S_ISLNK(object_one.st_mode or 0) != stat.S_ISLNK(object_two.st_mode or 0):\n        return False\n\n    if stat.S_ISLNK(object_one.st_mode or 0):\n        # there's no way from the stat to tell if two links have the same target\n        # so err on the side of \"nope\"\n        return False\n\n    if stat.S_ISREG(object_one.st_mode or 0):\n        # these comparisons should only be run on files\n        if int(object_one.st_size or 0) != int(object_two.st_size or 0):\n            return False\n        if int(object_one.st_mtime or 0) != int(object_two.st_mtime or 0):\n            return False\n    return True\n</code></pre>"},{"location":"reference/enderchest/sync/utils/#enderchest.sync.utils.render_remote","title":"<code>render_remote(alias, uri)</code>","text":"<p>Render a remote to a descriptive string</p> <p>Parameters:</p> Name Type Description Default <code>alias</code> <code>str</code> <p>The name of the remote</p> required <code>uri</code> <code>ParseResult</code> <p>The parsed URI for the remote</p> required <p>Returns:</p> Type Description <code>str</code> <p><code>{uri_string} [({alias})]}</code>     (alias is omitted if it's the same as the URI's hostname)</p> Source code in <code>enderchest/sync/utils.py</code> <pre><code>def render_remote(alias: str, uri: ParseResult) -&gt; str:\n    \"\"\"Render a remote to a descriptive string\n\n    Parameters\n    ----------\n    alias : str\n        The name of the remote\n    uri : ParseResult\n        The parsed URI for the remote\n\n    Returns\n    -------\n    str\n        `{uri_string} [({alias})]}`\n            (alias is omitted if it's the same as the URI's hostname)\n    \"\"\"\n    uri_string = uri.geturl()\n\n    if uri.hostname != alias:\n        uri_string += f\" ({alias})\"\n    return uri_string\n</code></pre>"},{"location":"reference/enderchest/sync/utils/#enderchest.sync.utils.uri_to_ssh","title":"<code>uri_to_ssh(uri)</code>","text":"<p>Convert a URI to an SSH address</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>ParseResult</code> <p>The URI to convert</p> required <p>Returns:</p> Type Description <code>str</code> <p>The SSH-format address</p> Source code in <code>enderchest/sync/utils.py</code> <pre><code>def uri_to_ssh(uri: ParseResult) -&gt; str:\n    \"\"\"Convert a URI to an SSH address\n\n    Parameters\n    ----------\n    uri: ParseResult\n        The URI to convert\n\n    Returns\n    -------\n    str\n        The SSH-format address\n    \"\"\"\n    return \"{user}{host}:{path}\".format(\n        user=f\"{uri.username}@\" if uri.username else \"\",\n        host=(uri.hostname or \"localhost\") + (f\":{uri.port}\" if uri.port else \"\"),\n        path=uri.path,\n    )\n</code></pre>"},{"location":"coverage/","title":"Coverage","text":""}]}