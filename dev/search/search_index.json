{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"EnderChest","text":"<p>Welcome to the documentation for EnderChest, a python package for syncing and linking all your Minecraft instances.</p> <p>Use the nav bar on the side of the page to access tutorials, how-to guides or the full API docs.</p> <p>The source code for this project is freely available on GitHub.</p> <p>If you encounter a bug or have a suggestion, open an issue!</p>"},{"location":"about/","title":"About EnderChest","text":"<p>With the arrival of my Steam Deck in 2022, I found myself with the very First World problem of having too many Minecraft installations across too many computers, and I really want to keep everything synced and backed up. This isn't as simple of a problem as just having a central repository on a NAS, as the machines I've got running Minecraft range from an Raspberry Pi, to an M1 Macbook to the controller-operated Steam Deck to an absolute beast of a desktop battlestation. Each machine needs its own settings, client mods and tweaks for optimal gameplay.</p> <p>Furthermore, since I make mods and datapacks and have content creation aspirations, several of my machines have multiple instance variants that are, for example, streamlined for development and testing or optimized for ReplayMod rendering, but for which I still want to share some mods, resourcepacks and worlds with other instances.</p> <p>And finally, there are some instances that I want to run on a server--either local or hosted--and keeping resource packs, mods and other assets synced between servers and clients is a giant pain.</p> <p>In short, there are three different levels of coordination that need to take place: 1. Selective sharing across different computers 1. Selective sharing across different instances on the same computer 1. Selective sharing across server and client installations</p>"},{"location":"about/#symlinks-to-the-rescue","title":"Symlinks to the Rescue!","text":"<p>The first and most important bit--making it so that changing a file in one place changes it everywhere else--is why MIT invented symbolic links, where each file is stored in exactly one location, and everywhere else that file is expected is basically just a forwarding address to that file.  Since I'm almost never going to be running two instances of Minecraft at once, there's no worrying about file locks or simultaneous writes, so making it so that there's only one true copy of every file on a file system is the ideal solution for keeping everything in sync.</p> <p>And if we're already talking about symlinking all the things, and we know we need to be able to sync files between filesystems, it makes sense to store all of those true copies in one centralized place. Hence, the EnderChest.</p>"},{"location":"about/#automagic-linking","title":"Automagic Linking","text":"<p>One could just stop there--designate a folder for all your Minecraft files, sync that folder between your computers, and then manually put links in each of your Minecraft instances pointing into the EnderChest. But dang it there are a lot of mods out there and having to create new links by hand every time you want to try out a new resource pack is very few people's idea of a fun time.</p> <p>And that's where the magic of scripting languages comes into play (and why is a Python package and not a \"how-to\" guide). With a few short terminal commands, you can set it up so that updating Sodium across all of your compatible Minecraft instances is a simple matter of dragging in the file and running the command <code>enderchest place</code>.</p>"},{"location":"about/#organizing-the-enderchest-monster-with-shulker-boxes","title":"Organizing the EnderChest Monster with Shulker Boxes","text":"<p>The original implementation of EnderChest was a giant mess, with every file for every instance just thrown into one of a small number of folders. After a few months of using it, I found myself absolutely dreading the process of creating a new Minecraft instance, knowing I'd have to update the configuration of every single file I'd want to link.</p> <p>The next iteration of this concept was probably obvious to anyone who's used an ender chest in the game after beating Jean: by grouping my files into purpose-specific \"Shulker Boxes,\" I could onboard a new Minecraft instance by editing just a handful of box-configs. Or even better--I could just tag the new instance in a way that it would get matched to the folders automatically.</p>"},{"location":"cli/","title":"Full Command-Line Interface Documentation","text":""},{"location":"cli/#summary","title":"Summary","text":"<pre><code>usage: enderchest [-h] [-v] action [arguments ...]\nv0.0.4+79.gece0b23\n\nsyncing and linking for all your Minecraft instances\n\npositional arguments:\n  action         the action to perform. Options are:\n                    craft\n                        to create and configure a new EnderChest installation\n                    craft shulker_box\n                        to create and configure a new shulker box\n                    place\n                        to link (or update the links) from your instances to your EnderChest\n                    gather\n                        to register (or update the registry of) a Minecraft installation\n                    gather enderchests\n                        to register (or update the registry of) a remote EnderChest\n                    inventory\n                        to list the minecraft instances registered with your Enderchest\n                    inventory shulker_boxes\n                        to list the shulker boxes inside your Enderchest\n                    inventory shulker_box\n                        to list the instances that match the specified shulker box\n                    inventory enderchests\n                        to list the other EnderChest installations registered with this EnderChest\n                    open\n                        to pull changes from other EnderChests\n                    close\n                        to push changes to other EnderChests\n  arguments      any additional arguments for the specific action. To learn more, try: enderchest {action} -h\n\noptions:\n  -h, --help     show this help message and exit\n-v, --version  show program's version number and exit\n</code></pre>"},{"location":"cli/#enderchest-craft","title":"<code>enderchest craft</code>","text":"<pre><code>usage: enderchest craft [-h] [--root ROOT_FLAG] [--verbose] [--quiet] [--from COPY_FROM] [-r REMOTES] [-i INSTANCE_SEARCH_PATHS] [--overwrite] [root]\ncreate and configure a new EnderChest installation\n\npositional arguments:\n  root                  optionally specify your root minecraft directory. If no path is given, the current working directory will be used.\n\noptions:\n  -h, --help            show this help message and exit\n--root ROOT_FLAG      specify your root minecraft directory\n  --verbose, -v         increase the amount of information that's printed\n  --quiet, -q           decrease the amount of information that's printed\n  --from COPY_FROM      provide the URI (e.g. rsync://deck@my-steam-deck/home/deck/) of a remote EnderChest installation that can be used to boostrap the creation of this one.\n  -r REMOTES, --remote REMOTES\n                        provide the URI (e.g. rsync://deck@my-steam-deck/home/deck/) of a remote EnderChest installation to register with this one\n  -i INSTANCE_SEARCH_PATHS, --instance INSTANCE_SEARCH_PATHS\n                        specify a folder to search for Minecraft installations in\n--overwrite           if there's already an EnderChest installation in this location, overwrite its configuration\n</code></pre>"},{"location":"cli/#enderchest-craft-shulker_box","title":"<code>enderchest craft shulker_box</code>","text":"<pre><code>usage: enderchest craft shulker_box [-h] [--root ROOT_FLAG] [--verbose] [--quiet] [--priority PRIORITY] [-i INSTANCES] [-t TAGS] [-e HOSTS] [-l LINK_FOLDERS] [--overwrite] [root] name\n\ncreate and configure a new shulker box\n\npositional arguments:\n  root                  optionally specify your root minecraft directory. If no path is given, the current working directory will be used.\n  name                  specify the name for this shulker box\n\noptions:\n  -h, --help            show this help message and exit\n--root ROOT_FLAG      specify your root minecraft directory\n  --verbose, -v         increase the amount of information that's printed\n  --quiet, -q           decrease the amount of information that's printed\n  --priority PRIORITY, -p PRIORITY\n                        specify the link priority for this shulker box (higher = linked later)\n-i INSTANCES, --instance INSTANCES\n                        only link instances with one of the provided names to this shulker box\n  -t TAGS, --tag TAGS   only link instances with one of the provided tags to this shulker box\n  -e HOSTS, --enderchest HOSTS\n                        only link instances registered to one of the provided EnderChest installations with this shulker box\n  -l LINK_FOLDERS, --folder LINK_FOLDERS\n                        specify the name of a folder inside this shulker box that should be linked completely\n  --overwrite           if there's already a shulker box with the specified name, overwrite its configuration\n</code></pre>"},{"location":"cli/#enderchest-place","title":"<code>enderchest place</code>","text":"<pre><code>usage: enderchest place [-h] [--root ROOT_FLAG] [--verbose] [--quiet] [-k] [--stop-at-first-failure | --ignore-errors | --errors {prompt,ignore,skip,skip-instance,skip-shulker-box,abort}] [root]\nlink (or update the links) from your instances to your EnderChest\n\npositional arguments:\n  root                  optionally specify your root minecraft directory. If no path is given, the current working directory will be used.\n\noptions:\n  -h, --help            show this help message and exit\n--root ROOT_FLAG      specify your root minecraft directory\n  --verbose, -v         increase the amount of information that's printed\n  --quiet, -q           decrease the amount of information that's printed\n  -k, --keep-broken-links\n                        do not remove broken links from instances\n  --stop-at-first-failure, -x\n                        stop linking at the first issue\n  --ignore-errors       ignore any linking errors\n  --errors {prompt,ignore,skip,skip-instance,skip-shulker-box,abort}, -e {prompt,ignore,skip,skip-instance,skip-shulker-box,abort}\nspecify how to handle linking errors (default behavior is to prompt after every error)\n</code></pre>"},{"location":"cli/#enderchest-gather","title":"<code>enderchest gather</code>","text":"<pre><code>usage: enderchest gather [-h] [--root ROOT_FLAG] [--verbose] [--quiet] [--official | --mmc] [root] search_paths [search_paths ...]\nregister (or update the registry of) a Minecraft installation\n\npositional arguments:\n  root              optionally specify your root minecraft directory. If no path is given, the current working directory will be used.\n  search_paths      specify a folder or folders to search for Minecraft installations\n\noptions:\n  -h, --help        show this help message and exit\n--root ROOT_FLAG  specify your root minecraft directory\n  --verbose, -v     increase the amount of information that's printed\n  --quiet, -q       decrease the amount of information that's printed\n  --official, -o    specify that these are instances managed by the official launcher\n  --mmc, -m         specify that these are MultiMC-like instances\n</code></pre>"},{"location":"cli/#enderchest-gather-enderchests","title":"<code>enderchest gather enderchests</code>","text":"<pre><code>usage: enderchest gather enderchests [-h] [--root ROOT_FLAG] [--verbose] [--quiet] [root] remotes [remotes ...]\nregister (or update the registry of) a remote EnderChest\n\npositional arguments:\n  root              optionally specify your root minecraft directory. If no path is given, the current working directory will be used.\n  remotes           provide URIs (e.g. rsync://deck@my-steam-deck/home/deck/) of any remote EnderChest installation to register with this one.Note: you should not use this method if the alias (name) of theremote does not match the remote's hostname (in this example,\"my-steam-deck\").\noptions:\n  -h, --help        show this help message and exit\n  --root ROOT_FLAG  specify your root minecraft directory\n  --verbose, -v     increase the amount of information that's printed\n  --quiet, -q       decrease the amount of information that's printed\n</code></pre>"},{"location":"cli/#enderchest-inventory","title":"<code>enderchest inventory</code>","text":"<pre><code>usage: enderchest inventory [-h] [--root ROOT_FLAG] [--verbose] [--quiet] [root]\nlist the minecraft instances registered with your Enderchest\n\npositional arguments:\n  root              optionally specify your root minecraft directory. If no path is given, the current working directory will be used.\n\noptions:\n  -h, --help        show this help message and exit\n--root ROOT_FLAG  specify your root minecraft directory\n  --verbose, -v     increase the amount of information that's printed\n  --quiet, -q       decrease the amount of information that's printed\n</code></pre>"},{"location":"cli/#enderchest-inventory-shulker_boxes","title":"<code>enderchest inventory shulker_boxes</code>","text":"<pre><code>usage: enderchest inventory shulker_boxes [-h] [--root ROOT_FLAG] [--verbose] [--quiet] [root]\nlist the shulker boxes inside your Enderchest\n\npositional arguments:\n  root              optionally specify your root minecraft directory. If no path is given, the current working directory will be used.\n\noptions:\n  -h, --help        show this help message and exit\n--root ROOT_FLAG  specify your root minecraft directory\n  --verbose, -v     increase the amount of information that's printed\n  --quiet, -q       decrease the amount of information that's printed\n</code></pre>"},{"location":"cli/#enderchest-inventory-shulker_box","title":"<code>enderchest inventory shulker_box</code>","text":"<pre><code>usage: enderchest inventory shulker_box [-h] [--root ROOT_FLAG] [--verbose] [--quiet] [root] shulker_box_name\n\nlist the instances that match the specified shulker box\n\npositional arguments:\n  root              optionally specify your root minecraft directory. If no path is given, the current working directory will be used.\n  shulker_box_name  The name of the shulker box to query\n\noptions:\n  -h, --help        show this help message and exit\n--root ROOT_FLAG  specify your root minecraft directory\n  --verbose, -v     increase the amount of information that's printed\n  --quiet, -q       decrease the amount of information that's printed\n</code></pre>"},{"location":"cli/#enderchest-inventory-enderchests","title":"<code>enderchest inventory enderchests</code>","text":"<pre><code>usage: enderchest inventory enderchests [-h] [--root ROOT_FLAG] [--verbose] [--quiet] [root]\nlist the other EnderChest installations registered with this EnderChest\n\npositional arguments:\n  root              optionally specify your root minecraft directory. If no path is given, the current working directory will be used.\n\noptions:\n  -h, --help        show this help message and exit\n--root ROOT_FLAG  specify your root minecraft directory\n  --verbose, -v     increase the amount of information that's printed\n  --quiet, -q       decrease the amount of information that's printed\n</code></pre>"},{"location":"cli/#enderchest-open","title":"<code>enderchest open</code>","text":"<pre><code>usage: enderchest open [-h] [--root ROOT_FLAG] [--verbose] [--quiet] [root]\npull changes from other EnderChests\n\npositional arguments:\n  root              optionally specify your root minecraft directory. If no path is given, the current working directory will be used.\n\noptions:\n  -h, --help        show this help message and exit\n--root ROOT_FLAG  specify your root minecraft directory\n  --verbose, -v     increase the amount of information that's printed\n  --quiet, -q       decrease the amount of information that's printed\n</code></pre>"},{"location":"cli/#enderchest-close","title":"<code>enderchest close</code>","text":"<pre><code>usage: enderchest close [-h] [--root ROOT_FLAG] [--verbose] [--quiet] [root]\npush changes to other EnderChests\n\npositional arguments:\n  root              optionally specify your root minecraft directory. If no path is given, the current working directory will be used.\n\noptions:\n  -h, --help        show this help message and exit\n--root ROOT_FLAG  specify your root minecraft directory\n  --verbose, -v     increase the amount of information that's printed\n  --quiet, -q       decrease the amount of information that's printed\n</code></pre>"},{"location":"contrib/","title":"Contribution Guide","text":"<p>EnderChest is an open source project, and its source code is publicly available on GitHub.</p> <p>Please open a new issue to report a bug or to propose a new feature or enhancement.</p> <p>If you would like to contribute your own bugfixes or code enhancements, start by forking this repo, and cloning it into your local workspace.</p> <p>(Note that all work should be done off of the <code>dev</code> branch.)</p> <p>I highly recommend using a conda-forge-based Python distribution for development and virtual environment management.</p> <p>With your distribution of choice installed and configured, navigate to the root of the EnderChest project and then:</p> <ol> <li>Create the development environment via    <pre><code>mamba env create\n</code></pre>    (substitute <code>conda</code> if you so choose)</li> <li>Install the package in editable mode:    <pre><code>python -m pip install --user -e .[test]\n</code></pre></li> <li>Set up pre-commit:    <pre><code>pre-commit install\n</code></pre></li> </ol> <p>Once that's done, start developing! Pre-commit is a fanstastic tool that will take care of most style-guide enforcement for you.</p> <p>Note that EnderChest strongly leverages type-hinting.</p>"},{"location":"contrib/#opening-a-pr","title":"Opening a PR","text":"<p>Once you're ready to contribute your code change back, open a PR (remember to target the <code>dev</code> branch) and tag @OpenBagTwo for review.</p>"},{"location":"contrib/#license","title":"License","text":"<p>This project--the executable, source code and all documentation are published under the GNU Public License v3, and any contributions to or derivatives of this project must be licensed under compatible terms.</p>"},{"location":"installation/","title":"Installation","text":"<p>EnderChest has minimal package dependencies and should run on pretty much any computer or operating system. It does require Python 3.11 or greater, portable distributions (read: no need for admin privileges)  of which are available through miniconda and mambaforge.</p> <p>Once you have python installed,</p> <ol> <li> <p>Open a terminal and create a new virtual environment via:    <pre><code>mamba create -n enderchest \"python&gt;=3.11\" \"pip&gt;22\"\n</code></pre>    (substitute <code>conda</code> for <code>mamba</code> as needed)</p> </li> <li> <p>Activate your new environment:     <pre><code>conda activate enderchest\n</code></pre></p> </li> <li> <p>Install <code>enderchest</code> from GitHub using pip:     <pre><code>python -m pip install --user git+https://github.com/OpenBagTwo/EnderChest.git@release#egg=enderchest[test]\n</code></pre></p> </li> <li> <p>Ensure that EnderChest is compatible with your system by running:     <pre><code>pytest --pyargs enderchest\n</code></pre></p> <p>If all tests pass, then you're good to go!</p> </li> <li> <p>If you'd like <code>enderchest</code> to be available outside of your virtual environment,    you can copy the executable to somewhere within your system path, e.g. for    Linux, starting with the virtual environment deactivated:    <pre><code>$ echo $PATH\n/home/openbagtwo/.mambaforge/condabin:/home/openbagtwo/.local/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/sbin\n$ conda activate enderchest\n$ which enderchest\n/home/openbagtwo/.mambaforge/envs/enderchest/bin/enderchest\n$ cp /home/openbagtwo/.mambaforge/envs/enderchest/bin/enderchest ~/.local/bin/\n</code></pre></p> </li> </ol>"},{"location":"installation/#bleeding-edge","title":"Bleeding Edge","text":"<p>If you'd like to test out upcoming features or help with beta testing, you can install from the current development branch via:</p> <pre><code>$ python -m pip install --user git+https://github.com/OpenBagTwo/EnderChest.git@dev#egg=enderchest[test]\n</code></pre> <p>Be warned that any code on this branch is considered highly experimental. As always, make sure to regularly back up any important data you're managing with this tool.</p>"},{"location":"suggestions/","title":"Best Practices and Suggested Workflows","text":"<p>Coming Soon!</p>"},{"location":"suggestions/#collisions-and-conflicts","title":"Collisions and Conflicts","text":"<p>TODO</p>"},{"location":"suggestions/#managing-backups","title":"Managing Backups","text":"<p>TODO</p>"},{"location":"suggestions/#integration-with-auto-update-tools","title":"Integration with Auto-Update Tools","text":""},{"location":"suggestions/#startup-and-shutdown-scripts","title":"Startup and Shutdown Scripts","text":"<p>Launchers like PrismLauncher can be configured to run commands before an  instance is launched or after it's closed. Consider putting <code>enderchest open /path/to/minecraft_root</code> in your startup scripts and <code>enderchest close /path/to/minecraft_root</code> in your shutdown scripts (where \"minecraft_root\" is the location where you usually run the enderchest commands, i.e. the parent of your EnderChest folder.</p>"},{"location":"usage/","title":"Quick-Start Guide","text":"<p>This is a brief guide to getting an EnderChest set up and linking. It covers the most important command-line operations and how to make best use of shulker boxes.</p>"},{"location":"usage/#locating-your-minecraft-instances","title":"Locating Your Minecraft Instances","text":"<p>Before setting up an EnderChest, it's a good idea to take a minute and figure out where all of your Minecraft data is actually stored. This will vary based on your operating system and the launchers you use. This document, for example, tells you how to find the official launcher data. MultiMC-derived programs like PrismLauncher will often have a \"Folder\" button that will take you to the location of each instance, which is especially helpful for the flatpak distribution.</p>"},{"location":"usage/#selecting-a-minecraft-root","title":"Selecting a \"Minecraft Root\"","text":"<p>Once you have the lay of the land, the next thing you'll want to do is decide where you want your EnderChest folder to live. This could be your home folder (<code>~</code> or <code>C:\\Users\\yourusername\\</code>, in the folder containing your MultiMC <code>instances</code> directory, or anywhere that's convenient for you. Go to that directory in your terminal.</p> <p>Tip</p> <p>You can run any EnderChest command from any location by explicitly specifying the Minecraft root, e.g. <pre><code>enderchest craft --root /path/to/my_minecraft_stuff\n</code></pre></p>"},{"location":"usage/#creating-an-enderchest","title":"Creating an EnderChest","text":"<p>When ready, run the command:</p> <pre><code>enderchest craft\n</code></pre> <p>to begin the guided setup process. This process will ask you about directories to look for Minecraft installations inside. Note that these will be the folders containing <code>.minecraft</code>, not the <code>.minecraft</code> folders themselves.</p> <p>You'll also be prompted for the address of another EnderChest installation you want to sync with. For now, I'll assume that this is your first EnderChest, so leave that answer blank. When you're ready to create another EnderChest on another machine, the Managing Remotes section will have you covered.</p> <p>Once the installer finishes, you'll end up with a new folder inside your current directory (or Minecraft root) named EnderChest along with a file inside that folder named <code>enderchest.cfg</code>. Feel free to open up that file in your favorite text editor and take a look. It's designed to be easily edited to make it easy to, for example, manually add a tag to an instance.</p> <p>Info</p> <p>When a given entry can have multiple values, you can separate those values by commas, e.g. <pre><code>tags = vanilla_plus, modded, sodium\n</code></pre> or by putting each entry on its own (indented) line, e.g. <pre><code>tags =\naether\nmodded\noptifine\n</code></pre></p>"},{"location":"usage/#registering-additional-instances","title":"Registering Additional Instances","text":"<p>Once you have an EnderChest installed, you can register additional instances at any time by using the <code>gather</code> action. Running:</p> <pre><code>enderchest gather &lt;path&gt;\n</code></pre> <p>will recursively search the provided directory for folders named <code>.minecraft</code> and attempt to register them.</p> <p>Tip</p> <p>You can control how much information gets displayed when running EnderChest commands by using the <code>--verbose</code> (<code>-v</code>) and <code>--quiet</code> (<code>-q</code>) flags.</p>"},{"location":"usage/#creating-shulker-boxes","title":"Creating Shulker Boxes","text":"<p>Once you've populated your EnderChest configuration with all the Minecraft instances you want to manage, it's time to start crafting shulker boxes.</p> <p>Running:</p> <pre><code>enderchest craft shulker_box\n</code></pre> <p>will take you through a guided setup that will let to control how your shulker box will know which instances will link to it along with what other remote EnderChest installations will use it. At the conclusion of the process you'll end up with a folder within your EnderChest that's pre-populated so as to mirror what you'd see in a <code>.minecraft</code> folder.</p>"},{"location":"usage/#moving-files-into-your-shulker-box","title":"Moving Files into Your Shulker Box","text":"<p>If you have existing Minecraft installations, now is the time to start moving the assets from those instances into your shulker box. Just put them in the exact same place inside the shulker box that they'd be inside of <code>.minecraft</code> (so resource packs go in <code>resourcepacks</code>, worlds go in <code>saves</code>, etc.)</p>"},{"location":"usage/#linking-entire-folders","title":"Linking Entire Folders","text":"<p>During the shulker box creation process, you were prompted to select any folders that you wanted to symlink whole-hog. This is useful for things like screenshots or logs where files will be generated by the instance and not just accessed or updated.</p> <p>Important!</p> <p>By default, for the purposes of linking EnderChest treats any folder that's not at the top level (e.g. <code>saves/my world</code>) as a file that's symlinked in its entirety. You can change this behavior by setting the <code>max-link-depth</code> parameter in the shulker box config, but doing so should be considered highly experimental.</p>"},{"location":"usage/#managing-remotes","title":"Managing Remotes","text":"<p>TODO</p>"},{"location":"usage/#syncing","title":"Syncing","text":"<p>TODO</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>enderchest<ul> <li>cli</li> <li>enderchest</li> <li>gather</li> <li>craft</li> <li>instance</li> <li>filesystem</li> <li>loggers</li> <li>shulker_box</li> <li>prompt</li> <li>place</li> <li>sync</li> <li>remote</li> </ul> </li> </ul>"},{"location":"reference/enderchest/","title":"enderchest","text":""},{"location":"reference/enderchest/#enderchest.EnderChest","title":"<code>EnderChest</code>  <code>dataclass</code>","text":"<p>Configuration of an EnderChest</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>URI or Path</code> <p>The \"address\" of this EnderChest, ideally as it can be accessed from other EnderChest installations, including both the path to where the EnderChest folder can be found (that is, the parent of the EnderChest folder itself, aka the \"minecraft_root\"), its net location including credentials, and the protocol that should be used to perform the syncing. All that being said, if just a path is provided, the constructor will try to figure out the rest.</p> required <code>name</code> <code>str, optional</code> <p>A unique name to give to this EnderChest installation. If None is provided, this will be taken from the hostname of the supplied URI.</p> <code>None</code> <code>instances</code> <code>list-like of InstanceSpec, optional</code> <p>The list of instances to register with this EnderChest installation</p> <code>None</code> <code>remotes</code> <code>list-like of URI, or (URI, str) tuples</code> <p>A list of other installations that this EnderChest should be aware of (for syncing purposes). When a (URI, str) tuple is provided, the second value will be used as the name/alias of the remote.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The unique name of this EnderChest installation. This is most commonly the computer's hostname, but one can configure multiple EnderChests to coexist on the same system (either for the sake of having a \"cold\" backup or for multi-user systems).</p> <code>uri</code> <code>str</code> <p>The complete URI of this instance</p> <code>root</code> <code>Path</code> <p>The path to this EnderChest folder</p> <code>instances</code> <code>list-like of InstanceSpec</code> <p>The instances registered with this EnderChest</p> <code>remotes</code> <code>list-like of (ParseResult, str) pairs</code> <p>The other EnderChest installations this EnderChest is aware of, paired with their aliases</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>@dataclass(init=False, repr=False)\nclass EnderChest:\n\"\"\"Configuration of an EnderChest\n    Parameters\n    ----------\n    uri : URI or Path\n        The \"address\" of this EnderChest, ideally as it can be accessed from other\n        EnderChest installations, including both the path to where\n        the EnderChest folder can be found (that is, the parent of the\n        EnderChest folder itself, aka the \"minecraft_root\"), its net location\n        including credentials, and the protocol that should be used to perform\n        the syncing. All that being said, if just a path is provided, the\n        constructor will try to figure out the rest.\n    name : str, optional\n        A unique name to give to this EnderChest installation. If None is\n        provided, this will be taken from the hostname of the supplied URI.\n    instances : list-like of InstanceSpec, optional\n        The list of instances to register with this EnderChest installation\n    remotes : list-like of URI, or (URI, str) tuples\n        A list of other installations that this EnderChest should be aware of\n        (for syncing purposes). When a (URI, str) tuple is provided, the\n        second value will be used as the name/alias of the remote.\n    Attributes\n    ----------\n    name : str\n        The unique name of this EnderChest installation. This is most commonly\n        the computer's hostname, but one can configure multiple EnderChests\n        to coexist on the same system (either for the sake of having a \"cold\"\n        backup or for multi-user systems).\n    uri : str\n        The complete URI of this instance\n    root : Path\n        The path to this EnderChest folder\n    instances : list-like of InstanceSpec\n        The instances registered with this EnderChest\n    remotes : list-like of (ParseResult, str) pairs\n        The other EnderChest installations this EnderChest is aware of, paired\n        with their aliases\n    \"\"\"\nname: str\n_uri: ParseResult\n_instances: list[i.InstanceSpec]\n_remotes: dict[str, ParseResult]\ndef __init__(\nself,\nuri: str | ParseResult | Path,\nname: str | None = None,\nremotes: Iterable[str | ParseResult | tuple[str, str] | tuple[ParseResult, str]]\n| None = None,\ninstances: Iterable[i.InstanceSpec] | None = None,\n):\ntry:\nif isinstance(uri, ParseResult):\nself._uri = uri\nelif isinstance(uri, Path):\nself._uri = urlparse(uri.absolute().as_uri())\nelse:\nself._uri = urlparse(uri)\nexcept AttributeError as parse_problem:\nraise ValueError(f\"{uri} is not a valid URI\") from parse_problem\nif not self._uri.netloc:\nself._uri = self._uri._replace(netloc=sync.get_default_netloc())\nif not self._uri.scheme:\nself._uri = self._uri._replace(scheme=sync.DEFAULT_PROTOCOL)\nself.name = name or self._uri.hostname or gethostname()\nself._instances = []\nself._remotes = {}\nfor instance in instances or ():\nself.register_instance(instance)\nfor remote in remotes or ():\nif isinstance(remote, (str, ParseResult)):\nself.register_remote(remote)\nelse:\nself.register_remote(*remote)\n@property\ndef uri(self) -&gt; str:\nreturn self._uri.geturl()\ndef __repr__(self) -&gt; str:\nreturn f\"EnderChest({self.uri, self.name})\"\n@property\ndef root(self) -&gt; Path:\nreturn fs.ender_chest_folder(Path(self._uri.path))\n@property\ndef instances(self) -&gt; tuple[i.InstanceSpec, ...]:\nreturn tuple(self._instances)\ndef register_instance(self, instance: i.InstanceSpec) -&gt; i.InstanceSpec:\n\"\"\"Register a new Minecraft installation\n        Parameters\n        ----------\n        instance : InstanceSpec\n            The instance to register\n        Returns\n        -------\n        InstanceSpec\n            The spec of the instance as it was actually registered (in case the\n            name changed or somesuch)\n        Notes\n        -----\n        - If the instance's name is already assigned to a registered instance,\n          this method will choose a new one\n        - If this instance shares a path with an existing instance, it will\n          replace that instance\n        \"\"\"\nself._instances = [\nold_instance\nfor old_instance in self._instances\nif not i.equals(Path(self._uri.path), instance, old_instance)\n]\nname = instance.name\ncounter = 0\ntaken_names = {old_instance.name for old_instance in self._instances}\nwhile True:\nif name not in taken_names:\nbreak\ncounter += 1\nname = f\"{instance.name}.{counter}\"\nGATHER_LOGGER.debug(f\"Registering instance {instance.name} at {instance.root}\")\nself._instances.append(instance._replace(name=name))\nreturn self._instances[-1]\n@property\ndef remotes(self) -&gt; tuple[tuple[ParseResult, str], ...]:\nreturn tuple((remote, alias) for alias, remote in self._remotes.items())\ndef register_remote(\nself, remote: str | ParseResult, alias: str | None = None\n) -&gt; None:\n\"\"\"Register a new remote EnderChest installation (or update an existing\n        registry)\n        Parameters\n        ----------\n        remote : URI\n            The URI of the remote\n        alias : str, optional\n            an alias to give to this remote. If None is provided, the URI's hostname\n            will be used.\n        Raises\n        ------\n        ValueError\n            If the provided remote is invalid\n        \"\"\"\ntry:\nremote = remote if isinstance(remote, ParseResult) else urlparse(remote)\nalias = alias or remote.hostname\nif not alias:\nraise AttributeError(f\"{remote.geturl()} has no hostname\")\nGATHER_LOGGER.debug(f\"Registering remote {remote.geturl()} ({alias})\")\nself._remotes[alias] = remote\nexcept AttributeError as parse_problem:\nraise ValueError(f\"{remote} is not a valid URI\") from parse_problem\n@classmethod\ndef from_cfg(cls, config_file: Path) -&gt; \"EnderChest\":\n\"\"\"Parse an EnderChest from its config file\n        Parameters\n        ----------\n        config_file : Path\n            The path to the config file\n        Returns\n        -------\n        EnderChest\n            The resulting EnderChest\n        Raises\n        ------\n        ValueError\n            If the config file at that location cannot be parsed\n        FileNotFoundError\n            If there is no config file at the specified location\n        \"\"\"\nparser = ConfigParser(\nallow_no_value=True, delimiters=(\"=\",), inline_comment_prefixes=(\";\",)\n)\ntry:\nassert parser.read(config_file)\nexcept ParsingError as bad_cfg:\nraise ValueError(f\"Could not parse {config_file}\") from bad_cfg\nexcept AssertionError:\nraise FileNotFoundError(f\"Could not open {config_file}\")\n# All I'm gonna say is that Windows pathing is the worst\npath = urlparse(config_file.absolute().parent.parent.as_uri()).path\ninstances: list[i.InstanceSpec] = []\nremotes: list[str | tuple[str, str]] = []\nscheme: str | None = None\nnetloc: str | None = None\nname: str | None = None\nfor section in parser.sections():\nif section == \"properties\":\nscheme = parser[section].get(\"sync-protocol\")\nnetloc = parser[section].get(\"address\")\nname = parser[section].get(\"name\")\nelif section == \"remotes\":\nfor remote in parser[section].items():\nif remote[1] is None:\nremotes.append(remote[0])\nelse:\nremotes.append((remote[1], remote[0]))\nelse:\ninstances.append(i.InstanceSpec.from_cfg(parser[section]))\nscheme = scheme or sync.DEFAULT_PROTOCOL\nnetloc = netloc or sync.get_default_netloc()\nuri = ParseResult(\nscheme=scheme, netloc=netloc, path=path, params=\"\", query=\"\", fragment=\"\"\n)\nreturn EnderChest(uri, name, remotes, instances)\ndef write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n\"\"\"Write this EnderChest's configuration to INI\n        Parameters\n        ----------\n        config_file : Path, optional\n            The path to the config file, assuming you'd like to write the\n            contents to file\n        Returns\n        -------\n        str\n            An INI-syntax rendering of this EnderChest's config\n        Notes\n        -----\n        The \"root\" attribute is ignored for this method\n        \"\"\"\nconfig = ConfigParser(allow_no_value=True)\nconfig.add_section(\"properties\")\nconfig.set(\"properties\", \"name\", self.name)\nconfig.set(\"properties\", \"address\", self._uri.netloc)\nconfig.set(\"properties\", \"sync-protocol\", self._uri.scheme)\nconfig.set(\"properties\", \"last_modified\", dt.datetime.now().isoformat(sep=\" \"))\nconfig.set(\n\"properties\", \"generated_by_enderchest_version\", get_versions()[\"version\"]\n)\nconfig.add_section(\"remotes\")\nfor uri, name in self.remotes:\nif name != uri.hostname:\nconfig.set(\"remotes\", name, uri.geturl())\nelse:\nconfig.set(\"remotes\", uri.geturl())\nfor instance in self.instances:\nconfig.add_section(instance.name)\nconfig.set(instance.name, \"root\", str(instance.root))\nconfig.set(\ninstance.name,\n\"minecraft_version\",\n_list_to_ini(instance.minecraft_versions),\n)\nconfig.set(instance.name, \"modloader\", instance.modloader)\nconfig.set(\ninstance.name,\n\"tags\",\n_list_to_ini(instance.tags),\n)\nbuffer = StringIO()\nbuffer.write(f\"; {fs.ENDER_CHEST_CONFIG_NAME}\\n\")\nconfig.write(buffer)\nbuffer.seek(0)  # rewind\nif config_file:\nconfig_file.write_text(buffer.read())\nbuffer.seek(0)\nreturn buffer.read()\n</code></pre>"},{"location":"reference/enderchest/#enderchest.enderchest.EnderChest.from_cfg","title":"<code>from_cfg(config_file)</code>  <code>classmethod</code>","text":"<p>Parse an EnderChest from its config file</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path</code> <p>The path to the config file</p> required <p>Returns:</p> Type Description <code>EnderChest</code> <p>The resulting EnderChest</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the config file at that location cannot be parsed</p> <code>FileNotFoundError</code> <p>If there is no config file at the specified location</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>@classmethod\ndef from_cfg(cls, config_file: Path) -&gt; \"EnderChest\":\n\"\"\"Parse an EnderChest from its config file\n    Parameters\n    ----------\n    config_file : Path\n        The path to the config file\n    Returns\n    -------\n    EnderChest\n        The resulting EnderChest\n    Raises\n    ------\n    ValueError\n        If the config file at that location cannot be parsed\n    FileNotFoundError\n        If there is no config file at the specified location\n    \"\"\"\nparser = ConfigParser(\nallow_no_value=True, delimiters=(\"=\",), inline_comment_prefixes=(\";\",)\n)\ntry:\nassert parser.read(config_file)\nexcept ParsingError as bad_cfg:\nraise ValueError(f\"Could not parse {config_file}\") from bad_cfg\nexcept AssertionError:\nraise FileNotFoundError(f\"Could not open {config_file}\")\n# All I'm gonna say is that Windows pathing is the worst\npath = urlparse(config_file.absolute().parent.parent.as_uri()).path\ninstances: list[i.InstanceSpec] = []\nremotes: list[str | tuple[str, str]] = []\nscheme: str | None = None\nnetloc: str | None = None\nname: str | None = None\nfor section in parser.sections():\nif section == \"properties\":\nscheme = parser[section].get(\"sync-protocol\")\nnetloc = parser[section].get(\"address\")\nname = parser[section].get(\"name\")\nelif section == \"remotes\":\nfor remote in parser[section].items():\nif remote[1] is None:\nremotes.append(remote[0])\nelse:\nremotes.append((remote[1], remote[0]))\nelse:\ninstances.append(i.InstanceSpec.from_cfg(parser[section]))\nscheme = scheme or sync.DEFAULT_PROTOCOL\nnetloc = netloc or sync.get_default_netloc()\nuri = ParseResult(\nscheme=scheme, netloc=netloc, path=path, params=\"\", query=\"\", fragment=\"\"\n)\nreturn EnderChest(uri, name, remotes, instances)\n</code></pre>"},{"location":"reference/enderchest/#enderchest.enderchest.EnderChest.register_instance","title":"<code>register_instance(instance)</code>","text":"<p>Register a new Minecraft installation</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>InstanceSpec</code> <p>The instance to register</p> required <p>Returns:</p> Type Description <code>InstanceSpec</code> <p>The spec of the instance as it was actually registered (in case the name changed or somesuch)</p>"},{"location":"reference/enderchest/#enderchest.enderchest.EnderChest.register_instance--notes","title":"Notes","text":"<ul> <li>If the instance's name is already assigned to a registered instance,   this method will choose a new one</li> <li>If this instance shares a path with an existing instance, it will   replace that instance</li> </ul> Source code in <code>enderchest/enderchest.py</code> <pre><code>def register_instance(self, instance: i.InstanceSpec) -&gt; i.InstanceSpec:\n\"\"\"Register a new Minecraft installation\n    Parameters\n    ----------\n    instance : InstanceSpec\n        The instance to register\n    Returns\n    -------\n    InstanceSpec\n        The spec of the instance as it was actually registered (in case the\n        name changed or somesuch)\n    Notes\n    -----\n    - If the instance's name is already assigned to a registered instance,\n      this method will choose a new one\n    - If this instance shares a path with an existing instance, it will\n      replace that instance\n    \"\"\"\nself._instances = [\nold_instance\nfor old_instance in self._instances\nif not i.equals(Path(self._uri.path), instance, old_instance)\n]\nname = instance.name\ncounter = 0\ntaken_names = {old_instance.name for old_instance in self._instances}\nwhile True:\nif name not in taken_names:\nbreak\ncounter += 1\nname = f\"{instance.name}.{counter}\"\nGATHER_LOGGER.debug(f\"Registering instance {instance.name} at {instance.root}\")\nself._instances.append(instance._replace(name=name))\nreturn self._instances[-1]\n</code></pre>"},{"location":"reference/enderchest/#enderchest.enderchest.EnderChest.register_remote","title":"<code>register_remote(remote, alias=None)</code>","text":"<p>Register a new remote EnderChest installation (or update an existing registry)</p> <p>Parameters:</p> Name Type Description Default <code>remote</code> <code>URI</code> <p>The URI of the remote</p> required <code>alias</code> <code>str, optional</code> <p>an alias to give to this remote. If None is provided, the URI's hostname will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided remote is invalid</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>def register_remote(\nself, remote: str | ParseResult, alias: str | None = None\n) -&gt; None:\n\"\"\"Register a new remote EnderChest installation (or update an existing\n    registry)\n    Parameters\n    ----------\n    remote : URI\n        The URI of the remote\n    alias : str, optional\n        an alias to give to this remote. If None is provided, the URI's hostname\n        will be used.\n    Raises\n    ------\n    ValueError\n        If the provided remote is invalid\n    \"\"\"\ntry:\nremote = remote if isinstance(remote, ParseResult) else urlparse(remote)\nalias = alias or remote.hostname\nif not alias:\nraise AttributeError(f\"{remote.geturl()} has no hostname\")\nGATHER_LOGGER.debug(f\"Registering remote {remote.geturl()} ({alias})\")\nself._remotes[alias] = remote\nexcept AttributeError as parse_problem:\nraise ValueError(f\"{remote} is not a valid URI\") from parse_problem\n</code></pre>"},{"location":"reference/enderchest/#enderchest.enderchest.EnderChest.write_to_cfg","title":"<code>write_to_cfg(config_file=None)</code>","text":"<p>Write this EnderChest's configuration to INI</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path, optional</code> <p>The path to the config file, assuming you'd like to write the contents to file</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>An INI-syntax rendering of this EnderChest's config</p>"},{"location":"reference/enderchest/#enderchest.enderchest.EnderChest.write_to_cfg--notes","title":"Notes","text":"<p>The \"root\" attribute is ignored for this method</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>def write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n\"\"\"Write this EnderChest's configuration to INI\n    Parameters\n    ----------\n    config_file : Path, optional\n        The path to the config file, assuming you'd like to write the\n        contents to file\n    Returns\n    -------\n    str\n        An INI-syntax rendering of this EnderChest's config\n    Notes\n    -----\n    The \"root\" attribute is ignored for this method\n    \"\"\"\nconfig = ConfigParser(allow_no_value=True)\nconfig.add_section(\"properties\")\nconfig.set(\"properties\", \"name\", self.name)\nconfig.set(\"properties\", \"address\", self._uri.netloc)\nconfig.set(\"properties\", \"sync-protocol\", self._uri.scheme)\nconfig.set(\"properties\", \"last_modified\", dt.datetime.now().isoformat(sep=\" \"))\nconfig.set(\n\"properties\", \"generated_by_enderchest_version\", get_versions()[\"version\"]\n)\nconfig.add_section(\"remotes\")\nfor uri, name in self.remotes:\nif name != uri.hostname:\nconfig.set(\"remotes\", name, uri.geturl())\nelse:\nconfig.set(\"remotes\", uri.geturl())\nfor instance in self.instances:\nconfig.add_section(instance.name)\nconfig.set(instance.name, \"root\", str(instance.root))\nconfig.set(\ninstance.name,\n\"minecraft_version\",\n_list_to_ini(instance.minecraft_versions),\n)\nconfig.set(instance.name, \"modloader\", instance.modloader)\nconfig.set(\ninstance.name,\n\"tags\",\n_list_to_ini(instance.tags),\n)\nbuffer = StringIO()\nbuffer.write(f\"; {fs.ENDER_CHEST_CONFIG_NAME}\\n\")\nconfig.write(buffer)\nbuffer.seek(0)  # rewind\nif config_file:\nconfig_file.write_text(buffer.read())\nbuffer.seek(0)\nreturn buffer.read()\n</code></pre>"},{"location":"reference/enderchest/#enderchest.InstanceSpec","title":"<code>InstanceSpec</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Specification of a Minecraft instance</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The \"display name\" for the instance</p> required <code>root</code> <code>Path</code> <p>The path to its \".minecraft\" folder</p> required <code>minecraft_versions</code> <code>list-like of str</code> <p>The minecraft versions of this instance. This is typically a 1-tuple, but some loaders (such as the official one) will just comingle all your assets together across all profiles</p> required <code>modloader</code> <code>str or None</code> <p>The (display) name of the modloader, or None if this is a vanilla instance</p> required <code>tags</code> <code>list-like of str</code> <p>The tags assigned to this instance</p> required Source code in <code>enderchest/instance.py</code> <pre><code>class InstanceSpec(NamedTuple):\n\"\"\"Specification of a Minecraft instance\n    Parameters\n    ----------\n    name : str\n        The \"display name\" for the instance\n    root : Path\n        The path to its \".minecraft\" folder\n    minecraft_versions : list-like of str\n        The minecraft versions of this instance. This is typically a 1-tuple,\n        but some loaders (such as the official one) will just comingle all\n        your assets together across all profiles\n    modloader : str or None\n        The (display) name of the modloader, or None if this is a vanilla\n        instance\n    tags : list-like of str\n        The tags assigned to this instance\n    \"\"\"\nname: str\nroot: Path\nminecraft_versions: tuple[str, ...]\nmodloader: str | None\ntags: tuple[str, ...]\n@classmethod\ndef from_cfg(cls, section: SectionProxy) -&gt; \"InstanceSpec\":\n\"\"\"Parse an instance spec as read in from the enderchest config file\n        Parameters\n        ----------\n        section : dict-like of str to str\n            The section in the enderchest config as parsed by a ConfigParser\n        Returns\n        -------\n        InstanceSpec\n            The resulting InstanceSpec\n        Raises\n        ------\n        KeyError\n            If a required key is absent\n        ValueError\n            If a required entry cannot be parsed\n        \"\"\"\nreturn cls(\nsection.name,\nPath(section[\"root\"]),\ntuple(section[\"minecraft_version\"].strip().split()),\nsection.get(\"modloader\", None),\ntuple(\ntag.strip()\nfor tag in section.get(\"tags\", \"\")\n.replace(\",\", \"\\n\")\n.strip()\n.split(\"\\n\")\n),\n)\n</code></pre>"},{"location":"reference/enderchest/#enderchest.instance.InstanceSpec.from_cfg","title":"<code>from_cfg(section)</code>  <code>classmethod</code>","text":"<p>Parse an instance spec as read in from the enderchest config file</p> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>dict-like of str to str</code> <p>The section in the enderchest config as parsed by a ConfigParser</p> required <p>Returns:</p> Type Description <code>InstanceSpec</code> <p>The resulting InstanceSpec</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If a required key is absent</p> <code>ValueError</code> <p>If a required entry cannot be parsed</p> Source code in <code>enderchest/instance.py</code> <pre><code>@classmethod\ndef from_cfg(cls, section: SectionProxy) -&gt; \"InstanceSpec\":\n\"\"\"Parse an instance spec as read in from the enderchest config file\n    Parameters\n    ----------\n    section : dict-like of str to str\n        The section in the enderchest config as parsed by a ConfigParser\n    Returns\n    -------\n    InstanceSpec\n        The resulting InstanceSpec\n    Raises\n    ------\n    KeyError\n        If a required key is absent\n    ValueError\n        If a required entry cannot be parsed\n    \"\"\"\nreturn cls(\nsection.name,\nPath(section[\"root\"]),\ntuple(section[\"minecraft_version\"].strip().split()),\nsection.get(\"modloader\", None),\ntuple(\ntag.strip()\nfor tag in section.get(\"tags\", \"\")\n.replace(\",\", \"\\n\")\n.strip()\n.split(\"\\n\")\n),\n)\n</code></pre>"},{"location":"reference/enderchest/#enderchest.ShulkerBox","title":"<code>ShulkerBox</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Specification of a ShulkerBox</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>The priority for linking assets in the shulker box (higher priority shulkers are linked last)</p> required <code>name</code> <code>str</code> <p>The name of the shulker box (which is incidetentally used to break priority ties)</p> required <code>root</code> <code>Path</code> <p>The path to the root of the shulker box</p> required <code>match_criteria</code> <code>list-like of tuples</code> <p>The parameters for matching instances to this shulker box. Each element consists of:</p> <ul> <li>the name of the condition</li> <li>the matching values for that condition</li> </ul> <p>The logic applied is that an instance must match at least one value for each condition (so it's ANDing a collection of ORs)</p> required <code>link_folders</code> <code>list-like of str</code> <p>The folders that should be linked in their entirety</p> required <code>max_link_depth</code> <code>int, optional</code> <p>By default, non-root-level folders (that is, folders inside of folders) will be treated as files for the purpose of linking. Put another way, only files with a depth of 2 or less from the shulker root will be linked. This behavior can be overridden by explicitly setting the <code>max_link_depth</code> value, but this feature is highly experimental, so use it at your own risk.</p> required"},{"location":"reference/enderchest/#enderchest.ShulkerBox--notes","title":"Notes","text":"<p>A shulker box specification is immutable, so making changes (such as updating the match critera) can only be done on copies created via the <code>_replace</code> method, inherited from the NamedTuple parent class.</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>class ShulkerBox(NamedTuple):\n\"\"\"Specification of a ShulkerBox\n    Parameters\n    ----------\n    priority : int\n        The priority for linking assets in the shulker box (higher priority\n        shulkers are linked last)\n    name : str\n        The name of the shulker box (which is incidetentally used to break\n        priority ties)\n    root : Path\n        The path to the root of the shulker box\n    match_criteria : list-like of tuples\n        The parameters for matching instances to this shulker box. Each element\n        consists of:\n          - the name of the condition\n          - the matching values for that condition\n        The logic applied is that an instance must match at least one value\n        for each condition (so it's ANDing a collection of ORs)\n    link_folders : list-like of str\n        The folders that should be linked in their entirety\n    max_link_depth : int, optional\n        By default, non-root-level folders (that is, folders inside of folders)\n        will be treated as files for the purpose of linking. Put another way,\n        only files with a depth of 2 or less from the shulker root will be\n        linked. This behavior can be overridden by explicitly setting\n        the `max_link_depth` value, but **this feature is highly experimental**,\n        so use it at your own risk.\n    Notes\n    -----\n    A shulker box specification is immutable, so making changes (such as\n    updating the match critera) can only be done on copies created via the\n    `_replace` method, inherited from the NamedTuple parent class.\n    \"\"\"\npriority: int\nname: str\nroot: Path\nmatch_criteria: tuple[tuple[str, tuple[str, ...]], ...]\nlink_folders: tuple[str, ...]\nmax_link_depth: int = 2\n@classmethod\ndef from_cfg(cls, config_file: Path) -&gt; \"ShulkerBox\":\n\"\"\"Parse a shulker box from its config file\n        Parameters\n        ----------\n        config_file : Path\n            The path to the config file\n        Returns\n        -------\n        ShulkerBox\n            The resulting ShulkerBox\n        Raises\n        ------\n        ValueError\n            If the config file at that location cannot be parsed\n        FileNotFoundError\n            If there is no config file at the specified location\n        \"\"\"\npriority = 0\nmax_link_depth = 2\nroot = config_file.parent\nname = root.name\nparser = ConfigParser(allow_no_value=True, inline_comment_prefixes=(\";\",))\ntry:\nassert parser.read(config_file)\nexcept ParsingError as bad_cfg:\nraise ValueError(f\"Could not parse {config_file}\") from bad_cfg\nexcept AssertionError:\nraise FileNotFoundError(f\"Could not open {config_file}\")\nmatch_criteria: dict[str, tuple[str, ...]] = {}\nfor section in parser.sections():\nnormalized = (\nsection.lower().replace(\" \", \"\").replace(\"-\", \"\").replace(\"_\", \"\")\n)\nif normalized.endswith(\"s\"):\nnormalized = normalized[:-1]  # lazy de-pluralization\nif normalized in (\"linkfolder\", \"folder\"):\nnormalized = \"link-folders\"\nif normalized in (\"minecraft\", \"version\", \"minecraftversion\"):\nnormalized = \"minecraft\"\nif normalized in (\"modloader\", \"loader\"):\nnormalized = \"modloader\"\nif normalized in (\"instance\", \"tag\", \"host\"):\nnormalized += \"s\"  # lazy re-pluralization\nif normalized == \"propertie\":  # lulz\n# TODO check to make sure properties hasn't been read before\n# most of this section gets ignored\npriority = parser[section].getint(\"priority\", 0)\nmax_link_depth = parser[section].getint(\"max-link-depth\", 2)\n# TODO: support specifying filters (and link-folders) in the properties section\ncontinue\nif normalized in match_criteria.keys():\nraise ValueError(f\"{config_file} specifies {normalized} more than once\")\nif normalized == \"minecraft\":\nminecraft_versions = []\nfor key, value in parser[section].items():\nif value is None:\nminecraft_versions.append(key)\nelif key.lower().strip().startswith(\"version\"):\nminecraft_versions.append(value)\nelse:  # what happens if you specify \"&gt;=1.19\" or \"=1.12\"\nminecraft_versions.append(\"=\".join((key, value)))\nmatch_criteria[\"minecraft\"] = tuple(minecraft_versions)\nelse:\n# really hoping delimiter shenanigans doesn't show up anywhere else\nmatch_criteria[normalized] = tuple(parser[section].keys())\nlink_folders = match_criteria.pop(\"link-folders\", ())\nreturn cls(\npriority,\nname,\nroot,\ntuple(match_criteria.items()),\nlink_folders,\nmax_link_depth=max_link_depth,\n)\ndef write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n\"\"\"Write this shulker's configuration to INI\n        Parameters\n        ----------\n        config_file : Path, optional\n            The path to the config file, assuming you'd like to write the\n            contents to file\n        Returns\n        -------\n        str\n            An INI-syntax rendering of this shulker box's config\n        Notes\n        -----\n        The \"root\" attribute is ignored for this method\n        \"\"\"\nconfig = ConfigParser(allow_no_value=True)\nconfig.add_section(\"properties\")\nconfig.set(\"properties\", \"priority\", str(self.priority))\nif self.max_link_depth != 2:\nconfig.set(\"properties\", \"max-link-depth\", str(self.max_link_depth))\nconfig.set(\"properties\", \"last_modified\", dt.datetime.now().isoformat(sep=\" \"))\nconfig.set(\n\"properties\", \"generated_by_enderchest_version\", get_versions()[\"version\"]\n)\nfor condition, values in self.match_criteria:\nconfig.add_section(condition)\nfor value in values:\nconfig.set(condition, value)\nconfig.add_section(\"link-folders\")\nfor folder in self.link_folders:\nconfig.set(\"link-folders\", folder)\nbuffer = StringIO()\nbuffer.write(f\"; {os.path.join(self.name, fs.SHULKER_BOX_CONFIG_NAME)}\\n\")\nconfig.write(buffer)\nbuffer.seek(0)  # rewind\nif config_file:\nconfig_file.write_text(buffer.read())\nbuffer.seek(0)\nreturn buffer.read()\ndef matches(self, instance: InstanceSpec) -&gt; bool:\n\"\"\"Determine whether the shulker box matches the given instance\n        Parameters\n        ----------\n        instance : InstanceSpec\n            The instance's specification\n        Returns\n        -------\n        bool\n            True if the instance matches the shulker box's conditions, False\n            otherwise.\n        \"\"\"\nfor condition, values in self.match_criteria:\nmatch condition:  # these should have been normalized on read-in\ncase \"instances\":\nfor value in values:\nif fnmatch.fnmatchcase(instance.name, value):\nbreak\nelse:\nreturn False\ncase \"tags\":\nfor value in values:\nif fnmatch.filter(\n[tag.lower() for tag in instance.tags], value.lower()\n):\nbreak\nelse:\nreturn False\ncase \"modloader\":\nnormalized: list[str] = sum(\n[_normalize_modloader(value) for value in values], []\n)\nfor value in normalized:\nif fnmatch.filter(\n[\nloader.lower()\nfor loader in _normalize_modloader(instance.modloader)\n],\nvalue.lower(),\n):\nbreak\nelse:\nreturn False\ncase \"minecraft\":\nfor value in values:\nif any(\n(\n_matches_version(value, version)\nfor version in instance.minecraft_versions\n)\n):\nbreak\nelse:\nreturn False\ncase \"hosts\":\n# this is handled at a higher level\npass\ncase _:\nraise NotImplementedError(\nf\"Don't know how to apply match condition {condition}.\"\n)\nreturn True\n</code></pre>"},{"location":"reference/enderchest/#enderchest.shulker_box.ShulkerBox.from_cfg","title":"<code>from_cfg(config_file)</code>  <code>classmethod</code>","text":"<p>Parse a shulker box from its config file</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path</code> <p>The path to the config file</p> required <p>Returns:</p> Type Description <code>ShulkerBox</code> <p>The resulting ShulkerBox</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the config file at that location cannot be parsed</p> <code>FileNotFoundError</code> <p>If there is no config file at the specified location</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>@classmethod\ndef from_cfg(cls, config_file: Path) -&gt; \"ShulkerBox\":\n\"\"\"Parse a shulker box from its config file\n    Parameters\n    ----------\n    config_file : Path\n        The path to the config file\n    Returns\n    -------\n    ShulkerBox\n        The resulting ShulkerBox\n    Raises\n    ------\n    ValueError\n        If the config file at that location cannot be parsed\n    FileNotFoundError\n        If there is no config file at the specified location\n    \"\"\"\npriority = 0\nmax_link_depth = 2\nroot = config_file.parent\nname = root.name\nparser = ConfigParser(allow_no_value=True, inline_comment_prefixes=(\";\",))\ntry:\nassert parser.read(config_file)\nexcept ParsingError as bad_cfg:\nraise ValueError(f\"Could not parse {config_file}\") from bad_cfg\nexcept AssertionError:\nraise FileNotFoundError(f\"Could not open {config_file}\")\nmatch_criteria: dict[str, tuple[str, ...]] = {}\nfor section in parser.sections():\nnormalized = (\nsection.lower().replace(\" \", \"\").replace(\"-\", \"\").replace(\"_\", \"\")\n)\nif normalized.endswith(\"s\"):\nnormalized = normalized[:-1]  # lazy de-pluralization\nif normalized in (\"linkfolder\", \"folder\"):\nnormalized = \"link-folders\"\nif normalized in (\"minecraft\", \"version\", \"minecraftversion\"):\nnormalized = \"minecraft\"\nif normalized in (\"modloader\", \"loader\"):\nnormalized = \"modloader\"\nif normalized in (\"instance\", \"tag\", \"host\"):\nnormalized += \"s\"  # lazy re-pluralization\nif normalized == \"propertie\":  # lulz\n# TODO check to make sure properties hasn't been read before\n# most of this section gets ignored\npriority = parser[section].getint(\"priority\", 0)\nmax_link_depth = parser[section].getint(\"max-link-depth\", 2)\n# TODO: support specifying filters (and link-folders) in the properties section\ncontinue\nif normalized in match_criteria.keys():\nraise ValueError(f\"{config_file} specifies {normalized} more than once\")\nif normalized == \"minecraft\":\nminecraft_versions = []\nfor key, value in parser[section].items():\nif value is None:\nminecraft_versions.append(key)\nelif key.lower().strip().startswith(\"version\"):\nminecraft_versions.append(value)\nelse:  # what happens if you specify \"&gt;=1.19\" or \"=1.12\"\nminecraft_versions.append(\"=\".join((key, value)))\nmatch_criteria[\"minecraft\"] = tuple(minecraft_versions)\nelse:\n# really hoping delimiter shenanigans doesn't show up anywhere else\nmatch_criteria[normalized] = tuple(parser[section].keys())\nlink_folders = match_criteria.pop(\"link-folders\", ())\nreturn cls(\npriority,\nname,\nroot,\ntuple(match_criteria.items()),\nlink_folders,\nmax_link_depth=max_link_depth,\n)\n</code></pre>"},{"location":"reference/enderchest/#enderchest.shulker_box.ShulkerBox.matches","title":"<code>matches(instance)</code>","text":"<p>Determine whether the shulker box matches the given instance</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>InstanceSpec</code> <p>The instance's specification</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the instance matches the shulker box's conditions, False otherwise.</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>def matches(self, instance: InstanceSpec) -&gt; bool:\n\"\"\"Determine whether the shulker box matches the given instance\n    Parameters\n    ----------\n    instance : InstanceSpec\n        The instance's specification\n    Returns\n    -------\n    bool\n        True if the instance matches the shulker box's conditions, False\n        otherwise.\n    \"\"\"\nfor condition, values in self.match_criteria:\nmatch condition:  # these should have been normalized on read-in\ncase \"instances\":\nfor value in values:\nif fnmatch.fnmatchcase(instance.name, value):\nbreak\nelse:\nreturn False\ncase \"tags\":\nfor value in values:\nif fnmatch.filter(\n[tag.lower() for tag in instance.tags], value.lower()\n):\nbreak\nelse:\nreturn False\ncase \"modloader\":\nnormalized: list[str] = sum(\n[_normalize_modloader(value) for value in values], []\n)\nfor value in normalized:\nif fnmatch.filter(\n[\nloader.lower()\nfor loader in _normalize_modloader(instance.modloader)\n],\nvalue.lower(),\n):\nbreak\nelse:\nreturn False\ncase \"minecraft\":\nfor value in values:\nif any(\n(\n_matches_version(value, version)\nfor version in instance.minecraft_versions\n)\n):\nbreak\nelse:\nreturn False\ncase \"hosts\":\n# this is handled at a higher level\npass\ncase _:\nraise NotImplementedError(\nf\"Don't know how to apply match condition {condition}.\"\n)\nreturn True\n</code></pre>"},{"location":"reference/enderchest/#enderchest.shulker_box.ShulkerBox.write_to_cfg","title":"<code>write_to_cfg(config_file=None)</code>","text":"<p>Write this shulker's configuration to INI</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path, optional</code> <p>The path to the config file, assuming you'd like to write the contents to file</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>An INI-syntax rendering of this shulker box's config</p>"},{"location":"reference/enderchest/#enderchest.shulker_box.ShulkerBox.write_to_cfg--notes","title":"Notes","text":"<p>The \"root\" attribute is ignored for this method</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>def write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n\"\"\"Write this shulker's configuration to INI\n    Parameters\n    ----------\n    config_file : Path, optional\n        The path to the config file, assuming you'd like to write the\n        contents to file\n    Returns\n    -------\n    str\n        An INI-syntax rendering of this shulker box's config\n    Notes\n    -----\n    The \"root\" attribute is ignored for this method\n    \"\"\"\nconfig = ConfigParser(allow_no_value=True)\nconfig.add_section(\"properties\")\nconfig.set(\"properties\", \"priority\", str(self.priority))\nif self.max_link_depth != 2:\nconfig.set(\"properties\", \"max-link-depth\", str(self.max_link_depth))\nconfig.set(\"properties\", \"last_modified\", dt.datetime.now().isoformat(sep=\" \"))\nconfig.set(\n\"properties\", \"generated_by_enderchest_version\", get_versions()[\"version\"]\n)\nfor condition, values in self.match_criteria:\nconfig.add_section(condition)\nfor value in values:\nconfig.set(condition, value)\nconfig.add_section(\"link-folders\")\nfor folder in self.link_folders:\nconfig.set(\"link-folders\", folder)\nbuffer = StringIO()\nbuffer.write(f\"; {os.path.join(self.name, fs.SHULKER_BOX_CONFIG_NAME)}\\n\")\nconfig.write(buffer)\nbuffer.seek(0)  # rewind\nif config_file:\nconfig_file.write_text(buffer.read())\nbuffer.seek(0)\nreturn buffer.read()\n</code></pre>"},{"location":"reference/enderchest/cli/","title":"cli","text":"<p>Command-line interface</p>"},{"location":"reference/enderchest/cli/#enderchest.cli.generate_parsers","title":"<code>generate_parsers()</code>","text":"<p>Generate the command-line parsers</p> <p>Returns:</p> Name Type Description <code>enderchest_parser</code> <code>ArgumentParser</code> <p>The top-level argument parser responsible for routing arguments to specific action parsers</p> <code>action_parsers</code> <code>dict of str to ArgumentParser</code> <p>The verb-specific argument parsers</p> Source code in <code>enderchest/cli.py</code> <pre><code>def generate_parsers() -&gt; tuple[ArgumentParser, dict[str, ArgumentParser]]:\n\"\"\"Generate the command-line parsers\n    Returns\n    -------\n    enderchest_parser : ArgumentParser\n        The top-level argument parser responsible for routing arguments to\n        specific action parsers\n    action_parsers : dict of str to ArgumentParser\n        The verb-specific argument parsers\n    \"\"\"\ndescriptions: dict[str, str] = {}\nroot_description: str = \"\"\nfor commands, description, method in ACTIONS:\ndescriptions[commands[0]] = description\nroot_description += f\"\\n\\t{commands[0]}\\n\\t\\tto {description}\"\nenderchest_parser = ArgumentParser(\nprog=\"enderchest\",\ndescription=(\nf\"v{get_versions()['version']}\\n\"\n\"\\nsyncing and linking for all your Minecraft instances\"\n),\nformatter_class=RawTextHelpFormatter,\n)\nenderchest_parser.add_argument(\n\"-v\",  # don't worry--this doesn't actually conflict with --verbose\n\"--version\",\naction=\"version\",\nversion=f\"%(prog)s v{get_versions()['version']}\",\n)\n# these are really just for the sake of --help\n# (the parsed args aren't actually used)\nenderchest_parser.add_argument(\n\"action\",\nhelp=f\"the action to perform. Options are:{root_description}\",\ntype=str,\n)\nenderchest_parser.add_argument(\n\"arguments\",\nnargs=\"*\",\nhelp=\"any additional arguments for the specific action.\"\n\" To learn more, try: enderchest {action} -h\",\n)\naction_parsers: dict[str, ArgumentParser] = {}\nfor verb, description in descriptions.items():\nparser = ArgumentParser(\nprog=f\"enderchest {verb}\",\ndescription=description,\n)\nroot = parser.add_mutually_exclusive_group()\nroot.add_argument(\n\"root\",\nnargs=\"?\",\nhelp=(\n\"optionally specify your root minecraft directory.\"\n\"  If no path is given, the current working directory will be used.\"\n),\ntype=Path,\n)\nroot.add_argument(\n\"--root\",\ndest=\"root_flag\",\nhelp=\"specify your root minecraft directory\",\ntype=Path,\n)\n# I'm actually okay with -vvqvqqv hilarity\nparser.add_argument(\n\"--verbose\",\n\"-v\",\naction=\"count\",\ndefault=0,\nhelp=\"increase the amount of information that's printed\",\n)\nparser.add_argument(\n\"--quiet\",\n\"-q\",\naction=\"count\",\ndefault=0,\nhelp=\"decrease the amount of information that's printed\",\n)\naction_parsers[verb] = parser\n# craft options\ncraft_parser = action_parsers[_create_aliases[0]]\ncraft_parser.add_argument(\n\"--from\",\ndest=\"copy_from\",\nhelp=(\n\"provide the URI (e.g. rsync://deck@my-steam-deck/home/deck/) of a\"\n\" remote EnderChest installation that can be used\"\n\" to boostrap the creation of this one.\"\n),\n)\ncraft_parser.add_argument(\n\"-r\",\n\"--remote\",\ndest=\"remotes\",\naction=\"append\",\nhelp=(\n\"provide the URI (e.g. rsync://deck@my-steam-deck/home/deck/) of a\"\n\" remote EnderChest installation to register with this one\"\n),\n)\ncraft_parser.add_argument(\n\"-i\",\n\"--instance\",\ndest=\"instance_search_paths\",\naction=\"append\",\ntype=Path,\nhelp=\"specify a folder to search for Minecraft installations in\",\n)\ncraft_parser.add_argument(\n\"--overwrite\",\naction=\"store_true\",\nhelp=(\n\"if there's already an EnderChest installation in this location,\"\n\" overwrite its configuration\"\n),\n)\n# shulker box craft options\nshulker_craft_parser = action_parsers[f\"{_create_aliases[0]} {_shulker_aliases[0]}\"]\nshulker_craft_parser.add_argument(\n\"name\",\nhelp=\"specify the name for this shulker box\",\n)\nshulker_craft_parser.add_argument(\n\"--priority\",\n\"-p\",\nhelp=\"specify the link priority for this shulker box (higher = linked later)\",\n)\nshulker_craft_parser.add_argument(\n\"-i\",\n\"--instance\",\ndest=\"instances\",\naction=\"append\",\nhelp=\"only link instances with one of the provided names to this shulker box\",\n)\nshulker_craft_parser.add_argument(\n\"-t\",\n\"--tag\",\ndest=\"tags\",\naction=\"append\",\nhelp=\"only link instances with one of the provided tags to this shulker box\",\n)\nshulker_craft_parser.add_argument(\n\"-e\",\n\"--enderchest\",\ndest=\"hosts\",\naction=\"append\",\nhelp=(\n\"only link instances registered to one of the provided EnderChest\"\n\" installations with this shulker box\"\n),\n)\nshulker_craft_parser.add_argument(\n\"-l\",\n\"--folder\",\ndest=\"link_folders\",\naction=\"append\",\nhelp=(\n\"specify the name of a folder inside this shulker box\"\n\" that should be linked completely\"\n),\n)\nshulker_craft_parser.add_argument(\n\"--overwrite\",\naction=\"store_true\",\nhelp=(\n\"if there's already a shulker box with the specified name,\"\n\" overwrite its configuration\"\n),\n)\n# place options\nplace_parser = action_parsers[\"place\"]\nplace_parser.add_argument(\n\"-k\",\n\"--keep-broken-links\",\naction=\"store_false\",\ndest=\"cleanup\",\nhelp=\"do not remove broken links from instances\",\n)\nerror_handling = place_parser.add_mutually_exclusive_group()\nerror_handling.add_argument(\n\"--stop-at-first-failure\",\n\"-x\",\naction=\"store_true\",\nhelp=\"stop linking at the first issue\",\n)\nerror_handling.add_argument(\n\"--ignore-errors\", action=\"store_true\", help=\"ignore any linking errors\"\n)\nerror_handling.add_argument(\n\"--errors\",\n\"-e\",\nchoices=(\n\"prompt\",\n\"ignore\",\n\"skip\",\n\"skip-instance\",\n\"skip-shulker-box\",\n\"abort\",\n),\ndefault=\"prompt\",\nhelp=\"specify how to handle linking errors (default behavior is to prompt after every error)\",\n)\n# gather instance options\ngather_instance_parser = action_parsers[f\"gather\"]\ngather_instance_parser.add_argument(\n\"search_paths\",\nnargs=\"+\",\naction=\"extend\",\ntype=Path,\nhelp=\"specify a folder or folders to search for Minecraft installations\",\n)\ninstance_type = gather_instance_parser.add_mutually_exclusive_group()\ninstance_type.add_argument(\n\"--official\",\n\"-o\",\naction=\"store_true\",\nhelp=\"specify that these are instances managed by the official launcher\",\n)\ninstance_type.add_argument(\n\"--mmc\",\n\"-m\",\naction=\"store_true\",\nhelp=\"specify that these are MultiMC-like instances\",\n)\n# gather remote options\ngather_remote_parser = action_parsers[f\"gather {_remote_aliases[0]}\"]\ngather_remote_parser.add_argument(\n\"remotes\",\nnargs=\"+\",\naction=\"extend\",\nhelp=(\n\"provide URIs (e.g. rsync://deck@my-steam-deck/home/deck/) of any\"\n\" remote EnderChest installation to register with this one.\"\n\"Note: you should not use this method if the alias (name) of the\"\n\"remote does not match the remote's hostname (in this example,\"\n'\"my-steam-deck\").'\n),\n)\n# list instances options\n# list shulkers options\n# list shulker options\nlist_shulker_parser = action_parsers[f\"{_list_aliases[0]} {_shulker_aliases[0]}\"]\nlist_shulker_parser.add_argument(\n\"shulker_box_name\", help=\"The name of the shulker box to query\"\n)\n# open options\n# close options\nreturn enderchest_parser, action_parsers\n</code></pre>"},{"location":"reference/enderchest/cli/#enderchest.cli.parse_args","title":"<code>parse_args(argv)</code>","text":"<p>Parse the provided command-line options to determine the action to perform and the arguments to pass to the action</p> <p>Parameters:</p> Name Type Description Default <code>argv</code> <code>list-like of str (sys.argv)</code> <p>The options passed into the command line</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The action method that will be called</p> <code>str</code> <p>The root of the minecraft folder (parent of the EnderChest) where the action will be performed</p> <code>int</code> <p>The verbosity level of the operation (in terms of log levels)</p> <code>dict</code> <p>Any additional options that will be given to the action method</p> Source code in <code>enderchest/cli.py</code> <pre><code>def parse_args(argv: Sequence[str]) -&gt; tuple[Action, Path, int, dict[str, Any]]:\n\"\"\"Parse the provided command-line options to determine the action to perform and\n    the arguments to pass to the action\n    Parameters\n    ----------\n    argv : list-like of str (sys.argv)\n        The options passed into the command line\n    Returns\n    -------\n    Callable\n        The action method that will be called\n    str\n        The root of the minecraft folder (parent of the EnderChest)\n        where the action will be performed\n    int\n        The verbosity level of the operation (in terms of log levels)\n    dict\n        Any additional options that will be given to the action method\n    \"\"\"\nactions: dict[str, Action] = {}\naliases: dict[str, str] = {}\nfor commands, description, method in ACTIONS:\nfor command in commands:\naliases[command] = commands[0]\nactions[commands[0]] = method\nenderchest_parser, action_parsers = generate_parsers()\n_ = enderchest_parser.parse_args(argv[1:2])  # check for --help and --version\nfor command in sorted(aliases.keys(), key=lambda x: -len(x)):  # longest first\nif \" \".join((*argv[1:], \"\")).startswith(command + \" \"):\naction_kwargs = vars(\naction_parsers[aliases[command]].parse_args(\nargv[1 + len(command.split()) :]\n)\n)\nroot_arg = action_kwargs.pop(\"root\")\nroot_flag = action_kwargs.pop(\"root_flag\")\nverbosity = action_kwargs.pop(\"verbose\") - action_kwargs.pop(\"quiet\")\nlog_level = logging.INFO - 10 * verbosity\nif log_level == logging.NOTSET:  # that's 0, annoyingly enough\nlog_level -= 1\nreturn (\nactions[aliases[command]],\nPath(root_arg or root_flag or os.getcwd()),\nlog_level,\naction_kwargs,\n)\nelse:\nenderchest_parser.print_help(sys.stderr)\nsys.exit(1)\n</code></pre>"},{"location":"reference/enderchest/craft/","title":"craft","text":"<p>Functionality for setting up the folder structure of both chests and shulker boxes</p>"},{"location":"reference/enderchest/craft/#enderchest.craft.craft_ender_chest","title":"<code>craft_ender_chest(minecraft_root, copy_from=None, instance_search_paths=None, remotes=None, overwrite=False)</code>","text":"<p>Craft an EnderChest, either from the specified keyword arguments, or interactively via prompts</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff is in (or, at least, the one inside which you want to create your EnderChest)</p> required <code>copy_from</code> <code>URI, optional</code> <p>Optionally bootstrap your configuration by pulling the list of remotes from an existing remote EnderChest</p> <code>None</code> <code>instance_search_paths</code> <code>list of Paths, optional</code> <p>Any paths to search for Minecraft instances</p> <code>None</code> <code>remotes</code> <code>list of URIs or (URI, str) tuples, optional</code> <p>Any remotes you wish you manually specify. If used with <code>copy_from</code>, these will overwrite any remotes pulled from the remote EnderChest. When a (URI, str) tuple is provided, the second value will be used as the name/alias of the remote.</p> <code>None</code> <code>overwrite</code> <code>bool, optional</code> <p>This method will not overwrite an EnderChest instance installed within the <code>minecraft_root</code> unless the user provides <code>overwrite=True</code></p> <code>False</code>"},{"location":"reference/enderchest/craft/#enderchest.craft.craft_ender_chest--notes","title":"Notes","text":"<ul> <li>The guided / interactive specifier will only be used if no other keyword   arguments are provided (not even <code>overwrite=True</code>)</li> <li>The instance searcher will first attempt to parse any instances it finds   as official-launcher Minecrafts and then, if that doesn't work, will try   parsing them as MultiMC-style instances.</li> <li>The instance searcher is fully recursive, so keep that in mind before   passing in, say \"/\"</li> </ul> Source code in <code>enderchest/craft.py</code> <pre><code>def craft_ender_chest(\nminecraft_root: Path,\ncopy_from: str | ParseResult | None = None,\ninstance_search_paths: Iterable[str | Path] | None = None,\nremotes: Iterable[str | ParseResult | tuple[str, str] | tuple[ParseResult, str]]\n| None = None,\noverwrite: bool = False,\n) -&gt; None:\n\"\"\"Craft an EnderChest, either from the specified keyword arguments, or\n    interactively via prompts\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff is in (or, at least, the\n        one inside which you want to create your EnderChest)\n    copy_from : URI, optional\n        Optionally bootstrap your configuration by pulling the list of remotes\n        from an existing remote EnderChest\n    instance_search_paths : list of Paths, optional\n        Any paths to search for Minecraft instances\n    remotes : list of URIs or (URI, str) tuples, optional\n        Any remotes you wish you manually specify. If used with `copy_from`, these\n        will overwrite any remotes pulled from the remote EnderChest. When a\n        (URI, str) tuple is provided, the second value will be used as the\n        name/alias of the remote.\n    overwrite : bool, optional\n        This method will not overwrite an EnderChest instance installed within\n        the `minecraft_root` unless the user provides `overwrite=True`\n    Notes\n    -----\n    - The guided / interactive specifier will only be used if no other keyword\n      arguments are provided (not even `overwrite=True`)\n    - The instance searcher will first attempt to parse any instances it finds\n      as official-launcher Minecrafts and then, if that doesn't work, will try\n      parsing them as MultiMC-style instances.\n    - The instance searcher is fully recursive, so keep that in mind before\n      passing in, say \"/\"\n    \"\"\"\nif not minecraft_root.exists():\nCRAFT_LOGGER.error(f\"The directory {minecraft_root} does not exist\")\nCRAFT_LOGGER.error(\"Aborting\")\nreturn\nif (\ncopy_from is None\nand instance_search_paths is None\nand remotes is None\nand not overwrite\n):\n# then we go interactive\ntry:\nender_chest = specify_ender_chest_from_prompt(minecraft_root)\nexcept (FileExistsError, RuntimeError):\nCRAFT_LOGGER.error(\"Aborting\")\nreturn\nelse:\ntry:\nfs.ender_chest_config(minecraft_root, check_exists=True)\nexist_message = (\nf\"There is already an EnderChest installed to {minecraft_root}\"\n)\nif overwrite:\nCRAFT_LOGGER.warning(exist_message)\nelse:\nCRAFT_LOGGER.error(exist_message)\nCRAFT_LOGGER.error(\"Aborting\")\nreturn\nexcept FileNotFoundError:\npass  # no existing chest? no problem!\nender_chest = EnderChest(minecraft_root)\nfor search_path in instance_search_paths or ():\nfor instance in gather_minecraft_instances(\nminecraft_root, Path(search_path), None\n):\nender_chest.register_instance(instance)\nif copy_from:\ntry:\nfor remote, alias in fetch_remotes_from_a_remote_ender_chest(copy_from):\nender_chest.register_remote(remote, alias)\nexcept (RuntimeError, ValueError) as fetch_fail:\nCRAFT_LOGGER.warning(\nf\"Could not fetch remotes from {copy_from}:\\n  {fetch_fail}\"\n)\nfor extra_remote in remotes or ():\nif isinstance(extra_remote, (str, ParseResult)):\nender_chest.register_remote(extra_remote)\nelse:\nender_chest.register_remote(*extra_remote)\ncreate_ender_chest(minecraft_root, ender_chest)\nCRAFT_LOGGER.info(\n\"\\nNow craft some shulker boxes via\\n$ enderchest craft shulker_box\\n\"\n)\n</code></pre>"},{"location":"reference/enderchest/craft/#enderchest.craft.craft_shulker_box","title":"<code>craft_shulker_box(minecraft_root, name, priority=None, link_folders=None, instances=None, tags=None, hosts=None, overwrite=False)</code>","text":"<p>Craft a shulker box, either from the specified keyword arguments, or interactively via prompts</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>name</code> <code>str</code> <p>A name to give to this shulker box</p> required <code>priority</code> <code>int, optional</code> <p>The priority for linking assets in the shulker box (higher priority shulkers are linked last)</p> <code>None</code> <code>link_folders</code> <code>list of str, optional</code> <p>The folders that should be linked in their entirety</p> <code>None</code> <code>instances</code> <code>list of str, optional</code> <p>The names of the instances you'd like to link to this shulker box</p> <code>None</code> <code>tags</code> <code>list of str, optional</code> <p>You can instead (see notes) provide a list of tags where any instances with those tags will be linked to this shulker box</p> <code>None</code> <code>hosts</code> <code>list of str, optional</code> <p>The EnderChest installations that this shulker box should be applied to</p> <code>None</code> <code>overwrite</code> <code>bool, optional</code> <p>This method will not overwrite an existing shulker box unless the user provides <code>overwrite=True</code></p> <code>False</code>"},{"location":"reference/enderchest/craft/#enderchest.craft.craft_shulker_box--notes","title":"Notes","text":"<ul> <li>The guided / interactive specifier will only be used if no other keyword   arguments are provided (not even <code>overwrite=True</code>)</li> <li>The conditions specified by instances, tags and hosts are ANDed   together--that is, if an instance is listed explicitly, but it doesn't   match a provided tag, it will not link to this shulker box</li> <li>Wildcards are supported for instances, tags and hosts (but not link-folders)</li> <li>Not specifying instances, tags or hosts is equivalent to providing <code>[\"*\"]</code></li> <li>When values are provided to the keyword arguments, no validation is performed   to ensure that they are valid or actively in use</li> </ul> Source code in <code>enderchest/craft.py</code> <pre><code>def craft_shulker_box(\nminecraft_root: Path,\nname: str,\npriority: int | None = None,\nlink_folders: Sequence[str] | None = None,\ninstances: Sequence[str] | None = None,\ntags: Sequence[str] | None = None,\nhosts: Sequence[str] | None = None,\noverwrite: bool = False,\n):\n\"\"\"Craft a shulker box, either from the specified keyword arguments, or\n    interactively via prompts\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    name : str\n        A name to give to this shulker box\n    priority : int, optional\n        The priority for linking assets in the shulker box (higher priority\n        shulkers are linked last)\n    link_folders : list of str, optional\n        The folders that should be linked in their entirety\n    instances : list of str, optional\n        The names of the instances you'd like to link to this shulker box\n    tags : list of str, optional\n        You can instead (see notes) provide a list of tags where any instances\n        with those tags will be linked to this shulker box\n    hosts : list of str, optional\n        The EnderChest installations that this shulker box should be applied to\n    overwrite : bool, optional\n        This method will not overwrite an existing shulker box unless the user\n        provides `overwrite=True`\n    Notes\n    -----\n    - The guided / interactive specifier will only be used if no other keyword\n      arguments are provided (not even `overwrite=True`)\n    - The conditions specified by instances, tags and hosts are ANDed\n      together--that is, if an instance is listed explicitly, but it doesn't\n      match a provided tag, it will not link to this shulker box\n    - Wildcards are supported for instances, tags and hosts (but not link-folders)\n    - Not specifying instances, tags or hosts is equivalent to providing `[\"*\"]`\n    - When values are provided to the keyword arguments, no validation is performed\n      to ensure that they are valid or actively in use\n    \"\"\"\nif not is_valid_filename(name):\nCRAFT_LOGGER.error(f\"{name} is not a valid name: must be useable as a filename\")\nreturn\ntry:\nif (\npriority is None\nand link_folders is None\nand instances is None\nand tags is None\nand hosts is None\nand not overwrite\n):\ntry:\nshulker_box = specify_shulker_box_from_prompt(minecraft_root, name)\nexcept FileExistsError as seat_taken:\nCRAFT_LOGGER.error(seat_taken)\nCRAFT_LOGGER.error(\"Aborting\")\nreturn\nelse:\nconfig_path = fs.shulker_box_config(minecraft_root, name)\nif config_path.exists():\nexist_message = (\nf\"There is already a shulker box named {name}\"\nf\" in {fs.ender_chest_folder(minecraft_root)}\"\n)\nif overwrite:\nCRAFT_LOGGER.warning(exist_message)\nelse:\nCRAFT_LOGGER.error(exist_message)\nCRAFT_LOGGER.error(\"Aborting\")\nreturn\nmatch_criteria: list[tuple[str, tuple[str, ...]]] = []\nif instances is not None:\nmatch_criteria.append((\"instances\", tuple(instances)))\nif tags is not None:\nmatch_criteria.append((\"tags\", tuple(tags)))\nif hosts is not None:\nmatch_criteria.append((\"hosts\", tuple(hosts)))\nshulker_box = ShulkerBox(\npriority=priority or 0,\nname=name,\nroot=minecraft_root,\nmatch_criteria=tuple(match_criteria),\nlink_folders=tuple(link_folders or ()),\n)\nexcept FileNotFoundError as no_ender_chest:\nCRAFT_LOGGER.error(no_ender_chest)\nreturn\ncreate_shulker_box(minecraft_root, shulker_box)\n</code></pre>"},{"location":"reference/enderchest/craft/#enderchest.craft.specify_ender_chest_from_prompt","title":"<code>specify_ender_chest_from_prompt(minecraft_root)</code>","text":"<p>Parse an EnderChest based on interactive user input</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff is in (or, at least, the one inside which you want to create your EnderChest)</p> required <p>Returns:</p> Type Description <code>EnderChest</code> <p>The resulting EnderChest</p> Source code in <code>enderchest/craft.py</code> <pre><code>def specify_ender_chest_from_prompt(minecraft_root: Path) -&gt; EnderChest:\n\"\"\"Parse an EnderChest based on interactive user input\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff is in (or, at least, the\n        one inside which you want to create your EnderChest)\n    Returns\n    -------\n    EnderChest\n        The resulting EnderChest\n    \"\"\"\ntry:\nroot = fs.ender_chest_folder(minecraft_root)\nCRAFT_LOGGER.info(\nf\"This will overwrite the EnderChest configuration at {root}.\"\n)\nif not confirm(default=False):\nmessage = f\"Aborting: {fs.ender_chest_config(minecraft_root)} exists.\"\nraise FileExistsError(message)\nexcept FileNotFoundError:\n# good! Then we don't already have an EnderChest here\nCRAFT_LOGGER.debug(f\"{minecraft_root} does not already contain an EnderChest\")\npass\ninstances: list[InstanceSpec] = []\nwhile True:\nsearch_home = prompt(\n\"Would you like to search your home directory for the official launcher?\",\nsuggestion=\"Y/n\",\n).lower()\nif search_home == \"\" or search_home in YES:\ninstances.extend(\ngather_minecraft_instances(minecraft_root, Path.home(), official=True)\n)\nelif search_home not in NO:\ncontinue\nbreak\nwhile True:\nsearch_here = prompt(\n\"Would you like to search the current directory for MultiMC-type instances?\",\nsuggestion=\"Y/n\",\n).lower()\nif search_here == \"\" or search_here in YES:\ninstances.extend(\ngather_minecraft_instances(minecraft_root, Path(), official=False)\n)\nelif search_here not in NO:\ncontinue\nbreak\nif minecraft_root.absolute() != Path().absolute():\nwhile True:\nsearch_mc_folder = prompt(\nf\"Would you like to search {minecraft_root} for MultiMC-type instances?\",\nsuggestion=\"Y/n\",\n).lower()\nif search_mc_folder == \"\" or search_here in YES:\ninstances.extend(\ngather_minecraft_instances(\nminecraft_root, minecraft_root, official=False\n)\n)\nelif search_mc_folder not in NO:\ncontinue\nbreak\nCRAFT_LOGGER.info(\n\"\\nYou can always add more instances later using\"\n\"\\n$ enderchest gather minecraft\\n\"\n)\nwhile True:\nremotes: list[tuple[ParseResult, str]] = []\nremote_uri = prompt(\n\"Would you like to grab the list of remotes from another EnderChest?\"\n\"\\nIf so, enter the URI of that EnderChest now (leave empty to skip).\"\n)\nif remote_uri == \"\":\nbreak\ntry:\nremotes.extend(fetch_remotes_from_a_remote_ender_chest(remote_uri))\nexcept Exception as fetch_fail:\nCRAFT_LOGGER.error(\nf\"Could not fetch remotes from {remote_uri}\\n  {fetch_fail}\"\n)\nif confirm(default=True):\nbreak\nCRAFT_LOGGER.info(\n\"\\nYou can always add more remotes later using\"\n\"\\n$ enderchest gather enderchest\\n\"\n)\nwhile True:\nprotocol = (\nprompt(\n(\n\"Specify the method for syncing with this EnderChest.\"\n\"\\nSupported protocols are: \" + \", \".join(sync.SUPPORTED_PROTOCOLS)\n),\nsuggestion=sync.DEFAULT_PROTOCOL,\n).lower()\nor sync.DEFAULT_PROTOCOL\n)\nif protocol not in sync.SUPPORTED_PROTOCOLS:\nCRAFT_LOGGER.error(\"Unsupported protocol\\n\")\ncontinue\nbreak\nwhile True:\ndefault_netloc = sync.get_default_netloc()\nnetloc = (\nprompt(\n(\n\"What's the address for accessing this machine?\"\n\"\\n(hostname or IP address, plus often a username)\"\n),\nsuggestion=default_netloc,\n)\nor default_netloc\n)\nuri = ParseResult(\nscheme=protocol,\nnetloc=netloc,\npath=minecraft_root.as_posix(),\nparams=\"\",\nquery=\"\",\nfragment=\"\",\n)\nif not uri.hostname:\nCRAFT_LOGGER.error(\"Invalid hostname\")\ncontinue\nbreak\nwhile True:\nname = (\nprompt(\"Provide a name for this EnderChest\", suggestion=uri.hostname)\nor uri.hostname\n)\nif name in (alias for _, alias in remotes):\nCRAFT_LOGGER.error(\nf\"The name {name} is already in use. Choose a different name.\"\n)\ncontinue\nbreak\nender_chest = EnderChest(uri, name, remotes, instances)\nCRAFT_LOGGER.info(\n\"\\n\"\n+ ender_chest.write_to_cfg()\n+ \"\\nPreparing to generate an EnderChest with the above configuration.\"\n)\nif not confirm(default=True):\nraise RuntimeError(\"EnderChest creation aborted.\")\nreturn ender_chest\n</code></pre>"},{"location":"reference/enderchest/craft/#enderchest.craft.specify_shulker_box_from_prompt","title":"<code>specify_shulker_box_from_prompt(minecraft_root, name)</code>","text":"<p>Parse a shulker box based on interactive user input</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>name</code> <code>str</code> <p>The name to give to the shulker box</p> required <p>Returns:</p> Type Description <code>ShulkerBox</code> <p>The resulting ShulkerBox</p> Source code in <code>enderchest/craft.py</code> <pre><code>def specify_shulker_box_from_prompt(minecraft_root: Path, name: str) -&gt; ShulkerBox:\n\"\"\"Parse a shulker box based on interactive user input\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    name : str\n        The name to give to the shulker box\n    Returns\n    -------\n    ShulkerBox\n        The resulting ShulkerBox\n    \"\"\"\nshulker_root = fs.shulker_box_root(minecraft_root, name)\nif shulker_root in shulker_root.parent.glob(\"*\"):\nif not shulker_root.is_dir():\nraise FileExistsError(\nf\"A file named {name} already exists in your EnderChest folder.\"\n)\nCRAFT_LOGGER.warning(\nf\"There is already a folder named {name} in your EnderChest folder.\"\n)\nif not confirm(default=False):\nraise FileExistsError(\nf\"There is already a folder named {name} in your EnderChest folder.\"\n)\nshulker_box = ShulkerBox(0, name, shulker_root, (), ())\ndef refresh_ender_chest_instance_list() -&gt; Sequence[InstanceSpec]:\n\"\"\"The primary reason to lambda-fy this is to re-print the instance list.\"\"\"\nreturn load_ender_chest_instances(minecraft_root)\ninstances = refresh_ender_chest_instance_list()\nexplicit_type = \"name\"\nif len(instances) &gt; 0:\nexplicit_type = \"number\"\nwhile True:\nselection_type = prompt(\nf\"Would you like to specify instances by [F]ilter or by [N]{explicit_type[1:]}?\"\n).lower()\nmatch selection_type:\ncase \"f\" | \"filter\":\nshulker_box = _prompt_for_filters(shulker_box, instances)\ncase \"n\":\nif explicit_type == \"name\":\nshulker_box = _prompt_for_instance_names(shulker_box)\nelse:  # if explicit_type == \"number\"\nshulker_box = _prompt_for_instance_numbers(\nshulker_box, instances, refresh_ender_chest_instance_list\n)\ncase \"name\":\n# yeah, this is always available\nshulker_box = _prompt_for_instance_names(shulker_box)\ncase \"number\":\nif explicit_type == \"name\":\ncontinue\nshulker_box = _prompt_for_instance_numbers(\nshulker_box, instances, refresh_ender_chest_instance_list\n)\ncase _:\ncontinue\nbreak\nwhile True:\nselection_type = prompt(\n\"Folders to Link?\"\n\"\\nUse the [S]tandard set, [M]anually specify or do [N]one?\"\n\"\\nThe standard set is: \" + \", \".join(STANDARD_LINK_FOLDERS)\n).lower()\nmatch selection_type:\ncase \"n\" | \"none\":\nlink_folders: tuple[str, ...] = ()\ncase \"s\" | \"standard\" | \"standard set\":\nlink_folders = STANDARD_LINK_FOLDERS\ncase \"m\" | \"manual\" | \"manually specify\":\nfolder_choices = prompt(\n\"Specify the folders to link using a comma-separated list\"\n\" (wildcards are not allowed)\"\n)\nlink_folders = tuple(\nfolder.strip() for folder in folder_choices.split(\",\")\n)\ncase _:\ncontinue\nbreak\nwhile True:\n# this is such a kludge\nexisting_shulker_boxes = load_shulker_boxes(\nminecraft_root, log_level=logging.DEBUG\n)\nif existing_shulker_boxes:\n_report_shulker_boxes(\nexisting_shulker_boxes, logging.INFO, \"the current EnderChest\"\n)\nvalue = (\nprompt(\n(\n\"What priority value should be assigned to this shulker box?\"\n\"\\nhigher number = applied later\"\n),\nsuggestion=\"0\",\n)\nor \"0\"\n)\ntry:\npriority = int(value)\nexcept ValueError:\ncontinue\nbreak\nwhile True:\n_ = load_ender_chest_remotes(minecraft_root)  # to display some log messages\nvalues = (\nprompt(\n(\n\"What hosts (EnderChest installations) should use this shulker box?\"\n\"\\nProvide a comma-separated list (wildcards are allowed)\"\n\"\\nand remember to include the name of this EnderChest\"\nf'(\"{load_ender_chest(minecraft_root).name}\")'\n),\nsuggestion=\"*\",\n)\nor \"*\"\n)\nhosts = tuple(host.strip() for host in values.split(\",\"))\n# TODO: DRY this into a dedicated function\n# TODO: stop wastefully reloading the cfg\nhost = load_ender_chest(minecraft_root).name\nprint(hosts, host)\nif not any(\nfnmatch.fnmatchcase(host.lower(), host_spec.lower()) for host_spec in hosts\n):\nCRAFT_LOGGER.warning(\n\"This shulker box will not link to any instances on this machine\"\n)\nif not confirm(default=False):\ncontinue\nbreak\nshulker_box = shulker_box._replace(\npriority=priority,\nmatch_criteria=shulker_box.match_criteria + ((\"hosts\", hosts),),\nlink_folders=link_folders,\n)\nCRAFT_LOGGER.info(\n\"\\n\"\n+ shulker_box.write_to_cfg()\n+ \"Preparing to generate a shulker box with the above configuration.\"\n)\nif not confirm(default=True):\nraise RuntimeError(\"Shulker box creation aborted.\")\nreturn shulker_box\n</code></pre>"},{"location":"reference/enderchest/enderchest/","title":"enderchest","text":"<p>Specification and configuration of an EnderChest</p>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.EnderChest","title":"<code>EnderChest</code>  <code>dataclass</code>","text":"<p>Configuration of an EnderChest</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>URI or Path</code> <p>The \"address\" of this EnderChest, ideally as it can be accessed from other EnderChest installations, including both the path to where the EnderChest folder can be found (that is, the parent of the EnderChest folder itself, aka the \"minecraft_root\"), its net location including credentials, and the protocol that should be used to perform the syncing. All that being said, if just a path is provided, the constructor will try to figure out the rest.</p> required <code>name</code> <code>str, optional</code> <p>A unique name to give to this EnderChest installation. If None is provided, this will be taken from the hostname of the supplied URI.</p> <code>None</code> <code>instances</code> <code>list-like of InstanceSpec, optional</code> <p>The list of instances to register with this EnderChest installation</p> <code>None</code> <code>remotes</code> <code>list-like of URI, or (URI, str) tuples</code> <p>A list of other installations that this EnderChest should be aware of (for syncing purposes). When a (URI, str) tuple is provided, the second value will be used as the name/alias of the remote.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The unique name of this EnderChest installation. This is most commonly the computer's hostname, but one can configure multiple EnderChests to coexist on the same system (either for the sake of having a \"cold\" backup or for multi-user systems).</p> <code>uri</code> <code>str</code> <p>The complete URI of this instance</p> <code>root</code> <code>Path</code> <p>The path to this EnderChest folder</p> <code>instances</code> <code>list-like of InstanceSpec</code> <p>The instances registered with this EnderChest</p> <code>remotes</code> <code>list-like of (ParseResult, str) pairs</code> <p>The other EnderChest installations this EnderChest is aware of, paired with their aliases</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>@dataclass(init=False, repr=False)\nclass EnderChest:\n\"\"\"Configuration of an EnderChest\n    Parameters\n    ----------\n    uri : URI or Path\n        The \"address\" of this EnderChest, ideally as it can be accessed from other\n        EnderChest installations, including both the path to where\n        the EnderChest folder can be found (that is, the parent of the\n        EnderChest folder itself, aka the \"minecraft_root\"), its net location\n        including credentials, and the protocol that should be used to perform\n        the syncing. All that being said, if just a path is provided, the\n        constructor will try to figure out the rest.\n    name : str, optional\n        A unique name to give to this EnderChest installation. If None is\n        provided, this will be taken from the hostname of the supplied URI.\n    instances : list-like of InstanceSpec, optional\n        The list of instances to register with this EnderChest installation\n    remotes : list-like of URI, or (URI, str) tuples\n        A list of other installations that this EnderChest should be aware of\n        (for syncing purposes). When a (URI, str) tuple is provided, the\n        second value will be used as the name/alias of the remote.\n    Attributes\n    ----------\n    name : str\n        The unique name of this EnderChest installation. This is most commonly\n        the computer's hostname, but one can configure multiple EnderChests\n        to coexist on the same system (either for the sake of having a \"cold\"\n        backup or for multi-user systems).\n    uri : str\n        The complete URI of this instance\n    root : Path\n        The path to this EnderChest folder\n    instances : list-like of InstanceSpec\n        The instances registered with this EnderChest\n    remotes : list-like of (ParseResult, str) pairs\n        The other EnderChest installations this EnderChest is aware of, paired\n        with their aliases\n    \"\"\"\nname: str\n_uri: ParseResult\n_instances: list[i.InstanceSpec]\n_remotes: dict[str, ParseResult]\ndef __init__(\nself,\nuri: str | ParseResult | Path,\nname: str | None = None,\nremotes: Iterable[str | ParseResult | tuple[str, str] | tuple[ParseResult, str]]\n| None = None,\ninstances: Iterable[i.InstanceSpec] | None = None,\n):\ntry:\nif isinstance(uri, ParseResult):\nself._uri = uri\nelif isinstance(uri, Path):\nself._uri = urlparse(uri.absolute().as_uri())\nelse:\nself._uri = urlparse(uri)\nexcept AttributeError as parse_problem:\nraise ValueError(f\"{uri} is not a valid URI\") from parse_problem\nif not self._uri.netloc:\nself._uri = self._uri._replace(netloc=sync.get_default_netloc())\nif not self._uri.scheme:\nself._uri = self._uri._replace(scheme=sync.DEFAULT_PROTOCOL)\nself.name = name or self._uri.hostname or gethostname()\nself._instances = []\nself._remotes = {}\nfor instance in instances or ():\nself.register_instance(instance)\nfor remote in remotes or ():\nif isinstance(remote, (str, ParseResult)):\nself.register_remote(remote)\nelse:\nself.register_remote(*remote)\n@property\ndef uri(self) -&gt; str:\nreturn self._uri.geturl()\ndef __repr__(self) -&gt; str:\nreturn f\"EnderChest({self.uri, self.name})\"\n@property\ndef root(self) -&gt; Path:\nreturn fs.ender_chest_folder(Path(self._uri.path))\n@property\ndef instances(self) -&gt; tuple[i.InstanceSpec, ...]:\nreturn tuple(self._instances)\ndef register_instance(self, instance: i.InstanceSpec) -&gt; i.InstanceSpec:\n\"\"\"Register a new Minecraft installation\n        Parameters\n        ----------\n        instance : InstanceSpec\n            The instance to register\n        Returns\n        -------\n        InstanceSpec\n            The spec of the instance as it was actually registered (in case the\n            name changed or somesuch)\n        Notes\n        -----\n        - If the instance's name is already assigned to a registered instance,\n          this method will choose a new one\n        - If this instance shares a path with an existing instance, it will\n          replace that instance\n        \"\"\"\nself._instances = [\nold_instance\nfor old_instance in self._instances\nif not i.equals(Path(self._uri.path), instance, old_instance)\n]\nname = instance.name\ncounter = 0\ntaken_names = {old_instance.name for old_instance in self._instances}\nwhile True:\nif name not in taken_names:\nbreak\ncounter += 1\nname = f\"{instance.name}.{counter}\"\nGATHER_LOGGER.debug(f\"Registering instance {instance.name} at {instance.root}\")\nself._instances.append(instance._replace(name=name))\nreturn self._instances[-1]\n@property\ndef remotes(self) -&gt; tuple[tuple[ParseResult, str], ...]:\nreturn tuple((remote, alias) for alias, remote in self._remotes.items())\ndef register_remote(\nself, remote: str | ParseResult, alias: str | None = None\n) -&gt; None:\n\"\"\"Register a new remote EnderChest installation (or update an existing\n        registry)\n        Parameters\n        ----------\n        remote : URI\n            The URI of the remote\n        alias : str, optional\n            an alias to give to this remote. If None is provided, the URI's hostname\n            will be used.\n        Raises\n        ------\n        ValueError\n            If the provided remote is invalid\n        \"\"\"\ntry:\nremote = remote if isinstance(remote, ParseResult) else urlparse(remote)\nalias = alias or remote.hostname\nif not alias:\nraise AttributeError(f\"{remote.geturl()} has no hostname\")\nGATHER_LOGGER.debug(f\"Registering remote {remote.geturl()} ({alias})\")\nself._remotes[alias] = remote\nexcept AttributeError as parse_problem:\nraise ValueError(f\"{remote} is not a valid URI\") from parse_problem\n@classmethod\ndef from_cfg(cls, config_file: Path) -&gt; \"EnderChest\":\n\"\"\"Parse an EnderChest from its config file\n        Parameters\n        ----------\n        config_file : Path\n            The path to the config file\n        Returns\n        -------\n        EnderChest\n            The resulting EnderChest\n        Raises\n        ------\n        ValueError\n            If the config file at that location cannot be parsed\n        FileNotFoundError\n            If there is no config file at the specified location\n        \"\"\"\nparser = ConfigParser(\nallow_no_value=True, delimiters=(\"=\",), inline_comment_prefixes=(\";\",)\n)\ntry:\nassert parser.read(config_file)\nexcept ParsingError as bad_cfg:\nraise ValueError(f\"Could not parse {config_file}\") from bad_cfg\nexcept AssertionError:\nraise FileNotFoundError(f\"Could not open {config_file}\")\n# All I'm gonna say is that Windows pathing is the worst\npath = urlparse(config_file.absolute().parent.parent.as_uri()).path\ninstances: list[i.InstanceSpec] = []\nremotes: list[str | tuple[str, str]] = []\nscheme: str | None = None\nnetloc: str | None = None\nname: str | None = None\nfor section in parser.sections():\nif section == \"properties\":\nscheme = parser[section].get(\"sync-protocol\")\nnetloc = parser[section].get(\"address\")\nname = parser[section].get(\"name\")\nelif section == \"remotes\":\nfor remote in parser[section].items():\nif remote[1] is None:\nremotes.append(remote[0])\nelse:\nremotes.append((remote[1], remote[0]))\nelse:\ninstances.append(i.InstanceSpec.from_cfg(parser[section]))\nscheme = scheme or sync.DEFAULT_PROTOCOL\nnetloc = netloc or sync.get_default_netloc()\nuri = ParseResult(\nscheme=scheme, netloc=netloc, path=path, params=\"\", query=\"\", fragment=\"\"\n)\nreturn EnderChest(uri, name, remotes, instances)\ndef write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n\"\"\"Write this EnderChest's configuration to INI\n        Parameters\n        ----------\n        config_file : Path, optional\n            The path to the config file, assuming you'd like to write the\n            contents to file\n        Returns\n        -------\n        str\n            An INI-syntax rendering of this EnderChest's config\n        Notes\n        -----\n        The \"root\" attribute is ignored for this method\n        \"\"\"\nconfig = ConfigParser(allow_no_value=True)\nconfig.add_section(\"properties\")\nconfig.set(\"properties\", \"name\", self.name)\nconfig.set(\"properties\", \"address\", self._uri.netloc)\nconfig.set(\"properties\", \"sync-protocol\", self._uri.scheme)\nconfig.set(\"properties\", \"last_modified\", dt.datetime.now().isoformat(sep=\" \"))\nconfig.set(\n\"properties\", \"generated_by_enderchest_version\", get_versions()[\"version\"]\n)\nconfig.add_section(\"remotes\")\nfor uri, name in self.remotes:\nif name != uri.hostname:\nconfig.set(\"remotes\", name, uri.geturl())\nelse:\nconfig.set(\"remotes\", uri.geturl())\nfor instance in self.instances:\nconfig.add_section(instance.name)\nconfig.set(instance.name, \"root\", str(instance.root))\nconfig.set(\ninstance.name,\n\"minecraft_version\",\n_list_to_ini(instance.minecraft_versions),\n)\nconfig.set(instance.name, \"modloader\", instance.modloader)\nconfig.set(\ninstance.name,\n\"tags\",\n_list_to_ini(instance.tags),\n)\nbuffer = StringIO()\nbuffer.write(f\"; {fs.ENDER_CHEST_CONFIG_NAME}\\n\")\nconfig.write(buffer)\nbuffer.seek(0)  # rewind\nif config_file:\nconfig_file.write_text(buffer.read())\nbuffer.seek(0)\nreturn buffer.read()\n</code></pre>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.EnderChest.from_cfg","title":"<code>from_cfg(config_file)</code>  <code>classmethod</code>","text":"<p>Parse an EnderChest from its config file</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path</code> <p>The path to the config file</p> required <p>Returns:</p> Type Description <code>EnderChest</code> <p>The resulting EnderChest</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the config file at that location cannot be parsed</p> <code>FileNotFoundError</code> <p>If there is no config file at the specified location</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>@classmethod\ndef from_cfg(cls, config_file: Path) -&gt; \"EnderChest\":\n\"\"\"Parse an EnderChest from its config file\n    Parameters\n    ----------\n    config_file : Path\n        The path to the config file\n    Returns\n    -------\n    EnderChest\n        The resulting EnderChest\n    Raises\n    ------\n    ValueError\n        If the config file at that location cannot be parsed\n    FileNotFoundError\n        If there is no config file at the specified location\n    \"\"\"\nparser = ConfigParser(\nallow_no_value=True, delimiters=(\"=\",), inline_comment_prefixes=(\";\",)\n)\ntry:\nassert parser.read(config_file)\nexcept ParsingError as bad_cfg:\nraise ValueError(f\"Could not parse {config_file}\") from bad_cfg\nexcept AssertionError:\nraise FileNotFoundError(f\"Could not open {config_file}\")\n# All I'm gonna say is that Windows pathing is the worst\npath = urlparse(config_file.absolute().parent.parent.as_uri()).path\ninstances: list[i.InstanceSpec] = []\nremotes: list[str | tuple[str, str]] = []\nscheme: str | None = None\nnetloc: str | None = None\nname: str | None = None\nfor section in parser.sections():\nif section == \"properties\":\nscheme = parser[section].get(\"sync-protocol\")\nnetloc = parser[section].get(\"address\")\nname = parser[section].get(\"name\")\nelif section == \"remotes\":\nfor remote in parser[section].items():\nif remote[1] is None:\nremotes.append(remote[0])\nelse:\nremotes.append((remote[1], remote[0]))\nelse:\ninstances.append(i.InstanceSpec.from_cfg(parser[section]))\nscheme = scheme or sync.DEFAULT_PROTOCOL\nnetloc = netloc or sync.get_default_netloc()\nuri = ParseResult(\nscheme=scheme, netloc=netloc, path=path, params=\"\", query=\"\", fragment=\"\"\n)\nreturn EnderChest(uri, name, remotes, instances)\n</code></pre>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.EnderChest.register_instance","title":"<code>register_instance(instance)</code>","text":"<p>Register a new Minecraft installation</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>InstanceSpec</code> <p>The instance to register</p> required <p>Returns:</p> Type Description <code>InstanceSpec</code> <p>The spec of the instance as it was actually registered (in case the name changed or somesuch)</p>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.EnderChest.register_instance--notes","title":"Notes","text":"<ul> <li>If the instance's name is already assigned to a registered instance,   this method will choose a new one</li> <li>If this instance shares a path with an existing instance, it will   replace that instance</li> </ul> Source code in <code>enderchest/enderchest.py</code> <pre><code>def register_instance(self, instance: i.InstanceSpec) -&gt; i.InstanceSpec:\n\"\"\"Register a new Minecraft installation\n    Parameters\n    ----------\n    instance : InstanceSpec\n        The instance to register\n    Returns\n    -------\n    InstanceSpec\n        The spec of the instance as it was actually registered (in case the\n        name changed or somesuch)\n    Notes\n    -----\n    - If the instance's name is already assigned to a registered instance,\n      this method will choose a new one\n    - If this instance shares a path with an existing instance, it will\n      replace that instance\n    \"\"\"\nself._instances = [\nold_instance\nfor old_instance in self._instances\nif not i.equals(Path(self._uri.path), instance, old_instance)\n]\nname = instance.name\ncounter = 0\ntaken_names = {old_instance.name for old_instance in self._instances}\nwhile True:\nif name not in taken_names:\nbreak\ncounter += 1\nname = f\"{instance.name}.{counter}\"\nGATHER_LOGGER.debug(f\"Registering instance {instance.name} at {instance.root}\")\nself._instances.append(instance._replace(name=name))\nreturn self._instances[-1]\n</code></pre>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.EnderChest.register_remote","title":"<code>register_remote(remote, alias=None)</code>","text":"<p>Register a new remote EnderChest installation (or update an existing registry)</p> <p>Parameters:</p> Name Type Description Default <code>remote</code> <code>URI</code> <p>The URI of the remote</p> required <code>alias</code> <code>str, optional</code> <p>an alias to give to this remote. If None is provided, the URI's hostname will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided remote is invalid</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>def register_remote(\nself, remote: str | ParseResult, alias: str | None = None\n) -&gt; None:\n\"\"\"Register a new remote EnderChest installation (or update an existing\n    registry)\n    Parameters\n    ----------\n    remote : URI\n        The URI of the remote\n    alias : str, optional\n        an alias to give to this remote. If None is provided, the URI's hostname\n        will be used.\n    Raises\n    ------\n    ValueError\n        If the provided remote is invalid\n    \"\"\"\ntry:\nremote = remote if isinstance(remote, ParseResult) else urlparse(remote)\nalias = alias or remote.hostname\nif not alias:\nraise AttributeError(f\"{remote.geturl()} has no hostname\")\nGATHER_LOGGER.debug(f\"Registering remote {remote.geturl()} ({alias})\")\nself._remotes[alias] = remote\nexcept AttributeError as parse_problem:\nraise ValueError(f\"{remote} is not a valid URI\") from parse_problem\n</code></pre>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.EnderChest.write_to_cfg","title":"<code>write_to_cfg(config_file=None)</code>","text":"<p>Write this EnderChest's configuration to INI</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path, optional</code> <p>The path to the config file, assuming you'd like to write the contents to file</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>An INI-syntax rendering of this EnderChest's config</p>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.EnderChest.write_to_cfg--notes","title":"Notes","text":"<p>The \"root\" attribute is ignored for this method</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>def write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n\"\"\"Write this EnderChest's configuration to INI\n    Parameters\n    ----------\n    config_file : Path, optional\n        The path to the config file, assuming you'd like to write the\n        contents to file\n    Returns\n    -------\n    str\n        An INI-syntax rendering of this EnderChest's config\n    Notes\n    -----\n    The \"root\" attribute is ignored for this method\n    \"\"\"\nconfig = ConfigParser(allow_no_value=True)\nconfig.add_section(\"properties\")\nconfig.set(\"properties\", \"name\", self.name)\nconfig.set(\"properties\", \"address\", self._uri.netloc)\nconfig.set(\"properties\", \"sync-protocol\", self._uri.scheme)\nconfig.set(\"properties\", \"last_modified\", dt.datetime.now().isoformat(sep=\" \"))\nconfig.set(\n\"properties\", \"generated_by_enderchest_version\", get_versions()[\"version\"]\n)\nconfig.add_section(\"remotes\")\nfor uri, name in self.remotes:\nif name != uri.hostname:\nconfig.set(\"remotes\", name, uri.geturl())\nelse:\nconfig.set(\"remotes\", uri.geturl())\nfor instance in self.instances:\nconfig.add_section(instance.name)\nconfig.set(instance.name, \"root\", str(instance.root))\nconfig.set(\ninstance.name,\n\"minecraft_version\",\n_list_to_ini(instance.minecraft_versions),\n)\nconfig.set(instance.name, \"modloader\", instance.modloader)\nconfig.set(\ninstance.name,\n\"tags\",\n_list_to_ini(instance.tags),\n)\nbuffer = StringIO()\nbuffer.write(f\"; {fs.ENDER_CHEST_CONFIG_NAME}\\n\")\nconfig.write(buffer)\nbuffer.seek(0)  # rewind\nif config_file:\nconfig_file.write_text(buffer.read())\nbuffer.seek(0)\nreturn buffer.read()\n</code></pre>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.create_ender_chest","title":"<code>create_ender_chest(minecraft_root, ender_chest)</code>","text":"<p>Create an EnderChest based on the provided configuration</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff is in (or, at least, the one inside which you want to create your EnderChest)</p> required <code>ender_chest</code> <code>EnderChest</code> <p>The spec of the chest to create</p> required"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.create_ender_chest--notes","title":"Notes","text":"<ul> <li>The \"root\" attribute of the EnderChest config will be ignored--instead   the EnderChest will be created at /EnderChest <li>This method does not check to see if there is already an EnderChest set   up at the specified location--if one exists, its config will   be overwritten</li> Source code in <code>enderchest/enderchest.py</code> <pre><code>def create_ender_chest(minecraft_root: Path, ender_chest: EnderChest) -&gt; None:\n\"\"\"Create an EnderChest based on the provided configuration\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff is in (or, at least, the\n        one inside which you want to create your EnderChest)\n    ender_chest : EnderChest\n        The spec of the chest to create\n    Notes\n    -----\n    - The \"root\" attribute of the EnderChest config will be ignored--instead\n      the EnderChest will be created at &lt;minecraft_root&gt;/EnderChest\n    - This method does not check to see if there is already an EnderChest set\n      up at the specified location--if one exists, its config will\n      be overwritten\n    \"\"\"\nroot = fs.ender_chest_folder(minecraft_root, check_exists=False)\nroot.mkdir(exist_ok=True)\nconfig_path = fs.ender_chest_config(minecraft_root, check_exists=False)\nender_chest.write_to_cfg(config_path)\nCRAFT_LOGGER.info(f\"EnderChest configuration written to {config_path}\")\n</code></pre>"},{"location":"reference/enderchest/filesystem/","title":"filesystem","text":"<p>Functionality for managing the EnderChest and shulker box config files and folders</p>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.ender_chest_config","title":"<code>ender_chest_config(minecraft_root, check_exists=True)</code>","text":"<p>Given a minecraft root directory, return the path to the EnderChest config file</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>check_exists</code> <code>bool, optional</code> <p>By default, this method will raise an error if the enderchest config file does not already exist. To disable that check, call this method with <code>check_exists=False</code></p> <code>True</code> <p>Returns:</p> Type Description <code>Path</code> <p>The path to the EnderChest config file</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the EnderChest config file isn't where it's supposed to be (and checking hasn't been disabled)</p>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.ender_chest_config--notes","title":"Notes","text":"<p>This method does not check if the config file is valid</p> Source code in <code>enderchest/filesystem.py</code> <pre><code>def ender_chest_config(minecraft_root, check_exists: bool = True) -&gt; Path:\n\"\"\"Given a minecraft root directory, return the path to the EnderChest\n    config file\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    check_exists : bool, optional\n        By default, this method will raise an error if the enderchest config\n        file does not already exist. To disable that check, call this method\n        with `check_exists=False`\n    Returns\n    -------\n    Path\n        The path to the EnderChest config file\n    Raises\n    ------\n    FileNotFoundError\n        If the EnderChest config file isn't where it's supposed to be (and\n        checking hasn't been disabled)\n    Notes\n    -----\n    This method does not check if the config file is valid\n    \"\"\"\nconfig_path = minecraft_root / ENDER_CHEST_FOLDER_NAME / ENDER_CHEST_CONFIG_NAME\nif check_exists and not config_path.exists():\nraise FileNotFoundError(\nf\"No valid EnderChest installation exists within {minecraft_root}\"\n)\nreturn config_path\n</code></pre>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.ender_chest_folder","title":"<code>ender_chest_folder(minecraft_root, check_exists=True)</code>","text":"<p>Given a minecraft root directory, return the path to the EnderChest folder</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>check_exists</code> <code>bool, optional</code> <p>By default, this method will raise an error if no EnderChest exists at that location (meaning no folder or no enderchest config file in that folder). To disable that check, call this method with <code>check_exists=False</code></p> <code>True</code> <p>Returns:</p> Type Description <code>Path</code> <p>The path to the EnderChest folder</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If no valid EnderChest installation exists within the given minecraft root (and checking hasn't been disabled)</p> Source code in <code>enderchest/filesystem.py</code> <pre><code>def ender_chest_folder(minecraft_root: Path, check_exists: bool = True) -&gt; Path:\n\"\"\"Given a minecraft root directory, return the path to the EnderChest\n    folder\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    check_exists : bool, optional\n        By default, this method will raise an error if no EnderChest exists\n        at that location (meaning no folder or no enderchest config file in\n        that folder). To disable that check, call this method with\n        `check_exists=False`\n    Returns\n    -------\n    Path\n        The path to the EnderChest folder\n    Raises\n    ------\n    FileNotFoundError\n        If no valid EnderChest installation exists within the given\n        minecraft root (and checking hasn't been disabled)\n    \"\"\"\nreturn ender_chest_config(minecraft_root, check_exists=check_exists).parent\n</code></pre>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.minecraft_folders","title":"<code>minecraft_folders(search_path)</code>","text":"<p>Find all .minecraft folders within a given search path</p> <p>Parameters:</p> Name Type Description Default <code>search_path</code> <code>Path</code> <p>The directory to search</p> required <p>Returns:</p> Type Description <code>list-like of paths</code> <p>The paths to all the .minecraft folders this method could find</p>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.minecraft_folders--notes","title":"Notes","text":"<p>This method does not check to make sure that those .minecraft folders contain valid minecraft instances, just that they exist</p> Source code in <code>enderchest/filesystem.py</code> <pre><code>def minecraft_folders(search_path: Path) -&gt; Iterable[Path]:\n\"\"\"Find all .minecraft folders within a given search path\n    Parameters\n    ----------\n    search_path : Path\n        The directory to search\n    Returns\n    -------\n    list-like of paths\n        The paths to all the .minecraft folders this method could find\n    Notes\n    -----\n    This method does not check to make sure that those .minecraft folders\n    contain valid minecraft instances, just that they exist\n    \"\"\"\nreturn search_path.rglob(\".minecraft\")\n</code></pre>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.shulker_box_config","title":"<code>shulker_box_config(minecraft_root, shulker_box_name)</code>","text":"<p>Generate the path to a shulker box config file, given its name and the minecraft root directory</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The path to the shulker box folder</p>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.shulker_box_config--notes","title":"Notes","text":"<p>This method does not check if a shulker box config exists at that location</p> Source code in <code>enderchest/filesystem.py</code> <pre><code>def shulker_box_config(minecraft_root: Path, shulker_box_name: str) -&gt; Path:\n\"\"\"Generate the path to a shulker box config file, given its name and\n    the minecraft root directory\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    Returns\n    -------\n    Path\n        The path to the shulker box folder\n    Notes\n    -----\n    This method does not check if a shulker box config exists at that location\n    \"\"\"\nreturn shulker_box_root(minecraft_root, shulker_box_name) / SHULKER_BOX_CONFIG_NAME\n</code></pre>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.shulker_box_configs","title":"<code>shulker_box_configs(minecraft_root)</code>","text":"<p>Find all shulker box configs on the system</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <p>Returns:</p> Type Description <code>list-like of paths</code> <p>The paths to all the shulker box configs on the system</p>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.shulker_box_configs--notes","title":"Notes","text":"<p>This method does not check to make sure those config files are valid, just that they exist</p> Source code in <code>enderchest/filesystem.py</code> <pre><code>def shulker_box_configs(minecraft_root: Path) -&gt; Iterable[Path]:\n\"\"\"Find all shulker box configs on the system\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    Returns\n    -------\n    list-like of paths\n        The paths to all the shulker box configs on the system\n    Notes\n    -----\n    This method does not check to make sure those config files are valid,\n    just that they exist\n    \"\"\"\nGATHER_LOGGER.debug(f\"Searching for shulker configs within {minecraft_root}\")\nreturn ender_chest_folder(minecraft_root).glob(f\"*/{SHULKER_BOX_CONFIG_NAME}\")\n</code></pre>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.shulker_box_root","title":"<code>shulker_box_root(minecraft_root, shulker_box_name)</code>","text":"<p>Generate the path to the root of a shulker box, given its name and the minecraft root directory</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The path to the shulker box folder</p>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.shulker_box_root--notes","title":"Notes","text":"<p>This method does not check if a shulker box exists at that location</p> Source code in <code>enderchest/filesystem.py</code> <pre><code>def shulker_box_root(minecraft_root: Path, shulker_box_name: str) -&gt; Path:\n\"\"\"Generate the path to the root of a shulker box, given its name and the\n    minecraft root directory\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    Returns\n    -------\n    Path\n        The path to the shulker box folder\n    Notes\n    -----\n    This method does not check if a shulker box exists at that location\n    \"\"\"\nreturn ender_chest_folder(minecraft_root) / shulker_box_name\n</code></pre>"},{"location":"reference/enderchest/gather/","title":"gather","text":"<p>Functionality for finding, resolving and parsing local installations and instances</p>"},{"location":"reference/enderchest/gather/#enderchest.gather.gather_metadata_for_mmc_instance","title":"<code>gather_metadata_for_mmc_instance(minecraft_folder, instgroups_file=None)</code>","text":"<p>Parse files to generate metadata for a MultiMC-like instance</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_folder</code> <code>Path</code> <p>The path to the installation's .minecraft folder</p> required <code>instgroups_file</code> <code>Path</code> <p>The path to instgroups.json. If None is provided, this method will look for it two directories up from the minecraft folder</p> <code>None</code> <p>Returns:</p> Type Description <code>InstanceSpec</code> <p>The metadata for this instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If this is not a valid MMC-like Minecraft instance</p>"},{"location":"reference/enderchest/gather/#enderchest.gather.gather_metadata_for_mmc_instance--notes","title":"Notes","text":"<p>If this method is failing to find the appropriate files, you may want to try ensuring that minecraft_folder is an absolute path.</p> Source code in <code>enderchest/gather.py</code> <pre><code>def gather_metadata_for_mmc_instance(\nminecraft_folder: Path, instgroups_file: Path | None = None\n) -&gt; InstanceSpec:\n\"\"\"Parse files to generate metadata for a MultiMC-like instance\n    Parameters\n    ----------\n    minecraft_folder : Path\n        The path to the installation's .minecraft folder\n    instgroups_file : Path\n        The path to instgroups.json. If None is provided, this method will\n        look for it two directories up from the minecraft folder\n    Returns\n    -------\n    InstanceSpec\n        The metadata for this instance\n    Raises\n    ------\n    ValueError\n        If this is not a valid MMC-like Minecraft instance\n    Notes\n    -----\n    If this method is failing to find the appropriate files, you may want\n    to try ensuring that minecraft_folder is an absolute path.\n    \"\"\"\nmmc_pack_file = minecraft_folder.parent / \"mmc-pack.json\"\ntry:\nwith mmc_pack_file.open() as mmc_json:\ncomponents: list[dict] = json.load(mmc_json)[\"components\"]\nversion: str | None = None\nmodloader: str | None = None\nfor component in components:\nmatch component.get(\"uid\"), component.get(\"cachedName\", \"\"):\ncase \"net.minecraft\", _:\nversion = component[\"version\"]\ncase \"net.fabricmc.fabric-loader\", _:\nmodloader = \"Fabric Loader\"\ncase \"org.quiltmc.quilt-loader\", _:\nmodloader = \"Quilt Loader\"\ncase (\"net.minecraftforge\", _) | (_, \"Forge\"):\nmodloader = \"Forge\"\ncase _, name if name.endswith(\"oader\"):\nmodloader = name\ncase _:\ncontinue\nif version is None:\nraise KeyError(\"Could not find a net.minecraft component\")\nexcept FileNotFoundError as no_json:\nraise ValueError(f\"Could not find {mmc_pack_file}\") from no_json\nexcept json.JSONDecodeError as bad_json:\nraise ValueError(\nf\"{mmc_pack_file} is corrupt and could not be parsed\"\n) from bad_json\nexcept KeyError as weird_json:\nraise ValueError(\nf\"Could not parse metadata from {mmc_pack_file}\"\n) from weird_json\nname = minecraft_folder.parent.name\ntags: list[str] = []\nif name == \"\":\nGATHER_LOGGER.warn(\n\"Could not resolve the name of the parent folder\"\n\" and thus could not load tags.\"\n)\nelse:\ninstgroups_file = (\ninstgroups_file or minecraft_folder.parent.parent / \"instgroups.json\"\n)\ntry:\nwith instgroups_file.open() as groups_json:\ngroups: dict[str, dict] = json.load(groups_json)[\"groups\"]\nfor tag, metadata in groups.items():\n# interestingly this comes from the folder name, not the actual name\nif name in metadata.get(\"instances\", ()):\ntags.append(tag)\nexcept FileNotFoundError as no_json:\nGATHER_LOGGER.warn(\nf\"Could not find {instgroups_file} and thus could not load tags\"\n)\nexcept json.JSONDecodeError as bad_json:\nGATHER_LOGGER.warn(\nf\"{instgroups_file} is corrupt and could not be parsed for tags\"\n)\nexcept KeyError as weird_json:\nGATHER_LOGGER.warn(f\"Could not parse tags from {instgroups_file}\")\ninstance_cfg = minecraft_folder.parent / \"instance.cfg\"\ntry:\nparser = ConfigParser(allow_no_value=True)\nparser.read_string(\"[instance]\\n\" + instance_cfg.read_text())\nname = parser[\"instance\"][\"name\"]\nexcept FileNotFoundError as no_cfg:\nGATHER_LOGGER.warn(\nf\"Could not find {instance_cfg} and thus could not load the instance name\"\n)\nexcept ParsingError as no_cfg:\nGATHER_LOGGER.warn(\nf\"{instance_cfg} is corrupt and could not be parsed the instance name\"\n)\nexcept KeyError as weird_json:\nGATHER_LOGGER.warn(f\"Could not parse instance name from {instance_cfg}\")\nif name == \"\":\nraise ValueError(\"Could not determine the name of the instance.\")\nreturn InstanceSpec(name, minecraft_folder, (version,), modloader, tuple(tags))\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.gather_metadata_for_official_instance","title":"<code>gather_metadata_for_official_instance(minecraft_folder, name='official')</code>","text":"<p>Parse files to generate metadata for an official Minecraft installation</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_folder</code> <code>Path</code> <p>The path to the installation's .minecraft folder</p> required <code>name</code> <code>str, optional</code> <p>A name or alias to give to the instance. If None is provided, the default name is \"official\"</p> <code>'official'</code> <p>Returns:</p> Type Description <code>InstanceSpec</code> <p>The metadata for this instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If this is not a valid official Minecraft installation</p>"},{"location":"reference/enderchest/gather/#enderchest.gather.gather_metadata_for_official_instance--notes","title":"Notes","text":"<p>This method will always consider this instance to be vanilla, with no modloader. If a Forge or Fabric executable is installed inside this instance, the precise name of that version of that modded minecraft will be included in the version list.</p> Source code in <code>enderchest/gather.py</code> <pre><code>def gather_metadata_for_official_instance(\nminecraft_folder: Path, name: str = \"official\"\n) -&gt; InstanceSpec:\n\"\"\"Parse files to generate metadata for an official Minecraft installation\n    Parameters\n    ----------\n    minecraft_folder : Path\n        The path to the installation's .minecraft folder\n    name : str, optional\n        A name or alias to give to the instance. If None is provided, the\n        default name is \"official\"\n    Returns\n    -------\n    InstanceSpec\n        The metadata for this instance\n    Raises\n    ------\n    ValueError\n        If this is not a valid official Minecraft installation\n    Notes\n    -----\n    This method will always consider this instance to be vanilla, with no\n    modloader. If a Forge or Fabric executable is installed inside this\n    instance, the precise name of that version of that modded minecraft\n    will be included in the version list.\n    \"\"\"\nlauncher_profile_file = minecraft_folder / \"launcher_profiles.json\"\ntry:\nwith launcher_profile_file.open() as lp_json:\nlauncher_profiles = json.load(lp_json)\nraw_versions: list[str] = [\nprofile[\"lastVersionId\"]\nfor profile in launcher_profiles[\"profiles\"].values()\n]\nexcept FileNotFoundError as no_json:\nraise ValueError(f\"Could not find {launcher_profile_file}\") from no_json\nexcept json.JSONDecodeError as bad_json:\nraise ValueError(\nf\"{launcher_profile_file} is corrupt and could not be parsed\"\n) from bad_json\nexcept KeyError as weird_json:\nraise ValueError(\nf\"Could not parse metadata from {launcher_profile_file}\"\n) from weird_json\nversion_manifest_file = minecraft_folder / \"versions\" / \"version_manifest_v2.json\"\ntry:\nwith version_manifest_file.open() as vm_json:\nversion_lookup: dict[str, str] = json.load(vm_json)[\"latest\"]\nexcept FileNotFoundError as no_json:\nraise ValueError(f\"Could not find {version_manifest_file}\") from no_json\nexcept json.JSONDecodeError as bad_json:\nraise ValueError(\nf\"{version_manifest_file} is corrupt and could not be parsed\"\n) from bad_json\nexcept KeyError as weird_json:\nGATHER_LOGGER.warn(\nf\"{version_manifest_file} has no latest-version lookup.\"\n\"\\nPlease check the parsed metadata to ensure that it's accurate.\",\n)\nversion_lookup = {}\nversions: list[str] = []\ntags: list[str] = [\"vanilla\"]\nfor version in raw_versions:\nif version.startswith(\"latest-\"):\nmapped_version = version_lookup.get(version[len(\"latest-\") :])\nif mapped_version is not None:\nversions.append(mapped_version)\ntags.append(version)\ncontinue\nversions.append(version)\nreturn InstanceSpec(name, minecraft_folder, tuple(versions), None, tuple(tags))\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.gather_minecraft_instances","title":"<code>gather_minecraft_instances(minecraft_root, search_path, official)</code>","text":"<p>Search the specified directory for Minecraft installations and return any that are can be found and parsed</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder). This will be used to construct relative paths.</p> required <code>search_path</code> <code>Path</code> <p>The path to search</p> required <code>official</code> <code>bool or None</code> <p>Whether we expect that the instances found in this location will be: - from the official launcher (official=True) - from a MultiMC-style launcher (official=False) - a mix / unsure (official=None)</p> required <p>Returns:</p> Type Description <code>list of InstanceSpec</code> <p>A list of parsed instances</p>"},{"location":"reference/enderchest/gather/#enderchest.gather.gather_minecraft_instances--notes","title":"Notes","text":"<ul> <li>If a minecraft installation is found but cannot be parsed   (or parsed as specified) this method will report that failure but then   continue on.</li> <li>As a corollary, if no valid Minecraft installations can be found, this   method will return an empty list.</li> </ul> Source code in <code>enderchest/gather.py</code> <pre><code>def gather_minecraft_instances(\nminecraft_root: Path, search_path: Path, official: bool | None\n) -&gt; list[InstanceSpec]:\n\"\"\"Search the specified directory for Minecraft installations and return\n    any that are can be found and parsed\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder). This will be used to\n        construct relative paths.\n    search_path : Path\n        The path to search\n    official : bool or None\n        Whether we expect that the instances found in this location will be:\n          - from the official launcher (official=True)\n          - from a MultiMC-style launcher (official=False)\n          - a mix / unsure (official=None)\n    Returns\n    -------\n    list of InstanceSpec\n        A list of parsed instances\n    Notes\n    -----\n    - If a minecraft installation is found but cannot be parsed\n      (or parsed as specified) this method will report that failure but then\n      continue on.\n    - As a corollary, if _no_ valid Minecraft installations can be found, this\n      method will return an empty list.\n    \"\"\"\nGATHER_LOGGER.debug(f\"Searching for Minecraft folders inside {search_path}\")\ninstances: list[InstanceSpec] = []\nfor folder in fs.minecraft_folders(search_path):\nfolder_path = folder.absolute()\nGATHER_LOGGER.debug(f\"Found minecraft installation at {folder}\")\nif official is not False:\ntry:\ninstances.append(gather_metadata_for_official_instance(folder_path))\nGATHER_LOGGER.info(\nf\"Gathered official Minecraft installation from {folder}\"\n)\ncontinue\nexcept ValueError as not_official:\nGATHER_LOGGER.log(\nlogging.DEBUG if official is None else logging.WARNING,\n(f\"{folder} is not an official instance:\" f\"\\n{not_official}\",),\n)\nif official is not True:\ntry:\ninstances.append(gather_metadata_for_mmc_instance(folder_path))\nGATHER_LOGGER.info(\nf\"Gathered MMC-like Minecraft installation from {folder}\"\n)\ncontinue\nexcept ValueError as not_mmc:\nGATHER_LOGGER.log(\nlogging.DEBUG if official is None else logging.WARNING,\nf\"{folder} is not an MMC-like instance:\\n{not_mmc}\",\n)\nGATHER_LOGGER.warning(\nf\"{folder_path} does not appear to be a valid Minecraft instance\"\n)\nfor i, mc_instance in enumerate(instances):\ntry:\ninstances[i] = mc_instance._replace(\nroot=mc_instance.root.relative_to(minecraft_root)\n)\nexcept ValueError:\n# TODO: if not Windows, try making relative to \"~\"\npass  # instance isn't inside the minecraft root\nif not instances:\nGATHER_LOGGER.warning(\nf\"Could not find any Minecraft instances inside {search_path}\"\n)\nreturn instances\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_ender_chest","title":"<code>load_ender_chest(minecraft_root)</code>","text":"<p>Load the configuration from the enderchest.cfg file in the EnderChest folder.</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <p>Returns:</p> Type Description <code>EnderChest</code> <p>The EnderChest configuration</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If no EnderChest folder exists in the given minecraft root or if no enderchest.cfg file exists within that EnderChest folder</p> Source code in <code>enderchest/gather.py</code> <pre><code>def load_ender_chest(minecraft_root: Path) -&gt; EnderChest:\n\"\"\"Load the configuration from the enderchest.cfg file in the EnderChest\n    folder.\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    Returns\n    -------\n    EnderChest\n        The EnderChest configuration\n    Raises\n    ------\n    FileNotFoundError\n        If no EnderChest folder exists in the given minecraft root or if no\n        enderchest.cfg file exists within that EnderChest folder\n    \"\"\"\nconfig_path = fs.ender_chest_config(minecraft_root)\nGATHER_LOGGER.debug(f\"Loading {config_path}\")\nender_chest = EnderChest.from_cfg(config_path)\nGATHER_LOGGER.debug(f\"Parsed EnderChest installation from {minecraft_root}\")\nreturn ender_chest\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_ender_chest_instances","title":"<code>load_ender_chest_instances(minecraft_root, log_level=logging.INFO)</code>","text":"<p>Get the list of instances registered with the EnderChest located in the minecraft root</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>log_level</code> <code>int, optional</code> <p>By default, this method will report out the minecraft instances it finds at the INFO level. You can optionally pass in a lower (or higher) level if this method is being called from another method where that information is redundant or overly verbose.</p> <code>logging.INFO</code> <p>Returns:</p> Type Description <code>list of InstanceSpec</code> <p>The instances registered with the EnderChest</p>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_ender_chest_instances--notes","title":"Notes","text":"<p>If no EnderChest is installed in the given location, then this will return an empty list rather than failing outright.</p> Source code in <code>enderchest/gather.py</code> <pre><code>def load_ender_chest_instances(\nminecraft_root: Path, log_level: int = logging.INFO\n) -&gt; Sequence[InstanceSpec]:\n\"\"\"Get the list of instances registered with the EnderChest located in the\n    minecraft root\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    log_level : int, optional\n        By default, this method will report out the minecraft instances it\n        finds at the INFO level. You can optionally pass in a lower (or higher)\n        level if this method is being called from another method where that\n        information is redundant or overly verbose.\n    Returns\n    -------\n    list of InstanceSpec\n        The instances registered with the EnderChest\n    Notes\n    -----\n    If no EnderChest is installed in the given location, then this will return\n    an empty list rather than failing outright.\n    \"\"\"\ntry:\nender_chest = load_ender_chest(minecraft_root)\ninstances: Sequence[InstanceSpec] = ender_chest.instances\nexcept (FileNotFoundError, ValueError) as bad_chest:\nGATHER_LOGGER.error(\nf\"Could not load EnderChest from {minecraft_root}:\\n  {bad_chest}\"\n)\ninstances = []\nif len(instances) == 0:\nGATHER_LOGGER.warning(\nf\"There are no instances registered to the {minecraft_root} EnderChest\",\n)\nelse:\nGATHER_LOGGER.log(\nlog_level,\n\"These are the instances that are currently registered\"\nf\" to the {minecraft_root} EnderChest:\\n\"\n+ \"\\n\".join(\n[\nf\"  {i + 1}. {_render_instance(instance)})\"\nfor i, instance in enumerate(instances)\n]\n),\n)\nreturn instances\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_ender_chest_remotes","title":"<code>load_ender_chest_remotes(minecraft_root, log_level=logging.INFO)</code>","text":"<p>Load all remote EnderChest installations registered with this one</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>log_level</code> <code>int, optional</code> <p>By default, this method will report out the minecraft instances it finds at the INFO level. You can optionally pass in a lower (or higher) level if this method is being called from another method where that information is redundant or overly verbose.</p> <code>logging.INFO</code> <p>Returns:</p> Type Description <code>list of (URI, str) tuples</code> <p>The URIs of the remote EnderChests, paired with their aliases</p>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_ender_chest_remotes--notes","title":"Notes","text":"<p>If no EnderChest is installed in the given location, then this will return an empty list rather than failing outright.</p> Source code in <code>enderchest/gather.py</code> <pre><code>def load_ender_chest_remotes(\nminecraft_root: Path, log_level: int = logging.INFO\n) -&gt; list[tuple[ParseResult, str]]:\n\"\"\"Load all remote EnderChest installations registered with this one\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    log_level : int, optional\n        By default, this method will report out the minecraft instances it\n        finds at the INFO level. You can optionally pass in a lower (or higher)\n        level if this method is being called from another method where that\n        information is redundant or overly verbose.\n    Returns\n    -------\n    list of (URI, str) tuples\n        The URIs of the remote EnderChests, paired with their aliases\n    Notes\n    -----\n    If no EnderChest is installed in the given location, then this will return\n    an empty list rather than failing outright.\n    \"\"\"\ntry:\nender_chest = load_ender_chest(minecraft_root)\nremotes: Sequence[tuple[ParseResult, str]] = ender_chest.remotes\nexcept (FileNotFoundError, ValueError) as bad_chest:\nGATHER_LOGGER.error(\nf\"Could not load EnderChest from {minecraft_root}:\\n  {bad_chest}\"\n)\nremotes = ()\nif len(remotes) == 0:\nif log_level &gt;= logging.INFO:\nGATHER_LOGGER.warning(\nf\"There are no remotes registered to the {minecraft_root} EnderChest\"\n)\nreturn []\nreport = (\n\"These are the remote EnderChest installations registered\"\nf\" to the one installed at {minecraft_root}\"\n)\nremote_list: list[tuple[ParseResult, str]] = []\nfor remote, alias in remotes:\nreport += f\"\\n  - {render_remote(alias, remote)}\"\nremote_list.append((remote, alias))\nGATHER_LOGGER.log(log_level, report)\nreturn remote_list\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_shulker_box_matches","title":"<code>load_shulker_box_matches(minecraft_root, shulker_box_name)</code>","text":"<p>Get the list of registered instances that link to the specified shulker box</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>shulker_box_name</code> <code>str</code> <p>The name of the shulker box you're asking about</p> required <p>Returns:</p> Type Description <code>list of InstanceSpec</code> <p>The instances that are / should be linked to the specified shulker box</p> Source code in <code>enderchest/gather.py</code> <pre><code>def load_shulker_box_matches(\nminecraft_root: Path, shulker_box_name: str\n) -&gt; Sequence[InstanceSpec]:\n\"\"\"Get the list of registered instances that link to the specified shulker box\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    shulker_box_name : str\n        The name of the shulker box you're asking about\n    Returns\n    -------\n    list of InstanceSpec\n        The instances that are / should be linked to the specified shulker box\n    \"\"\"\ntry:\nconfig_file = fs.shulker_box_config(minecraft_root, shulker_box_name)\nexcept FileNotFoundError:\nGATHER_LOGGER.error(f\"No EnderChest is installed in {minecraft_root}\")\nreturn ()\ntry:\nshulker_box = _load_shulker_box(config_file)\nexcept (FileNotFoundError, ValueError) as bad_box:\nGATHER_LOGGER.error(\nf\"Could not load shulker box {shulker_box_name}\\n  {bad_box}\"\n)\nreturn ()\ninstances = load_ender_chest_instances(minecraft_root, log_level=logging.DEBUG)\nif not instances:\nreturn instances\nif shulker_box is None:\nreturn ()\nmatches = [instance for instance in instances if shulker_box.matches(instance)]\nif len(matches) == 0:\nreport = \"does not link to by any registered instances\"\nelse:\nreport = \"is linked to by the following instancs:\\n\" + \"\\n\".join(\nf\"  - {_render_instance(instance)}\" for instance in matches\n)\nGATHER_LOGGER.info(f\"The shulker box {_render_shulker_box(shulker_box)} {report}\")\nreturn matches\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_shulker_boxes","title":"<code>load_shulker_boxes(minecraft_root, log_level=logging.INFO)</code>","text":"<p>Load all shulker boxes in the EnderChest folder and return them in the order in which they should be linked.</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>log_level</code> <code>int, optional</code> <p>By default, this method will report out the minecraft instances it finds at the INFO level. You can optionally pass in a lower (or higher) level if this method is being called from another method where that information is redundant or overly verbose.</p> <code>logging.INFO</code> <p>Returns:</p> Type Description <code>list of ShulkerBoxes</code> <p>The shulker boxes found in the EnderChest folder, ordered in terms of the sequence in which they should be linked</p>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_shulker_boxes--notes","title":"Notes","text":"<p>If no EnderChest is installed in the given location, then this will return an empty list rather than failing outright.</p> Source code in <code>enderchest/gather.py</code> <pre><code>def load_shulker_boxes(\nminecraft_root: Path, log_level: int = logging.INFO\n) -&gt; list[ShulkerBox]:\n\"\"\"Load all shulker boxes in the EnderChest folder and return them in the\n    order in which they should be linked.\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    log_level : int, optional\n        By default, this method will report out the minecraft instances it\n        finds at the INFO level. You can optionally pass in a lower (or higher)\n        level if this method is being called from another method where that\n        information is redundant or overly verbose.\n    Returns\n    -------\n    list of ShulkerBoxes\n        The shulker boxes found in the EnderChest folder, ordered in terms of\n        the sequence in which they should be linked\n    Notes\n    -----\n    If no EnderChest is installed in the given location, then this will return\n    an empty list rather than failing outright.\n    \"\"\"\nshulker_boxes: list[ShulkerBox] = []\ntry:\nfor shulker_config in fs.shulker_box_configs(minecraft_root):\ntry:\nshulker_boxes.append(_load_shulker_box(shulker_config))\nexcept (FileNotFoundError, ValueError) as bad_shulker:\nGATHER_LOGGER.warning(\nf\"{bad_shulker}\\n  Skipping shulker box {shulker_config.parent.name}\"\n)\nexcept FileNotFoundError:\nGATHER_LOGGER.error(f\"There is no EnderChest installed within {minecraft_root}\")\nreturn []\nshulker_boxes = sorted(shulker_boxes)\nif len(shulker_boxes) == 0:\nif log_level &gt;= logging.INFO:\nGATHER_LOGGER.warning(\nf\"There are no shulker boxes within the {minecraft_root} EnderChest\"\n)\nelse:\n_report_shulker_boxes(\nshulker_boxes, log_level, f\"the {minecraft_root} EnderChest\"\n)\nreturn shulker_boxes\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.update_ender_chest","title":"<code>update_ender_chest(minecraft_root, search_paths=None, official=None, remotes=None)</code>","text":"<p>Orchestration method that coordinates the onboarding of new instances or EnderChest installations</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder).</p> required <code>search_paths</code> <code>list of Paths, optional</code> <p>The local search paths to look for Minecraft installations within. Be warned that this search is performed recursively.</p> <code>None</code> <code>official</code> <code>bool | None, optional</code> <p>Optionally specify whether the Minecraft instances you expect to find are from the official launcher (<code>official=True</code>) or a MultiMC-derivative (<code>official=False</code>).</p> <code>None</code> <code>remotes</code> <code>list of URIs or (URI, str) tuples, optional</code> <p>Any remotes you wish to register to this instance. When a (URI, str) tuple is provided, the second value will be used as the name/alias of the remote. If there is already a remote specified with the given alias, this method will replace it.</p> <code>None</code> Source code in <code>enderchest/gather.py</code> <pre><code>def update_ender_chest(\nminecraft_root: Path,\nsearch_paths: Iterable[str | Path] | None = None,\nofficial: bool | None = None,\nremotes: Iterable[str | ParseResult | tuple[str, str] | tuple[ParseResult, str]]\n| None = None,\n) -&gt; None:\n\"\"\"Orchestration method that coordinates the onboarding of new instances or\n    EnderChest installations\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder).\n    search_paths : list of Paths, optional\n        The local search paths to look for Minecraft installations within.\n        Be warned that this search is performed recursively.\n    official : bool | None, optional\n        Optionally specify whether the Minecraft instances you expect to find\n        are from the official launcher (`official=True`) or a MultiMC-derivative\n        (`official=False`).\n    remotes : list of URIs or (URI, str) tuples, optional\n        Any remotes you wish to register to this instance. When a (URI, str) tuple\n        is provided, the second value will be used as the name/alias of the remote.\n        If there is already a remote specified with the given alias, this method will\n        replace it.\n    \"\"\"\ntry:\nender_chest = load_ender_chest(minecraft_root)\nexcept (FileNotFoundError, ValueError) as bad_chest:\nGATHER_LOGGER.error(\nf\"Could not load EnderChest from {minecraft_root}:\\n  {bad_chest}\"\n)\nreturn\nfor search_path in search_paths or ():\nfor instance in gather_minecraft_instances(\nminecraft_root, Path(search_path), official=official\n):\n_ = ender_chest.register_instance(instance)\nfor remote in remotes or ():\ntry:\nif isinstance(remote, (str, ParseResult)):\nender_chest.register_remote(remote)\nelse:\nender_chest.register_remote(*remote)\nexcept ValueError as bad_remote:\nGATHER_LOGGER.warning(bad_remote)\ncreate_ender_chest(minecraft_root, ender_chest)\n</code></pre>"},{"location":"reference/enderchest/instance/","title":"instance","text":"<p>Specification of a Minecraft instance</p>"},{"location":"reference/enderchest/instance/#enderchest.instance.InstanceSpec","title":"<code>InstanceSpec</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Specification of a Minecraft instance</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The \"display name\" for the instance</p> required <code>root</code> <code>Path</code> <p>The path to its \".minecraft\" folder</p> required <code>minecraft_versions</code> <code>list-like of str</code> <p>The minecraft versions of this instance. This is typically a 1-tuple, but some loaders (such as the official one) will just comingle all your assets together across all profiles</p> required <code>modloader</code> <code>str or None</code> <p>The (display) name of the modloader, or None if this is a vanilla instance</p> required <code>tags</code> <code>list-like of str</code> <p>The tags assigned to this instance</p> required Source code in <code>enderchest/instance.py</code> <pre><code>class InstanceSpec(NamedTuple):\n\"\"\"Specification of a Minecraft instance\n    Parameters\n    ----------\n    name : str\n        The \"display name\" for the instance\n    root : Path\n        The path to its \".minecraft\" folder\n    minecraft_versions : list-like of str\n        The minecraft versions of this instance. This is typically a 1-tuple,\n        but some loaders (such as the official one) will just comingle all\n        your assets together across all profiles\n    modloader : str or None\n        The (display) name of the modloader, or None if this is a vanilla\n        instance\n    tags : list-like of str\n        The tags assigned to this instance\n    \"\"\"\nname: str\nroot: Path\nminecraft_versions: tuple[str, ...]\nmodloader: str | None\ntags: tuple[str, ...]\n@classmethod\ndef from_cfg(cls, section: SectionProxy) -&gt; \"InstanceSpec\":\n\"\"\"Parse an instance spec as read in from the enderchest config file\n        Parameters\n        ----------\n        section : dict-like of str to str\n            The section in the enderchest config as parsed by a ConfigParser\n        Returns\n        -------\n        InstanceSpec\n            The resulting InstanceSpec\n        Raises\n        ------\n        KeyError\n            If a required key is absent\n        ValueError\n            If a required entry cannot be parsed\n        \"\"\"\nreturn cls(\nsection.name,\nPath(section[\"root\"]),\ntuple(section[\"minecraft_version\"].strip().split()),\nsection.get(\"modloader\", None),\ntuple(\ntag.strip()\nfor tag in section.get(\"tags\", \"\")\n.replace(\",\", \"\\n\")\n.strip()\n.split(\"\\n\")\n),\n)\n</code></pre>"},{"location":"reference/enderchest/instance/#enderchest.instance.InstanceSpec.from_cfg","title":"<code>from_cfg(section)</code>  <code>classmethod</code>","text":"<p>Parse an instance spec as read in from the enderchest config file</p> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>dict-like of str to str</code> <p>The section in the enderchest config as parsed by a ConfigParser</p> required <p>Returns:</p> Type Description <code>InstanceSpec</code> <p>The resulting InstanceSpec</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If a required key is absent</p> <code>ValueError</code> <p>If a required entry cannot be parsed</p> Source code in <code>enderchest/instance.py</code> <pre><code>@classmethod\ndef from_cfg(cls, section: SectionProxy) -&gt; \"InstanceSpec\":\n\"\"\"Parse an instance spec as read in from the enderchest config file\n    Parameters\n    ----------\n    section : dict-like of str to str\n        The section in the enderchest config as parsed by a ConfigParser\n    Returns\n    -------\n    InstanceSpec\n        The resulting InstanceSpec\n    Raises\n    ------\n    KeyError\n        If a required key is absent\n    ValueError\n        If a required entry cannot be parsed\n    \"\"\"\nreturn cls(\nsection.name,\nPath(section[\"root\"]),\ntuple(section[\"minecraft_version\"].strip().split()),\nsection.get(\"modloader\", None),\ntuple(\ntag.strip()\nfor tag in section.get(\"tags\", \"\")\n.replace(\",\", \"\\n\")\n.strip()\n.split(\"\\n\")\n),\n)\n</code></pre>"},{"location":"reference/enderchest/instance/#enderchest.instance.equals","title":"<code>equals(minecraft_root, instance, other_instance)</code>","text":"<p>Determine whether two instances point to the same location</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The starting location (the parent of where your EnderChest folder lives)</p> required <code>instance</code> <code>InstanceSpec</code> <p>the first instance</p> required <code>other_instance</code> <code>InstanceSpec</code> <p>the instance to compare it against</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if and only if the two instances have the same root, with regards to the provided <code>minecraft_root</code></p> Source code in <code>enderchest/instance.py</code> <pre><code>def equals(\nminecraft_root: Path, instance: InstanceSpec, other_instance: InstanceSpec\n) -&gt; bool:\n\"\"\"Determine whether two instances point to the same location\n    Parameters\n    ----------\n    minecraft_root : Path\n        The starting location (the parent of where your EnderChest folder lives)\n    instance : InstanceSpec\n        the first instance\n    other_instance : InstanceSpec\n        the instance to compare it against\n    Returns\n    -------\n    bool\n        True if and only if the two instances have the same root, with regards\n        to the provided `minecraft_root`\n    \"\"\"\npath = minecraft_root / instance.root.expanduser()\nother_path = minecraft_root / other_instance.root.expanduser()\nreturn path.expanduser().resolve() == other_path.expanduser().resolve()\n</code></pre>"},{"location":"reference/enderchest/loggers/","title":"loggers","text":"<p>Loggers for the various EnderChest actions</p>"},{"location":"reference/enderchest/loggers/#enderchest.loggers.CLIFormatter","title":"<code>CLIFormatter</code>","text":"<p>         Bases: <code>logging.Formatter</code></p> <p>Colorful formatter for the CLI</p> <p>h/t https://stackoverflow.com/a/56944256</p> Source code in <code>enderchest/loggers.py</code> <pre><code>class CLIFormatter(logging.Formatter):\n\"\"\"Colorful formatter for the CLI\n    h/t https://stackoverflow.com/a/56944256\"\"\"\ngrey = \"\\x1b[38;20m\"\nyellow = \"\\x1b[33;20m\"\nbold_red = \"\\x1b[31;1m\"\nreset = \"\\x1b[0m\"\nFORMATS = {\nlogging.DEBUG: grey + \"%(message)s\" + reset,\nlogging.INFO: \"%(message)s\",\nlogging.WARNING: yellow + \"%(message)s\" + reset,\nlogging.ERROR: bold_red + \"%(message)s\" + reset,\nlogging.CRITICAL: bold_red + \"%(message)s\" + reset,\n}\ndef format(self, record: logging.LogRecord) -&gt; str:\nreturn logging.Formatter(self.FORMATS.get(record.levelno)).format(record)\n</code></pre>"},{"location":"reference/enderchest/place/","title":"place","text":"<p>Symlinking functionality</p>"},{"location":"reference/enderchest/place/#enderchest.place.link_resource","title":"<code>link_resource(resource_path, shulker_root, instance_root)</code>","text":"<p>Create a symlink for the specified resource from an instance's space pointing to the tagged file / folder living inside a shulker box.</p> <p>Parameters:</p> Name Type Description Default <code>resource_path</code> <code>str or Path</code> <p>Location of the resource relative to the instance's \".minecraft\" folder</p> required <code>shulker_root</code> <code>Path</code> <p>The path to the shulker box</p> required <code>instance_root</code> <code>Path</code> <p>The path to the instance's \".minecraft\" folder</p> required <p>Raises:</p> Type Description <code>NotADirectoryError</code> <p>If a file already exists where you're attempting to place the symlink</p> <code>OSError</code> <p>If a non-empty directory already exists where you're attempting to place the symlink</p>"},{"location":"reference/enderchest/place/#enderchest.place.link_resource--notes","title":"Notes","text":"<ul> <li>This method will create any folders that do not exist within an instance</li> <li>This method will overwrite existing symlinks and empty folders   but will not overwrite or delete any actual files.</li> </ul> Source code in <code>enderchest/place.py</code> <pre><code>def link_resource(\nresource_path: str | Path, shulker_root: Path, instance_root: Path\n) -&gt; None:\n\"\"\"Create a symlink for the specified resource from an instance's space\n    pointing to the tagged file / folder living inside a shulker box.\n    Parameters\n    ----------\n    resource_path : str or Path\n        Location of the resource relative to the instance's \".minecraft\" folder\n    shulker_root : Path\n        The path to the shulker box\n    instance_root : Path\n        The path to the instance's \".minecraft\" folder\n    Raises\n    ------\n    NotADirectoryError\n        If a file already exists where you're attempting to place the symlink\n    OSError\n        If a non-empty directory already exists where you're attempting to\n        place the symlink\n    Notes\n    -----\n    - This method will create any folders that do not exist within an instance\n    - This method will overwrite existing symlinks and empty folders\n      but will not overwrite or delete any actual files.\n    \"\"\"\ninstance_path = (instance_root / resource_path).expanduser().absolute()\ninstance_path.parent.mkdir(parents=True, exist_ok=True)\nrelative_path = os.path.relpath(\n(shulker_root / resource_path).expanduser().absolute(), instance_path.parent\n)\nif instance_path.is_symlink():\n# remove previous symlink in this spot\nPLACE_LOGGER.debug(f\"Removing old link at {instance_path}\")\ninstance_path.unlink()\nelse:\ntry:\nos.rmdir(instance_path)\nPLACE_LOGGER.debug(f\"Removed empty diretory at {instance_path}\")\nexcept FileNotFoundError:\npass  # A-OK\nPLACE_LOGGER.debug(f\"Linking {instance_path} to {relative_path}\")\nos.symlink(\nrelative_path,\ninstance_path,\ntarget_is_directory=(shulker_root / resource_path).is_dir(),\n)\n</code></pre>"},{"location":"reference/enderchest/place/#enderchest.place.place_ender_chest","title":"<code>place_ender_chest(minecraft_root, cleanup=True, error_handling='abort', rollback=False)</code>","text":"<p>Link all instance files and folders to all shulker boxes</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>cleanup</code> <code>bool, optional</code> <p>By default, this method will remove any broken links in your instances and servers folders. To disable this behavior, pass in <code>cleanup=False</code></p> <code>True</code> <code>error_handling</code> <code>str, optional</code> <p>By default, if a linking failure occurs, this method will terminate immediately (<code>error_handling=abort</code>). Alternatively, - pass in <code>error_handling=\"ignore\"</code> to continue as if the link failure hadn't occrurred - pass in <code>error_handling=\"skip\"</code> to abort linking the current instance to the current shulker box but otherwise continue on - pass in <code>error_handling=\"skip-instance\"</code> to abort linking the current instance altogether but to otherwise continue on with other instances - pass in <code>error_handling=\"skip-shulker-box\"</code> to abort linking to the current shulker box altogether but to otherwise continue on with other boxes - pass in <code>error_handling=\"prompt\"</code> to ask what to do on each failure</p> <code>'abort'</code> <code>rollback</code> <p>In the future in the event of linking errors passing in <code>rollback=True</code> can be used to roll back any changes that have already been applied based on the error-handling method specified.</p> <code>False</code> Source code in <code>enderchest/place.py</code> <pre><code>def place_ender_chest(\nminecraft_root: Path,\ncleanup: bool = True,\nerror_handling: str = \"abort\",\nrollback=False,\n) -&gt; None:\n\"\"\"Link all instance files and folders to all shulker boxes\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    cleanup : bool, optional\n        By default, this method will remove any broken links in your instances\n        and servers folders. To disable this behavior, pass in `cleanup=False`\n    error_handling : str, optional\n        By default, if a linking failure occurs, this method will terminate\n        immediately (`error_handling=abort`). Alternatively,\n          - pass in `error_handling=\"ignore\"` to continue as if the link failure\n            hadn't occrurred\n          - pass in `error_handling=\"skip\"` to abort linking the current instance\n            to the current shulker box but otherwise continue on\n          - pass in `error_handling=\"skip-instance\"` to abort linking the current\n            instance altogether but to otherwise continue on with other instances\n          - pass in `error_handling=\"skip-shulker-box\"` to abort linking to the current\n            shulker box altogether but to otherwise continue on with other boxes\n          - pass in `error_handling=\"prompt\"` to ask what to do on each failure\n    rollback: bool, optional\n        In the future in the event of linking errors passing in `rollback=True`\n        can be used to roll back any changes that have already been applied\n        based on the error-handling method specified.\n    \"\"\"\nif rollback is not False:\nraise NotImplementedError(\"Rollbacks are not currently supported\")\ntry:\nhost = load_ender_chest(minecraft_root).name\nexcept (FileNotFoundError, ValueError) as bad_chest:\nPLACE_LOGGER.error(\nf\"Could not load EnderChest from {minecraft_root}:\\n  {bad_chest}\"\n)\nreturn\ninstances = load_ender_chest_instances(minecraft_root, log_level=logging.DEBUG)\nshulker_boxes: list[ShulkerBox] = []\nfor shulker_box in load_shulker_boxes(minecraft_root, log_level=logging.DEBUG):\nfor condition, values in shulker_box.match_criteria:\nif condition == \"hosts\":\n# TODO: DRY this into a dedicated function\nif not any(\nfnmatch.fnmatchcase(host.lower(), host_spec.lower())\nfor host_spec in values\n):\nPLACE_LOGGER.debug(\nf\"{shulker_box.name} is not intended\"\nf\" for linking to this host ({host})\"\n)\nbreak\nelse:\nshulker_boxes.append(shulker_box)\nskip_instances: list[InstanceSpec] = []\ndef handle_error(instance: InstanceSpec) -&gt; str:\n\"\"\"Centralized error-handling\n        Parameters\n        ----------\n        instance:\n            The current instance (in case it needs to be added to the skip list)\n        Returns\n        -------\n        str\n            Instructions on what to do next. Options are:\n              - return\n              - break\n              - coninue\n              - pass\n        \"\"\"\nif error_handling == \"prompt\":\nproceed_how = (\nprompt(\n\"How would you like to proceed?\"\n\"\\n[Q]uit, [C]ontinue, abort linking the rest of this shulker/instance [M]atch?\"\n\"\\nskip the rest of this [I]nstance, skip the rest of this [S]hulker box?\",\nsuggestion=\"I\",  # TODO: in my experience it's usally an instance issue\n)\n.lower()\n.replace(\" \", \"\")\n.replace(\"-\", \"\")\n.replace(\"_\", \"\")\n)\nmatch proceed_how:\ncase \"\" | \"i\" | \"instance\" | \"skipinstance\":\nproceed_how = \"skip-instance\"\ncase \"q\" | \"quit\" | \"abort\" | \"exit\" | \"stop\":\nproceed_how = \"abort\"\ncase \"c\" | \"continue\" | \"ignore\":\nproceed_how = \"ignore\"\ncase \"m\" | \"match\" | \"skip\":\nproceed_how = \"skip\"\ncase \"s\" | \"shulker\" | \"shulkerbox\" | \"skipshulker\":\nproceed_how = \"skip-shulker\"\ncase _:\nPLACE_LOGGER.error(\"Invalid selection.\")\nreturn handle_error(instance)\nelse:\nproceed_how = error_handling\nmatch proceed_how:\ncase \"abort\" | \"stop\" | \"quit\" | \"exit\":\nPLACE_LOGGER.error(\"Aborting\")\nreturn \"return\"\ncase \"ignore\":\nPLACE_LOGGER.debug(\"Ignoring\")\nreturn \"pass\"\ncase \"skip\":\nPLACE_LOGGER.warning(\"Skipping the rest of this match\")\nreturn \"continue\"\ncase \"skip-instance\":\nPLACE_LOGGER.warning(\"Skipping any more linking from this instance\")\nskip_instances.append(instance)\nreturn \"continue\"\ncase \"skip-shulker-box\" | \"skip-shulkerbox\" | \"skip-shulker\":\nPLACE_LOGGER.warning(\"Skipping any more linking into this shulker box\")\nreturn \"break\"\ncase _:\nraise ValueError(\nf\"Unrecognized error-handling method: {error_handling}\"\n)\nfor shulker_box in shulker_boxes:\nfor instance in instances:\nif not shulker_box.matches(instance):\ncontinue\nif instance in skip_instances:\ncontinue\ninstance_root = (minecraft_root / instance.root.expanduser()).expanduser()\nbox_root = shulker_box.root.expanduser().absolute()\nif not instance_root.exists():\nPLACE_LOGGER.error(\nf\"No minecraft instance exists at {instance_root.expanduser().absolute()}\"\n)\nmatch handle_error(instance):\ncase \"return\":\nreturn\ncase \"break\":\nbreak\ncase _:  # nothing to link, so might as well skip the rest\ncontinue\nPLACE_LOGGER.info(f\"Linking {instance.root} to {shulker_box.name}\")\nresources = set(_rglob(box_root, shulker_box.max_link_depth))\nmatch_exit = \"pass\"\nfor link_folder in shulker_box.link_folders:\nresources -= {box_root / link_folder}\nresources -= set((box_root / link_folder).rglob(\"*\"))\ntry:\nlink_resource(link_folder, box_root, instance_root)\nexcept (OSError, NotADirectoryError) as oh_no:\nPLACE_LOGGER.error(\nf\"Error linking shulker box {shulker_box.name}\"\nf\" to instance {instance.name}:\"\nf\"\\n  {(instance.root / link_folder)} is a\"\n\" non-empty directory\"\n)\nmatch handle_error(instance):\ncase \"return\":\nreturn\ncase \"break\":\nmatch_exit = \"break\"\nbreak\ncase \"continue\":\nmatch_exit = \"continue\"\nbreak\ncase \"pass\":\ncontinue  # or pass--it's the end of the loop\nif match_exit not in (\"break\", \"continue\"):\nfor resource in resources:\nresource_path = resource.relative_to(box_root)\ntry:\nlink_resource(\nresource_path,\nbox_root,\ninstance_root,\n)\nexcept (OSError, NotADirectoryError) as oh_no:\nPLACE_LOGGER.error(\nf\"Error linking shulker box {shulker_box.name}\"\nf\" to instance {instance.name}:\"\nf\"\\n  {(instance.root / resource_path)}\"\n\" already exists\"\n)\n# TODO: option to record failure but keep going\nmatch handle_error(instance):\ncase \"return\":\nreturn\ncase \"break\":\nmatch_exit = \"break\"\nbreak\ncase \"continue\":\nmatch_exit = \"continue\"  # technically does nothing\nbreak\ncase \"pass\":\ncontinue  # or pass--it's the end of the loop\nif cleanup:  # consider this a \"finally\"\n# we clean up as we go, just in case of a failure\nfor file in instance_root.rglob(\"*\"):\nif not file.exists():\nPLACE_LOGGER.debug(f\"Removing broken link: {file}\")\nfile.unlink()\nif match_exit == \"break\":\nbreak\n</code></pre>"},{"location":"reference/enderchest/prompt/","title":"prompt","text":"<p>Utilities for helping build interactive prompts</p>"},{"location":"reference/enderchest/prompt/#enderchest.prompt.confirm","title":"<code>confirm(default)</code>","text":"<p>Confirm that the user wishes to continue</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>bool</code> <p>Whether the default selection should be True (yes) or False (no)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the user has opted to continue</p> Source code in <code>enderchest/prompt.py</code> <pre><code>def confirm(default: bool) -&gt; bool:\n\"\"\"Confirm that the user wishes to continue\n    Parameters\n    ----------\n    default : bool\n        Whether the default selection should be True (yes) or False (no)\n    Returns\n    -------\n    bool\n        Whether the user has opted to continue\n    \"\"\"\nconfirm = prompt(\"Do you wish to continue?\", \"Y/n\" if default else \"y/N\")\nif confirm == \"\":\nreturn default\nif confirm in YES:\nreturn True\nreturn False\n</code></pre>"},{"location":"reference/enderchest/prompt/#enderchest.prompt.prompt","title":"<code>prompt(message, suggestion=None)</code>","text":"<p>Prompt the user and return the response</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The prompt message</p> required <code>suggestion</code> <code>str, optional</code> <p>A suggested input. If None is provided, no suggestion will be shown.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The user-provided response</p>"},{"location":"reference/enderchest/prompt/#enderchest.prompt.prompt--notes","title":"Notes","text":"<ul> <li>The output will be stripped of trailing and leading whitespace, but no   other validation or processing will be used.</li> <li>Regardless of whether a suggestion is provided, if the user provides an   empty input, this method will return an empty string. To reiterate: the   suggestion does not serve as a default / fallback value.</li> </ul> Source code in <code>enderchest/prompt.py</code> <pre><code>def prompt(message: str, suggestion: str | None = None) -&gt; str:\n\"\"\"Prompt the user and return the response\n    Parameters\n    ----------\n    message : str\n        The prompt message\n    suggestion : str, optional\n        A suggested input. If None is provided, no suggestion will be shown.\n    Returns\n    -------\n    str\n        The user-provided response\n    Notes\n    -----\n    - The output will be stripped of trailing and leading whitespace, but no\n      other validation or processing will be used.\n    - Regardless of whether a suggestion is provided, if the user provides an\n      empty input, this method will return an empty string. To reiterate: the\n      suggestion *does not serve* as a default / fallback value.\n    \"\"\"\nlines = message.splitlines() + [\"\"]\nmessage = \"\\n\".join(f\"{CURSOR} {line}\" for line in lines)\nif suggestion is not None:\nmessage += f\"[{suggestion}] \"\nreturn input(message)\n</code></pre>"},{"location":"reference/enderchest/remote/","title":"remote","text":"<p>Higher-level functionality around synchronizing with different EnderCherts</p>"},{"location":"reference/enderchest/remote/#enderchest.remote.fetch_remotes_from_a_remote_ender_chest","title":"<code>fetch_remotes_from_a_remote_ender_chest(uri)</code>","text":"<p>Grab the list of EnderChests registered with the specified remote EnderChest</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>URI</code> <p>The URI to the remote Minecraft root</p> required <p>Returns:</p> Type Description <code>list of (URI, str) tuples</code> <p>The URIs of the remote EnderChests, paired with their aliases</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the remote list could not be pulled</p> Source code in <code>enderchest/remote.py</code> <pre><code>def fetch_remotes_from_a_remote_ender_chest(\nuri: str | ParseResult,\n) -&gt; list[tuple[ParseResult, str]]:\n\"\"\"Grab the list of EnderChests registered with the specified remote EnderChest\n    Parameters\n    ----------\n    uri : URI\n        The URI to the remote Minecraft root\n    Returns\n    -------\n    list of (URI, str) tuples\n        The URIs of the remote EnderChests, paired with their aliases\n    Raises\n    ------\n    RuntimeError\n        If the remote list could not be pulled\n    \"\"\"\nremote_chest = load_remote_ender_chest(uri)\nremotes: list[tuple[ParseResult, str]] = [(remote_chest._uri, remote_chest.name)]\nremotes.extend(remote_chest.remotes)\nSYNC_LOGGER.info(\n\"Loaded the following remotes:\\n\"\n+ \"\\n\".join(f\"  - {render_remote(alias, uri)}\" for uri, alias in remotes)\n)\nif len(set(alias for _, alias in remotes)) != len(remotes):\nraise RuntimeError(\nf\"There are duplicates aliases in the list of remotes pulled from {uri}\"\n)\nreturn remotes\n</code></pre>"},{"location":"reference/enderchest/remote/#enderchest.remote.load_remote_ender_chest","title":"<code>load_remote_ender_chest(uri)</code>","text":"<p>Load an EnderChest configuration from another machine</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>URI</code> <p>The URI to the remote Minecraft root</p> required <p>Returns:</p> Type Description <code>EnderChest</code> <p>The remote EnderChest configuration</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided URI is invalid</p> <code>RuntimeError</code> <p>If the config from the remote EnderChest could not be parsed</p> Source code in <code>enderchest/remote.py</code> <pre><code>def load_remote_ender_chest(uri: str | ParseResult) -&gt; EnderChest:\n\"\"\"Load an EnderChest configuration from another machine\n    Parameters\n    ----------\n    uri : URI\n        The URI to the remote Minecraft root\n    Returns\n    -------\n    EnderChest\n        The remote EnderChest configuration\n    Raises\n    ------\n    ValueError\n        If the provided URI is invalid\n    RuntimeError\n        If the config from the remote EnderChest could not be parsed\n    \"\"\"\ntry:\nuri = uri if isinstance(uri, ParseResult) else urlparse(uri)\nexcept AttributeError as bad_uri:\nraise ValueError(f\"{uri} is not a valid URI\") from bad_uri\nremote_root = Path(uri.path)\nremote_config_path = fs.ender_chest_config(remote_root, check_exists=False)\nuri = uri._replace(path=remote_config_path.as_posix())\nwith remote_file(uri) as remote_config:\ntry:\nreturn EnderChest.from_cfg(remote_config)\nexcept ValueError as bad_chest:\nraise RuntimeError(\n\"The remote EnderChest config downloaded\"\nf\"from {uri.geturl()} could not be parsed.\"\n) from bad_chest\n</code></pre>"},{"location":"reference/enderchest/shulker_box/","title":"shulker_box","text":"<p>Specification and configuration of a shulker box</p>"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.ShulkerBox","title":"<code>ShulkerBox</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Specification of a ShulkerBox</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>The priority for linking assets in the shulker box (higher priority shulkers are linked last)</p> required <code>name</code> <code>str</code> <p>The name of the shulker box (which is incidetentally used to break priority ties)</p> required <code>root</code> <code>Path</code> <p>The path to the root of the shulker box</p> required <code>match_criteria</code> <code>list-like of tuples</code> <p>The parameters for matching instances to this shulker box. Each element consists of:</p> <ul> <li>the name of the condition</li> <li>the matching values for that condition</li> </ul> <p>The logic applied is that an instance must match at least one value for each condition (so it's ANDing a collection of ORs)</p> required <code>link_folders</code> <code>list-like of str</code> <p>The folders that should be linked in their entirety</p> required <code>max_link_depth</code> <code>int, optional</code> <p>By default, non-root-level folders (that is, folders inside of folders) will be treated as files for the purpose of linking. Put another way, only files with a depth of 2 or less from the shulker root will be linked. This behavior can be overridden by explicitly setting the <code>max_link_depth</code> value, but this feature is highly experimental, so use it at your own risk.</p> required"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.ShulkerBox--notes","title":"Notes","text":"<p>A shulker box specification is immutable, so making changes (such as updating the match critera) can only be done on copies created via the <code>_replace</code> method, inherited from the NamedTuple parent class.</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>class ShulkerBox(NamedTuple):\n\"\"\"Specification of a ShulkerBox\n    Parameters\n    ----------\n    priority : int\n        The priority for linking assets in the shulker box (higher priority\n        shulkers are linked last)\n    name : str\n        The name of the shulker box (which is incidetentally used to break\n        priority ties)\n    root : Path\n        The path to the root of the shulker box\n    match_criteria : list-like of tuples\n        The parameters for matching instances to this shulker box. Each element\n        consists of:\n          - the name of the condition\n          - the matching values for that condition\n        The logic applied is that an instance must match at least one value\n        for each condition (so it's ANDing a collection of ORs)\n    link_folders : list-like of str\n        The folders that should be linked in their entirety\n    max_link_depth : int, optional\n        By default, non-root-level folders (that is, folders inside of folders)\n        will be treated as files for the purpose of linking. Put another way,\n        only files with a depth of 2 or less from the shulker root will be\n        linked. This behavior can be overridden by explicitly setting\n        the `max_link_depth` value, but **this feature is highly experimental**,\n        so use it at your own risk.\n    Notes\n    -----\n    A shulker box specification is immutable, so making changes (such as\n    updating the match critera) can only be done on copies created via the\n    `_replace` method, inherited from the NamedTuple parent class.\n    \"\"\"\npriority: int\nname: str\nroot: Path\nmatch_criteria: tuple[tuple[str, tuple[str, ...]], ...]\nlink_folders: tuple[str, ...]\nmax_link_depth: int = 2\n@classmethod\ndef from_cfg(cls, config_file: Path) -&gt; \"ShulkerBox\":\n\"\"\"Parse a shulker box from its config file\n        Parameters\n        ----------\n        config_file : Path\n            The path to the config file\n        Returns\n        -------\n        ShulkerBox\n            The resulting ShulkerBox\n        Raises\n        ------\n        ValueError\n            If the config file at that location cannot be parsed\n        FileNotFoundError\n            If there is no config file at the specified location\n        \"\"\"\npriority = 0\nmax_link_depth = 2\nroot = config_file.parent\nname = root.name\nparser = ConfigParser(allow_no_value=True, inline_comment_prefixes=(\";\",))\ntry:\nassert parser.read(config_file)\nexcept ParsingError as bad_cfg:\nraise ValueError(f\"Could not parse {config_file}\") from bad_cfg\nexcept AssertionError:\nraise FileNotFoundError(f\"Could not open {config_file}\")\nmatch_criteria: dict[str, tuple[str, ...]] = {}\nfor section in parser.sections():\nnormalized = (\nsection.lower().replace(\" \", \"\").replace(\"-\", \"\").replace(\"_\", \"\")\n)\nif normalized.endswith(\"s\"):\nnormalized = normalized[:-1]  # lazy de-pluralization\nif normalized in (\"linkfolder\", \"folder\"):\nnormalized = \"link-folders\"\nif normalized in (\"minecraft\", \"version\", \"minecraftversion\"):\nnormalized = \"minecraft\"\nif normalized in (\"modloader\", \"loader\"):\nnormalized = \"modloader\"\nif normalized in (\"instance\", \"tag\", \"host\"):\nnormalized += \"s\"  # lazy re-pluralization\nif normalized == \"propertie\":  # lulz\n# TODO check to make sure properties hasn't been read before\n# most of this section gets ignored\npriority = parser[section].getint(\"priority\", 0)\nmax_link_depth = parser[section].getint(\"max-link-depth\", 2)\n# TODO: support specifying filters (and link-folders) in the properties section\ncontinue\nif normalized in match_criteria.keys():\nraise ValueError(f\"{config_file} specifies {normalized} more than once\")\nif normalized == \"minecraft\":\nminecraft_versions = []\nfor key, value in parser[section].items():\nif value is None:\nminecraft_versions.append(key)\nelif key.lower().strip().startswith(\"version\"):\nminecraft_versions.append(value)\nelse:  # what happens if you specify \"&gt;=1.19\" or \"=1.12\"\nminecraft_versions.append(\"=\".join((key, value)))\nmatch_criteria[\"minecraft\"] = tuple(minecraft_versions)\nelse:\n# really hoping delimiter shenanigans doesn't show up anywhere else\nmatch_criteria[normalized] = tuple(parser[section].keys())\nlink_folders = match_criteria.pop(\"link-folders\", ())\nreturn cls(\npriority,\nname,\nroot,\ntuple(match_criteria.items()),\nlink_folders,\nmax_link_depth=max_link_depth,\n)\ndef write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n\"\"\"Write this shulker's configuration to INI\n        Parameters\n        ----------\n        config_file : Path, optional\n            The path to the config file, assuming you'd like to write the\n            contents to file\n        Returns\n        -------\n        str\n            An INI-syntax rendering of this shulker box's config\n        Notes\n        -----\n        The \"root\" attribute is ignored for this method\n        \"\"\"\nconfig = ConfigParser(allow_no_value=True)\nconfig.add_section(\"properties\")\nconfig.set(\"properties\", \"priority\", str(self.priority))\nif self.max_link_depth != 2:\nconfig.set(\"properties\", \"max-link-depth\", str(self.max_link_depth))\nconfig.set(\"properties\", \"last_modified\", dt.datetime.now().isoformat(sep=\" \"))\nconfig.set(\n\"properties\", \"generated_by_enderchest_version\", get_versions()[\"version\"]\n)\nfor condition, values in self.match_criteria:\nconfig.add_section(condition)\nfor value in values:\nconfig.set(condition, value)\nconfig.add_section(\"link-folders\")\nfor folder in self.link_folders:\nconfig.set(\"link-folders\", folder)\nbuffer = StringIO()\nbuffer.write(f\"; {os.path.join(self.name, fs.SHULKER_BOX_CONFIG_NAME)}\\n\")\nconfig.write(buffer)\nbuffer.seek(0)  # rewind\nif config_file:\nconfig_file.write_text(buffer.read())\nbuffer.seek(0)\nreturn buffer.read()\ndef matches(self, instance: InstanceSpec) -&gt; bool:\n\"\"\"Determine whether the shulker box matches the given instance\n        Parameters\n        ----------\n        instance : InstanceSpec\n            The instance's specification\n        Returns\n        -------\n        bool\n            True if the instance matches the shulker box's conditions, False\n            otherwise.\n        \"\"\"\nfor condition, values in self.match_criteria:\nmatch condition:  # these should have been normalized on read-in\ncase \"instances\":\nfor value in values:\nif fnmatch.fnmatchcase(instance.name, value):\nbreak\nelse:\nreturn False\ncase \"tags\":\nfor value in values:\nif fnmatch.filter(\n[tag.lower() for tag in instance.tags], value.lower()\n):\nbreak\nelse:\nreturn False\ncase \"modloader\":\nnormalized: list[str] = sum(\n[_normalize_modloader(value) for value in values], []\n)\nfor value in normalized:\nif fnmatch.filter(\n[\nloader.lower()\nfor loader in _normalize_modloader(instance.modloader)\n],\nvalue.lower(),\n):\nbreak\nelse:\nreturn False\ncase \"minecraft\":\nfor value in values:\nif any(\n(\n_matches_version(value, version)\nfor version in instance.minecraft_versions\n)\n):\nbreak\nelse:\nreturn False\ncase \"hosts\":\n# this is handled at a higher level\npass\ncase _:\nraise NotImplementedError(\nf\"Don't know how to apply match condition {condition}.\"\n)\nreturn True\n</code></pre>"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.ShulkerBox.from_cfg","title":"<code>from_cfg(config_file)</code>  <code>classmethod</code>","text":"<p>Parse a shulker box from its config file</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path</code> <p>The path to the config file</p> required <p>Returns:</p> Type Description <code>ShulkerBox</code> <p>The resulting ShulkerBox</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the config file at that location cannot be parsed</p> <code>FileNotFoundError</code> <p>If there is no config file at the specified location</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>@classmethod\ndef from_cfg(cls, config_file: Path) -&gt; \"ShulkerBox\":\n\"\"\"Parse a shulker box from its config file\n    Parameters\n    ----------\n    config_file : Path\n        The path to the config file\n    Returns\n    -------\n    ShulkerBox\n        The resulting ShulkerBox\n    Raises\n    ------\n    ValueError\n        If the config file at that location cannot be parsed\n    FileNotFoundError\n        If there is no config file at the specified location\n    \"\"\"\npriority = 0\nmax_link_depth = 2\nroot = config_file.parent\nname = root.name\nparser = ConfigParser(allow_no_value=True, inline_comment_prefixes=(\";\",))\ntry:\nassert parser.read(config_file)\nexcept ParsingError as bad_cfg:\nraise ValueError(f\"Could not parse {config_file}\") from bad_cfg\nexcept AssertionError:\nraise FileNotFoundError(f\"Could not open {config_file}\")\nmatch_criteria: dict[str, tuple[str, ...]] = {}\nfor section in parser.sections():\nnormalized = (\nsection.lower().replace(\" \", \"\").replace(\"-\", \"\").replace(\"_\", \"\")\n)\nif normalized.endswith(\"s\"):\nnormalized = normalized[:-1]  # lazy de-pluralization\nif normalized in (\"linkfolder\", \"folder\"):\nnormalized = \"link-folders\"\nif normalized in (\"minecraft\", \"version\", \"minecraftversion\"):\nnormalized = \"minecraft\"\nif normalized in (\"modloader\", \"loader\"):\nnormalized = \"modloader\"\nif normalized in (\"instance\", \"tag\", \"host\"):\nnormalized += \"s\"  # lazy re-pluralization\nif normalized == \"propertie\":  # lulz\n# TODO check to make sure properties hasn't been read before\n# most of this section gets ignored\npriority = parser[section].getint(\"priority\", 0)\nmax_link_depth = parser[section].getint(\"max-link-depth\", 2)\n# TODO: support specifying filters (and link-folders) in the properties section\ncontinue\nif normalized in match_criteria.keys():\nraise ValueError(f\"{config_file} specifies {normalized} more than once\")\nif normalized == \"minecraft\":\nminecraft_versions = []\nfor key, value in parser[section].items():\nif value is None:\nminecraft_versions.append(key)\nelif key.lower().strip().startswith(\"version\"):\nminecraft_versions.append(value)\nelse:  # what happens if you specify \"&gt;=1.19\" or \"=1.12\"\nminecraft_versions.append(\"=\".join((key, value)))\nmatch_criteria[\"minecraft\"] = tuple(minecraft_versions)\nelse:\n# really hoping delimiter shenanigans doesn't show up anywhere else\nmatch_criteria[normalized] = tuple(parser[section].keys())\nlink_folders = match_criteria.pop(\"link-folders\", ())\nreturn cls(\npriority,\nname,\nroot,\ntuple(match_criteria.items()),\nlink_folders,\nmax_link_depth=max_link_depth,\n)\n</code></pre>"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.ShulkerBox.matches","title":"<code>matches(instance)</code>","text":"<p>Determine whether the shulker box matches the given instance</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>InstanceSpec</code> <p>The instance's specification</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the instance matches the shulker box's conditions, False otherwise.</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>def matches(self, instance: InstanceSpec) -&gt; bool:\n\"\"\"Determine whether the shulker box matches the given instance\n    Parameters\n    ----------\n    instance : InstanceSpec\n        The instance's specification\n    Returns\n    -------\n    bool\n        True if the instance matches the shulker box's conditions, False\n        otherwise.\n    \"\"\"\nfor condition, values in self.match_criteria:\nmatch condition:  # these should have been normalized on read-in\ncase \"instances\":\nfor value in values:\nif fnmatch.fnmatchcase(instance.name, value):\nbreak\nelse:\nreturn False\ncase \"tags\":\nfor value in values:\nif fnmatch.filter(\n[tag.lower() for tag in instance.tags], value.lower()\n):\nbreak\nelse:\nreturn False\ncase \"modloader\":\nnormalized: list[str] = sum(\n[_normalize_modloader(value) for value in values], []\n)\nfor value in normalized:\nif fnmatch.filter(\n[\nloader.lower()\nfor loader in _normalize_modloader(instance.modloader)\n],\nvalue.lower(),\n):\nbreak\nelse:\nreturn False\ncase \"minecraft\":\nfor value in values:\nif any(\n(\n_matches_version(value, version)\nfor version in instance.minecraft_versions\n)\n):\nbreak\nelse:\nreturn False\ncase \"hosts\":\n# this is handled at a higher level\npass\ncase _:\nraise NotImplementedError(\nf\"Don't know how to apply match condition {condition}.\"\n)\nreturn True\n</code></pre>"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.ShulkerBox.write_to_cfg","title":"<code>write_to_cfg(config_file=None)</code>","text":"<p>Write this shulker's configuration to INI</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path, optional</code> <p>The path to the config file, assuming you'd like to write the contents to file</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>An INI-syntax rendering of this shulker box's config</p>"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.ShulkerBox.write_to_cfg--notes","title":"Notes","text":"<p>The \"root\" attribute is ignored for this method</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>def write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n\"\"\"Write this shulker's configuration to INI\n    Parameters\n    ----------\n    config_file : Path, optional\n        The path to the config file, assuming you'd like to write the\n        contents to file\n    Returns\n    -------\n    str\n        An INI-syntax rendering of this shulker box's config\n    Notes\n    -----\n    The \"root\" attribute is ignored for this method\n    \"\"\"\nconfig = ConfigParser(allow_no_value=True)\nconfig.add_section(\"properties\")\nconfig.set(\"properties\", \"priority\", str(self.priority))\nif self.max_link_depth != 2:\nconfig.set(\"properties\", \"max-link-depth\", str(self.max_link_depth))\nconfig.set(\"properties\", \"last_modified\", dt.datetime.now().isoformat(sep=\" \"))\nconfig.set(\n\"properties\", \"generated_by_enderchest_version\", get_versions()[\"version\"]\n)\nfor condition, values in self.match_criteria:\nconfig.add_section(condition)\nfor value in values:\nconfig.set(condition, value)\nconfig.add_section(\"link-folders\")\nfor folder in self.link_folders:\nconfig.set(\"link-folders\", folder)\nbuffer = StringIO()\nbuffer.write(f\"; {os.path.join(self.name, fs.SHULKER_BOX_CONFIG_NAME)}\\n\")\nconfig.write(buffer)\nbuffer.seek(0)  # rewind\nif config_file:\nconfig_file.write_text(buffer.read())\nbuffer.seek(0)\nreturn buffer.read()\n</code></pre>"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.create_shulker_box","title":"<code>create_shulker_box(minecraft_root, shulker_box)</code>","text":"<p>Create a shulker box folder based on the provided configuration</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>shulker_box</code> <code>ShulkerBox</code> <p>The spec of the box to create</p> required"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.create_shulker_box--notes","title":"Notes","text":"<ul> <li>The \"root\" attribute of the ShulkerBox config will be ignored--instead   the shulker box will be created at   /EnderChest/ <li>This method will fail if there is no EnderChest set up in the minecraft   root</li> <li>This method does not check to see if there is already a shulker box   set up at the specificed location--if one exists, its config will   be overwritten</li> Source code in <code>enderchest/shulker_box.py</code> <pre><code>def create_shulker_box(minecraft_root: Path, shulker_box: ShulkerBox) -&gt; None:\n\"\"\"Create a shulker box folder based on the provided configuration\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    shulker_box : ShulkerBox\n        The spec of the box to create\n    Notes\n    -----\n    - The \"root\" attribute of the ShulkerBox config will be ignored--instead\n      the shulker box will be created at\n      &lt;minecraft_root&gt;/EnderChest/&lt;shulker box name&gt;\n    - This method will fail if there is no EnderChest set up in the minecraft\n      root\n    - This method does not check to see if there is already a shulker box\n      set up at the specificed location--if one exists, its config will\n      be overwritten\n    \"\"\"\nroot = fs.shulker_box_root(minecraft_root, shulker_box.name)\nroot.mkdir(exist_ok=True)\nfor folder in (*DEFAULT_SHULKER_FOLDERS, *shulker_box.link_folders):\nCRAFT_LOGGER.debug(f\"Creating {root / folder}\")\n(root / folder).mkdir(exist_ok=True, parents=True)\nconfig_path = fs.shulker_box_config(minecraft_root, shulker_box.name)\nshulker_box.write_to_cfg(config_path)\nCRAFT_LOGGER.info(f\"Shulker box configuration written to {config_path}\")\n</code></pre>"},{"location":"reference/enderchest/sync/","title":"sync","text":"<p>Low-level functionality for synchronizing across different machines</p>"},{"location":"reference/enderchest/sync/#enderchest.sync.get_default_netloc","title":"<code>get_default_netloc()</code>","text":"<p>Compile a netloc from environment variables, etc.</p> <p>Returns:</p> Type Description <code>str</code> <p>The default netloc, which is {user}@{hostname}</p> Source code in <code>enderchest/sync.py</code> <pre><code>def get_default_netloc() -&gt; str:\n\"\"\"Compile a netloc from environment variables, etc.\n    Returns\n    -------\n    str\n        The default netloc, which is {user}@{hostname}\n    \"\"\"\nreturn f\"{getpass.getuser()}@{socket.gethostname()}\"\n</code></pre>"},{"location":"reference/enderchest/sync/#enderchest.sync.remote_file","title":"<code>remote_file(uri)</code>","text":"<p>Grab a file from a remote filesystem by its URI and read its contents</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>parsed URI</code> <p>The URI of the file to read</p> required <p>Yields:</p> Type Description <code>Path</code> <p>A path to a local (temp) copy of the file</p> Source code in <code>enderchest/sync.py</code> <pre><code>@contextmanager\ndef remote_file(uri: ParseResult) -&gt; Generator[Path, None, None]:\n\"\"\"Grab a file from a remote filesystem by its URI and read its contents\n    Parameters\n    ----------\n    uri : parsed URI\n        The URI of the file to read\n    Yields\n    ------\n    Path\n        A path to a local (temp) copy of the file\n    \"\"\"\nraise NotImplementedError(\"Remote file access is not currently implemented\")\n</code></pre>"},{"location":"reference/enderchest/sync/#enderchest.sync.render_remote","title":"<code>render_remote(alias, uri)</code>","text":"<p>Render a remote to a descriptive string</p> <p>Parameters:</p> Name Type Description Default <code>alias</code> <code>str</code> <p>The name of the remote</p> required <code>uri</code> <code>ParseResult</code> <p>The parsed URI for the remote</p> required <p>Returns:</p> Type Description <code>str</code> <p>{uri_string} [({alias})]} (if different from the URI hostname)</p> Source code in <code>enderchest/sync.py</code> <pre><code>def render_remote(alias: str, uri: ParseResult) -&gt; str:\n\"\"\"Render a remote to a descriptive string\n    Parameters\n    ----------\n    alias : str\n        The name of the remote\n    uri : ParseResult\n        The parsed URI for the remote\n    Returns\n    -------\n    str\n        {uri_string} [({alias})]}\n            (if different from the URI hostname)\n    \"\"\"\nuri_string = uri.geturl()\nif uri.hostname != alias:\nuri_string += f\" ({alias})\"\nreturn uri_string\n</code></pre>"}]}