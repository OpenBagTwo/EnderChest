{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"EnderChest","text":"<p>syncing and linking for all your Minecraft instances</p>"},{"location":"#registering-instances","title":"Registering Instances","text":"<p>TODO</p>"},{"location":"#creating-shulker-boxes","title":"Creating Shulker Boxes","text":"<p>TODO</p>"},{"location":"#linking-entire-folders","title":"Linking Entire Folders","text":"<p>TODO</p>"},{"location":"#collisions-and-conflicts","title":"Collisions and Conflicts","text":"<p>TODO</p>"},{"location":"#syncing","title":"Syncing","text":"<p>TODO</p>"},{"location":"#managing-backups","title":"Managing Backups","text":"<p>TODO</p>"},{"location":"#integration-with-auto-update-tools","title":"Integration with Auto-Update Tools","text":"<p>TODO</p>"},{"location":"about/","title":"About Me","text":"<p>Hello!</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>enderchest<ul> <li>prompt</li> <li>remote</li> <li>sync</li> <li>enderchest</li> <li>place</li> <li>shulker_box</li> <li>instance</li> <li>filesystem</li> <li>gather</li> <li>cli</li> <li>loggers</li> <li>craft</li> </ul> </li> </ul>"},{"location":"reference/enderchest/","title":"enderchest","text":""},{"location":"reference/enderchest/#enderchest.EnderChest","title":"<code>EnderChest</code>  <code>dataclass</code>","text":"<p>Configuration of an EnderChest</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>URI or Path</code> <p>The \"address\" of this EnderChest, ideally as it can be accessed from other EnderChest installations, including both the path to where the EnderChest folder can be found (that is, the parent of the EnderChest folder itself, aka the \"minecraft_root\"), its net location including credentials, and the protocol that should be used to perform the syncing. All that being said, if just a path is provided, the constructor will try to figure out the rest.</p> required <code>name</code> <code>str, optional</code> <p>A unique name to give to this EnderChest installation. If None is provided, this will be taken from the hostname of the supplied URI.</p> <code>None</code> <code>instances</code> <code>list-like of InstanceSpec, optional</code> <p>The list of instances to register with this EnderChest installation</p> <code>None</code> <code>remotes</code> <code>list-like of URI, or (URI, str) tuples</code> <p>A list of other installations that this EnderChest should be aware of (for syncing purposes). When a (URI, str) tuple is provided, the second value will be used as the name/alias of the remote.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The unique name of this EnderChest installation. This is most commonly the computer's hostname, but one can configure multiple EnderChests to coexist on the same system (either for the sake of having a \"cold\" backup or for multi-user systems).</p> <code>uri</code> <code>str</code> <p>The complete URI of this instance</p> <code>root</code> <code>Path</code> <p>The path to this EnderChest folder</p> <code>instances</code> <code>list-like of InstanceSpec</code> <p>The instances registered with this EnderChest</p> <code>remotes</code> <code>list-like of (ParseResult, str) pairs</code> <p>The other EnderChest installations this EnderChest is aware of, paired with their aliases</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>@dataclass(init=False, repr=False)\nclass EnderChest:\n\"\"\"Configuration of an EnderChest\n\n    Parameters\n    ----------\n    uri : URI or Path\n        The \"address\" of this EnderChest, ideally as it can be accessed from other\n        EnderChest installations, including both the path to where\n        the EnderChest folder can be found (that is, the parent of the\n        EnderChest folder itself, aka the \"minecraft_root\"), its net location\n        including credentials, and the protocol that should be used to perform\n        the syncing. All that being said, if just a path is provided, the\n        constructor will try to figure out the rest.\n    name : str, optional\n        A unique name to give to this EnderChest installation. If None is\n        provided, this will be taken from the hostname of the supplied URI.\n    instances : list-like of InstanceSpec, optional\n        The list of instances to register with this EnderChest installation\n    remotes : list-like of URI, or (URI, str) tuples\n        A list of other installations that this EnderChest should be aware of\n        (for syncing purposes). When a (URI, str) tuple is provided, the\n        second value will be used as the name/alias of the remote.\n\n    Attributes\n    ----------\n    name : str\n        The unique name of this EnderChest installation. This is most commonly\n        the computer's hostname, but one can configure multiple EnderChests\n        to coexist on the same system (either for the sake of having a \"cold\"\n        backup or for multi-user systems).\n    uri : str\n        The complete URI of this instance\n    root : Path\n        The path to this EnderChest folder\n    instances : list-like of InstanceSpec\n        The instances registered with this EnderChest\n    remotes : list-like of (ParseResult, str) pairs\n        The other EnderChest installations this EnderChest is aware of, paired\n        with their aliases\n    \"\"\"\n\n    name: str\n    _uri: ParseResult\n    _instances: list[i.InstanceSpec]\n\n    _remotes: dict[str, ParseResult]\n\n    def __init__(\n        self,\n        uri: str | ParseResult | Path,\n        name: str | None = None,\n        remotes: Iterable[str | ParseResult | tuple[str, str] | tuple[ParseResult, str]]\n        | None = None,\n        instances: Iterable[i.InstanceSpec] | None = None,\n    ):\n        try:\n            if isinstance(uri, ParseResult):\n                self._uri = uri\n            elif isinstance(uri, Path):\n                self._uri = urlparse(uri.absolute().as_uri())\n            else:\n                self._uri = urlparse(uri)\n        except AttributeError as parse_problem:\n            raise ValueError(f\"{uri} is not a valid URI\") from parse_problem\n\n        if not self._uri.netloc:\n            self._uri = self._uri._replace(netloc=sync.get_default_netloc())\n        if not self._uri.scheme:\n            self._uri = self._uri._replace(scheme=sync.DEFAULT_PROTOCOL)\n\n        self.name = name or self._uri.hostname or gethostname()\n\n        self._instances = []\n        self._remotes = {}\n\n        for instance in instances or ():\n            self.register_instance(instance)\n\n        for remote in remotes or ():\n            if isinstance(remote, (str, ParseResult)):\n                self.register_remote(remote)\n            else:\n                self.register_remote(*remote)\n\n    @property\n    def uri(self) -&gt; str:\n        return self._uri.geturl()\n\n    def __repr__(self) -&gt; str:\n        return f\"EnderChest({self.uri, self.name})\"\n\n    @property\n    def root(self) -&gt; Path:\n        return fs.ender_chest_folder(Path(self._uri.path))\n\n    @property\n    def instances(self) -&gt; tuple[i.InstanceSpec, ...]:\n        return tuple(self._instances)\n\n    def register_instance(self, instance: i.InstanceSpec) -&gt; i.InstanceSpec:\n\"\"\"Register a new Minecraft installation\n\n        Parameters\n        ----------\n        instance : InstanceSpec\n            The instance to register\n\n        Returns\n        -------\n        InstanceSpec\n            The spec of the instance as it was actually registered (in case the\n            name changed or somesuch)\n\n        Notes\n        -----\n        - If the instance's name is already assigned to a registered instance,\n          this method will choose a new one\n        - If this instance shares a path with an existing instance, it will\n          replace that instance\n        \"\"\"\n        self._instances = [\n            old_instance\n            for old_instance in self._instances\n            if not i.equals(Path(self._uri.path), instance, old_instance)\n        ]\n        name = instance.name\n        counter = 0\n        taken_names = {old_instance.name for old_instance in self._instances}\n        while True:\n            if name not in taken_names:\n                break\n            counter += 1\n            name = f\"{instance.name}.{counter}\"\n\n        GATHER_LOGGER.debug(f\"Registering instance {instance.name} at {instance.root}\")\n        self._instances.append(instance._replace(name=name))\n        return self._instances[-1]\n\n    @property\n    def remotes(self) -&gt; tuple[tuple[ParseResult, str], ...]:\n        return tuple((remote, alias) for alias, remote in self._remotes.items())\n\n    def register_remote(\n        self, remote: str | ParseResult, alias: str | None = None\n    ) -&gt; None:\n\"\"\"Register a new remote EnderChest installation (or update an existing\n        registry)\n\n        Parameters\n        ----------\n        remote : URI\n            The URI of the remote\n        alias : str, optional\n            an alias to give to this remote. If None is provided, the URI's hostname\n            will be used.\n\n        Raises\n        ------\n        ValueError\n            If the provided remote is invalid\n        \"\"\"\n        try:\n            remote = remote if isinstance(remote, ParseResult) else urlparse(remote)\n            alias = alias or remote.hostname\n            if not alias:\n                raise AttributeError(f\"{remote.geturl()} has no hostname\")\n            GATHER_LOGGER.debug(f\"Registering remote {remote.geturl()} ({alias})\")\n            self._remotes[alias] = remote\n        except AttributeError as parse_problem:\n            raise ValueError(f\"{remote} is not a valid URI\") from parse_problem\n\n    @classmethod\n    def from_cfg(cls, config_file: Path) -&gt; \"EnderChest\":\n\"\"\"Parse an EnderChest from its config file\n\n        Parameters\n        ----------\n        config_file : Path\n            The path to the config file\n\n        Returns\n        -------\n        EnderChest\n            The resulting EnderChest\n\n        Raises\n        ------\n        ValueError\n            If the config file at that location cannot be parsed\n        FileNotFoundError\n            If there is no config file at the specified location\n        \"\"\"\n        parser = ConfigParser(\n            allow_no_value=True, delimiters=(\"=\",), inline_comment_prefixes=(\";\",)\n        )\n        try:\n            assert parser.read(config_file)\n        except ParsingError as bad_cfg:\n            raise ValueError(f\"Could not parse {config_file}\") from bad_cfg\n        except AssertionError:\n            raise FileNotFoundError(f\"Could not open {config_file}\")\n\n        # All I'm gonna say is that Windows pathing is the worst\n        path = urlparse(config_file.absolute().parent.parent.as_uri()).path\n\n        instances: list[i.InstanceSpec] = []\n        remotes: list[str | tuple[str, str]] = []\n\n        scheme: str | None = None\n        netloc: str | None = None\n        name: str | None = None\n\n        for section in parser.sections():\n            if section == \"properties\":\n                scheme = parser[section].get(\"sync-protocol\")\n                netloc = parser[section].get(\"address\")\n                name = parser[section].get(\"name\")\n            elif section == \"remotes\":\n                for remote in parser[section].items():\n                    if remote[1] is None:\n                        remotes.append(remote[0])\n                    else:\n                        remotes.append((remote[1], remote[0]))\n            else:\n                instances.append(i.InstanceSpec.from_cfg(parser[section]))\n\n        scheme = scheme or sync.DEFAULT_PROTOCOL\n        netloc = netloc or sync.get_default_netloc()\n        uri = ParseResult(\n            scheme=scheme, netloc=netloc, path=path, params=\"\", query=\"\", fragment=\"\"\n        )\n\n        return EnderChest(uri, name, remotes, instances)\n\n    def write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n\"\"\"Write this EnderChest's configuration to INI\n\n        Parameters\n        ----------\n        config_file : Path, optional\n            The path to the config file, assuming you'd like to write the\n            contents to file\n\n        Returns\n        -------\n        str\n            An INI-syntax rendering of this EnderChest's config\n\n        Notes\n        -----\n        The \"root\" attribute is ignored for this method\n        \"\"\"\n        config = ConfigParser(allow_no_value=True)\n        config.add_section(\"properties\")\n        config.set(\"properties\", \"name\", self.name)\n        config.set(\"properties\", \"address\", self._uri.netloc)\n        config.set(\"properties\", \"sync-protocol\", self._uri.scheme)\n        config.set(\"properties\", \"last_modified\", dt.datetime.now().isoformat(sep=\" \"))\n        config.set(\n            \"properties\", \"generated_by_enderchest_version\", get_versions()[\"version\"]\n        )\n\n        config.add_section(\"remotes\")\n        for uri, name in self.remotes:\n            if name != uri.hostname:\n                config.set(\"remotes\", name, uri.geturl())\n            else:\n                config.set(\"remotes\", uri.geturl())\n        for instance in self.instances:\n            config.add_section(instance.name)\n            config.set(instance.name, \"root\", str(instance.root))\n            config.set(\n                instance.name,\n                \"minecraft_version\",\n                _list_to_ini(instance.minecraft_versions),\n            )\n            config.set(instance.name, \"modloader\", instance.modloader)\n            config.set(\n                instance.name,\n                \"tags\",\n                _list_to_ini(instance.tags),\n            )\n\n        buffer = StringIO()\n        buffer.write(f\"; {fs.ENDER_CHEST_CONFIG_NAME}\\n\")\n        config.write(buffer)\n        buffer.seek(0)  # rewind\n\n        if config_file:\n            config_file.write_text(buffer.read())\n            buffer.seek(0)\n        return buffer.read()\n</code></pre>"},{"location":"reference/enderchest/#enderchest.enderchest.EnderChest.from_cfg","title":"<code>from_cfg(config_file)</code>  <code>classmethod</code>","text":"<p>Parse an EnderChest from its config file</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path</code> <p>The path to the config file</p> required <p>Returns:</p> Type Description <code>EnderChest</code> <p>The resulting EnderChest</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the config file at that location cannot be parsed</p> <code>FileNotFoundError</code> <p>If there is no config file at the specified location</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>@classmethod\ndef from_cfg(cls, config_file: Path) -&gt; \"EnderChest\":\n\"\"\"Parse an EnderChest from its config file\n\n    Parameters\n    ----------\n    config_file : Path\n        The path to the config file\n\n    Returns\n    -------\n    EnderChest\n        The resulting EnderChest\n\n    Raises\n    ------\n    ValueError\n        If the config file at that location cannot be parsed\n    FileNotFoundError\n        If there is no config file at the specified location\n    \"\"\"\n    parser = ConfigParser(\n        allow_no_value=True, delimiters=(\"=\",), inline_comment_prefixes=(\";\",)\n    )\n    try:\n        assert parser.read(config_file)\n    except ParsingError as bad_cfg:\n        raise ValueError(f\"Could not parse {config_file}\") from bad_cfg\n    except AssertionError:\n        raise FileNotFoundError(f\"Could not open {config_file}\")\n\n    # All I'm gonna say is that Windows pathing is the worst\n    path = urlparse(config_file.absolute().parent.parent.as_uri()).path\n\n    instances: list[i.InstanceSpec] = []\n    remotes: list[str | tuple[str, str]] = []\n\n    scheme: str | None = None\n    netloc: str | None = None\n    name: str | None = None\n\n    for section in parser.sections():\n        if section == \"properties\":\n            scheme = parser[section].get(\"sync-protocol\")\n            netloc = parser[section].get(\"address\")\n            name = parser[section].get(\"name\")\n        elif section == \"remotes\":\n            for remote in parser[section].items():\n                if remote[1] is None:\n                    remotes.append(remote[0])\n                else:\n                    remotes.append((remote[1], remote[0]))\n        else:\n            instances.append(i.InstanceSpec.from_cfg(parser[section]))\n\n    scheme = scheme or sync.DEFAULT_PROTOCOL\n    netloc = netloc or sync.get_default_netloc()\n    uri = ParseResult(\n        scheme=scheme, netloc=netloc, path=path, params=\"\", query=\"\", fragment=\"\"\n    )\n\n    return EnderChest(uri, name, remotes, instances)\n</code></pre>"},{"location":"reference/enderchest/#enderchest.enderchest.EnderChest.register_instance","title":"<code>register_instance(instance)</code>","text":"<p>Register a new Minecraft installation</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>InstanceSpec</code> <p>The instance to register</p> required <p>Returns:</p> Type Description <code>InstanceSpec</code> <p>The spec of the instance as it was actually registered (in case the name changed or somesuch)</p>"},{"location":"reference/enderchest/#enderchest.enderchest.EnderChest.register_instance--notes","title":"Notes","text":"<ul> <li>If the instance's name is already assigned to a registered instance,   this method will choose a new one</li> <li>If this instance shares a path with an existing instance, it will   replace that instance</li> </ul> Source code in <code>enderchest/enderchest.py</code> <pre><code>def register_instance(self, instance: i.InstanceSpec) -&gt; i.InstanceSpec:\n\"\"\"Register a new Minecraft installation\n\n    Parameters\n    ----------\n    instance : InstanceSpec\n        The instance to register\n\n    Returns\n    -------\n    InstanceSpec\n        The spec of the instance as it was actually registered (in case the\n        name changed or somesuch)\n\n    Notes\n    -----\n    - If the instance's name is already assigned to a registered instance,\n      this method will choose a new one\n    - If this instance shares a path with an existing instance, it will\n      replace that instance\n    \"\"\"\n    self._instances = [\n        old_instance\n        for old_instance in self._instances\n        if not i.equals(Path(self._uri.path), instance, old_instance)\n    ]\n    name = instance.name\n    counter = 0\n    taken_names = {old_instance.name for old_instance in self._instances}\n    while True:\n        if name not in taken_names:\n            break\n        counter += 1\n        name = f\"{instance.name}.{counter}\"\n\n    GATHER_LOGGER.debug(f\"Registering instance {instance.name} at {instance.root}\")\n    self._instances.append(instance._replace(name=name))\n    return self._instances[-1]\n</code></pre>"},{"location":"reference/enderchest/#enderchest.enderchest.EnderChest.register_remote","title":"<code>register_remote(remote, alias=None)</code>","text":"<p>Register a new remote EnderChest installation (or update an existing registry)</p> <p>Parameters:</p> Name Type Description Default <code>remote</code> <code>URI</code> <p>The URI of the remote</p> required <code>alias</code> <code>str, optional</code> <p>an alias to give to this remote. If None is provided, the URI's hostname will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided remote is invalid</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>def register_remote(\n    self, remote: str | ParseResult, alias: str | None = None\n) -&gt; None:\n\"\"\"Register a new remote EnderChest installation (or update an existing\n    registry)\n\n    Parameters\n    ----------\n    remote : URI\n        The URI of the remote\n    alias : str, optional\n        an alias to give to this remote. If None is provided, the URI's hostname\n        will be used.\n\n    Raises\n    ------\n    ValueError\n        If the provided remote is invalid\n    \"\"\"\n    try:\n        remote = remote if isinstance(remote, ParseResult) else urlparse(remote)\n        alias = alias or remote.hostname\n        if not alias:\n            raise AttributeError(f\"{remote.geturl()} has no hostname\")\n        GATHER_LOGGER.debug(f\"Registering remote {remote.geturl()} ({alias})\")\n        self._remotes[alias] = remote\n    except AttributeError as parse_problem:\n        raise ValueError(f\"{remote} is not a valid URI\") from parse_problem\n</code></pre>"},{"location":"reference/enderchest/#enderchest.enderchest.EnderChest.write_to_cfg","title":"<code>write_to_cfg(config_file=None)</code>","text":"<p>Write this EnderChest's configuration to INI</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path, optional</code> <p>The path to the config file, assuming you'd like to write the contents to file</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>An INI-syntax rendering of this EnderChest's config</p>"},{"location":"reference/enderchest/#enderchest.enderchest.EnderChest.write_to_cfg--notes","title":"Notes","text":"<p>The \"root\" attribute is ignored for this method</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>def write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n\"\"\"Write this EnderChest's configuration to INI\n\n    Parameters\n    ----------\n    config_file : Path, optional\n        The path to the config file, assuming you'd like to write the\n        contents to file\n\n    Returns\n    -------\n    str\n        An INI-syntax rendering of this EnderChest's config\n\n    Notes\n    -----\n    The \"root\" attribute is ignored for this method\n    \"\"\"\n    config = ConfigParser(allow_no_value=True)\n    config.add_section(\"properties\")\n    config.set(\"properties\", \"name\", self.name)\n    config.set(\"properties\", \"address\", self._uri.netloc)\n    config.set(\"properties\", \"sync-protocol\", self._uri.scheme)\n    config.set(\"properties\", \"last_modified\", dt.datetime.now().isoformat(sep=\" \"))\n    config.set(\n        \"properties\", \"generated_by_enderchest_version\", get_versions()[\"version\"]\n    )\n\n    config.add_section(\"remotes\")\n    for uri, name in self.remotes:\n        if name != uri.hostname:\n            config.set(\"remotes\", name, uri.geturl())\n        else:\n            config.set(\"remotes\", uri.geturl())\n    for instance in self.instances:\n        config.add_section(instance.name)\n        config.set(instance.name, \"root\", str(instance.root))\n        config.set(\n            instance.name,\n            \"minecraft_version\",\n            _list_to_ini(instance.minecraft_versions),\n        )\n        config.set(instance.name, \"modloader\", instance.modloader)\n        config.set(\n            instance.name,\n            \"tags\",\n            _list_to_ini(instance.tags),\n        )\n\n    buffer = StringIO()\n    buffer.write(f\"; {fs.ENDER_CHEST_CONFIG_NAME}\\n\")\n    config.write(buffer)\n    buffer.seek(0)  # rewind\n\n    if config_file:\n        config_file.write_text(buffer.read())\n        buffer.seek(0)\n    return buffer.read()\n</code></pre>"},{"location":"reference/enderchest/#enderchest.InstanceSpec","title":"<code>InstanceSpec</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Specification of a Minecraft instance</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The \"display name\" for the instance</p> required <code>root</code> <code>Path</code> <p>The path to its \".minecraft\" folder</p> required <code>minecraft_versions</code> <code>list-like of str</code> <p>The minecraft versions of this instance. This is typically a 1-tuple, but some loaders (such as the official one) will just comingle all your assets together across all profiles</p> required <code>modloader</code> <code>str or None</code> <p>The (display) name of the modloader, or None if this is a vanilla instance</p> required <code>tags</code> <code>list-like of str</code> <p>The tags assigned to this instance</p> required Source code in <code>enderchest/instance.py</code> <pre><code>class InstanceSpec(NamedTuple):\n\"\"\"Specification of a Minecraft instance\n    Parameters\n    ----------\n    name : str\n        The \"display name\" for the instance\n    root : Path\n        The path to its \".minecraft\" folder\n    minecraft_versions : list-like of str\n        The minecraft versions of this instance. This is typically a 1-tuple,\n        but some loaders (such as the official one) will just comingle all\n        your assets together across all profiles\n    modloader : str or None\n        The (display) name of the modloader, or None if this is a vanilla\n        instance\n    tags : list-like of str\n        The tags assigned to this instance\n    \"\"\"\n\n    name: str\n    root: Path\n    minecraft_versions: tuple[str, ...]\n    modloader: str | None\n    tags: tuple[str, ...]\n\n    @classmethod\n    def from_cfg(cls, section: SectionProxy) -&gt; \"InstanceSpec\":\n\"\"\"Parse an instance spec as read in from the enderchest config file\n\n        Parameters\n        ----------\n        section : dict-like of str to str\n            The section in the enderchest config as parsed by a ConfigParser\n\n        Returns\n        -------\n        InstanceSpec\n            The resulting InstanceSpec\n\n        Raises\n        ------\n        KeyError\n            If a required key is absent\n        ValueError\n            If a required entry cannot be parsed\n        \"\"\"\n        return cls(\n            section.name,\n            Path(section[\"root\"]),\n            tuple(section[\"minecraft_version\"].strip().split()),\n            section.get(\"modloader\", None),\n            tuple(\n                tag.strip()\n                for tag in section.get(\"tags\", \"\")\n                .replace(\",\", \"\\n\")\n                .strip()\n                .split(\"\\n\")\n            ),\n        )\n</code></pre>"},{"location":"reference/enderchest/#enderchest.instance.InstanceSpec.from_cfg","title":"<code>from_cfg(section)</code>  <code>classmethod</code>","text":"<p>Parse an instance spec as read in from the enderchest config file</p> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>dict-like of str to str</code> <p>The section in the enderchest config as parsed by a ConfigParser</p> required <p>Returns:</p> Type Description <code>InstanceSpec</code> <p>The resulting InstanceSpec</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If a required key is absent</p> <code>ValueError</code> <p>If a required entry cannot be parsed</p> Source code in <code>enderchest/instance.py</code> <pre><code>@classmethod\ndef from_cfg(cls, section: SectionProxy) -&gt; \"InstanceSpec\":\n\"\"\"Parse an instance spec as read in from the enderchest config file\n\n    Parameters\n    ----------\n    section : dict-like of str to str\n        The section in the enderchest config as parsed by a ConfigParser\n\n    Returns\n    -------\n    InstanceSpec\n        The resulting InstanceSpec\n\n    Raises\n    ------\n    KeyError\n        If a required key is absent\n    ValueError\n        If a required entry cannot be parsed\n    \"\"\"\n    return cls(\n        section.name,\n        Path(section[\"root\"]),\n        tuple(section[\"minecraft_version\"].strip().split()),\n        section.get(\"modloader\", None),\n        tuple(\n            tag.strip()\n            for tag in section.get(\"tags\", \"\")\n            .replace(\",\", \"\\n\")\n            .strip()\n            .split(\"\\n\")\n        ),\n    )\n</code></pre>"},{"location":"reference/enderchest/#enderchest.ShulkerBox","title":"<code>ShulkerBox</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Specification of a ShulkerBox</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>The priority for linking assets in the shulker box (higher priority shulkers are linked last)</p> required <code>name</code> <code>str</code> <p>The name of the shulker box (which is incidetentally used to break priority ties)</p> required <code>root</code> <code>Path</code> <p>The path to the root of the shulker box</p> required <code>match_criteria</code> <code>list-like of tuples</code> <p>The parameters for matching instances to this shulker box. Each element consistents of: - the name of the condition - the matching values for that condition</p> <p>The logic applied is that an instance must match at least one value for each condition (so it's ANDing a collection of ORs)</p> required <code>link_folders</code> <code>list-like of str</code> <p>The folders that should be linked in their entirety</p> required"},{"location":"reference/enderchest/#enderchest.ShulkerBox--notes","title":"Notes","text":"<p>A shulker box specification is immutable, so making changes (such as updating the match critera) can only be done on copies created via the <code>_replace</code> method, inherited from the NamedTuple parent class.</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>class ShulkerBox(NamedTuple):\n\"\"\"Specification of a ShulkerBox\n\n    Parameters\n    ----------\n    priority : int\n        The priority for linking assets in the shulker box (higher priority\n        shulkers are linked last)\n    name : str\n        The name of the shulker box (which is incidetentally used to break\n        priority ties)\n    root : Path\n        The path to the root of the shulker box\n    match_criteria : list-like of tuples\n        The parameters for matching instances to this shulker box. Each element\n        consistents of:\n          - the name of the condition\n          - the matching values for that condition\n\n        The logic applied is that an instance must match at least one value\n        for each condition (so it's ANDing a collection of ORs)\n    link_folders : list-like of str\n        The folders that should be linked in their entirety\n\n    Notes\n    -----\n    A shulker box specification is immutable, so making changes (such as\n    updating the match critera) can only be done on copies created via the\n    `_replace` method, inherited from the NamedTuple parent class.\n    \"\"\"\n\n    priority: int\n    name: str\n    root: Path\n    match_criteria: tuple[tuple[str, tuple[str, ...]], ...]\n    link_folders: tuple[str, ...]\n\n    @classmethod\n    def from_cfg(cls, config_file: Path) -&gt; \"ShulkerBox\":\n\"\"\"Parse a shulker box from its config file\n\n        Parameters\n        ----------\n        config_file : Path\n            The path to the config file\n\n        Returns\n        -------\n        ShulkerBox\n            The resulting ShulkerBox\n\n        Raises\n        ------\n        ValueError\n            If the config file at that location cannot be parsed\n        FileNotFoundError\n            If there is no config file at the specified location\n        \"\"\"\n        priority = 0\n        root = config_file.parent\n        name = root.name\n        parser = ConfigParser(allow_no_value=True, inline_comment_prefixes=(\";\",))\n        try:\n            assert parser.read(config_file)\n        except ParsingError as bad_cfg:\n            raise ValueError(f\"Could not parse {config_file}\") from bad_cfg\n        except AssertionError:\n            raise FileNotFoundError(f\"Could not open {config_file}\")\n\n        match_criteria: dict[str, tuple[str, ...]] = {}\n\n        for section in parser.sections():\n            normalized = (\n                section.lower().replace(\" \", \"\").replace(\"-\", \"\").replace(\"_\", \"\")\n            )\n            if normalized.endswith(\"s\"):\n                normalized = normalized[:-1]  # lazy de-pluralization\n            if normalized in (\"linkfolder\", \"folder\"):\n                normalized = \"link-folders\"\n            if normalized in (\"minecraft\", \"version\", \"minecraftversion\"):\n                normalized = \"minecraft\"\n            if normalized in (\"modloader\", \"loader\"):\n                normalized = \"modloader\"\n            if normalized in (\"instance\", \"tag\", \"host\"):\n                normalized += \"s\"  # lazy re-pluralization\n\n            if normalized == \"propertie\":  # lulz\n                # TODO check to make sure properties hasn't been read before\n                # most of this section gets ignored\n                priority = parser[section].getint(\"priority\", 0)\n                # TODO: support specifying filters (and link-folders) in the properties section\n                continue\n            if normalized in match_criteria.keys():\n                raise ValueError(f\"{config_file} specifies {normalized} more than once\")\n\n            if normalized == \"minecraft\":\n                minecraft_versions = []\n                for key, value in parser[section].items():\n                    if value is None:\n                        minecraft_versions.append(key)\n                    elif key.lower().strip().startswith(\"version\"):\n                        minecraft_versions.append(value)\n                    else:  # what happens if you specify \"&gt;=1.19\" or \"=1.12\"\n                        minecraft_versions.append(\"=\".join((key, value)))\n                match_criteria[\"minecraft\"] = tuple(minecraft_versions)\n            else:\n                # really hoping delimiter shenanigans doesn't show up anywhere else\n                match_criteria[normalized] = tuple(parser[section].keys())\n\n        link_folders = match_criteria.pop(\"link-folders\", ())\n\n        return cls(priority, name, root, tuple(match_criteria.items()), link_folders)\n\n    def write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n\"\"\"Write this shulker's configuration to INI\n\n        Parameters\n        ----------\n        config_file : Path, optional\n            The path to the config file, assuming you'd like to write the\n            contents to file\n\n        Returns\n        -------\n        str\n            An INI-syntax rendering of this shulker box's config\n\n        Notes\n        -----\n        The \"root\" attribute is ignored for this method\n        \"\"\"\n        config = ConfigParser(allow_no_value=True)\n        config.add_section(\"properties\")\n        config.set(\"properties\", \"priority\", str(self.priority))\n        config.set(\"properties\", \"last_modified\", dt.datetime.now().isoformat(sep=\" \"))\n        config.set(\n            \"properties\", \"generated_by_enderchest_version\", get_versions()[\"version\"]\n        )\n\n        for condition, values in self.match_criteria:\n            config.add_section(condition)\n            for value in values:\n                config.set(condition, value)\n\n        config.add_section(\"link-folders\")\n        for folder in self.link_folders:\n            config.set(\"link-folders\", folder)\n\n        buffer = StringIO()\n        buffer.write(f\"; {os.path.join(self.name, fs.SHULKER_BOX_CONFIG_NAME)}\\n\")\n        config.write(buffer)\n        buffer.seek(0)  # rewind\n\n        if config_file:\n            config_file.write_text(buffer.read())\n            buffer.seek(0)\n        return buffer.read()\n\n    def matches(self, instance: InstanceSpec) -&gt; bool:\n\"\"\"Determine whether the shulker box matches the given instance\n\n        Parameters\n        ----------\n        instance : InstanceSpec\n            The instance's specification\n\n        Returns\n        -------\n        bool\n            True if the instance matches the shulker box's conditions, False\n            otherwise.\n        \"\"\"\n        for condition, values in self.match_criteria:\n            match condition:  # these should have been normalized on read-in\n                case \"instances\":\n                    for value in values:\n                        if fnmatch.fnmatchcase(instance.name, value):\n                            break\n                    else:\n                        return False\n                case \"tags\":\n                    for value in values:\n                        if fnmatch.filter(\n                            [tag.lower() for tag in instance.tags], value.lower()\n                        ):\n                            break\n                    else:\n                        return False\n                case \"modloader\":\n                    normalized: list[str] = sum(\n                        [_normalize_modloader(value) for value in values], []\n                    )\n                    for value in normalized:\n                        if fnmatch.filter(\n                            [\n                                loader.lower()\n                                for loader in _normalize_modloader(instance.modloader)\n                            ],\n                            value.lower(),\n                        ):\n                            break\n                    else:\n                        return False\n                case \"minecraft\":\n                    for value in values:\n                        if any(\n                            (\n                                _matches_version(value, version)\n                                for version in instance.minecraft_versions\n                            )\n                        ):\n                            break\n                    else:\n                        return False\n                case \"hosts\":\n                    # this is handled at a higher level\n                    pass\n                case _:\n                    raise NotImplementedError(\n                        f\"Don't know how to apply match condition {condition}.\"\n                    )\n\n        return True\n</code></pre>"},{"location":"reference/enderchest/#enderchest.shulker_box.ShulkerBox.from_cfg","title":"<code>from_cfg(config_file)</code>  <code>classmethod</code>","text":"<p>Parse a shulker box from its config file</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path</code> <p>The path to the config file</p> required <p>Returns:</p> Type Description <code>ShulkerBox</code> <p>The resulting ShulkerBox</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the config file at that location cannot be parsed</p> <code>FileNotFoundError</code> <p>If there is no config file at the specified location</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>@classmethod\ndef from_cfg(cls, config_file: Path) -&gt; \"ShulkerBox\":\n\"\"\"Parse a shulker box from its config file\n\n    Parameters\n    ----------\n    config_file : Path\n        The path to the config file\n\n    Returns\n    -------\n    ShulkerBox\n        The resulting ShulkerBox\n\n    Raises\n    ------\n    ValueError\n        If the config file at that location cannot be parsed\n    FileNotFoundError\n        If there is no config file at the specified location\n    \"\"\"\n    priority = 0\n    root = config_file.parent\n    name = root.name\n    parser = ConfigParser(allow_no_value=True, inline_comment_prefixes=(\";\",))\n    try:\n        assert parser.read(config_file)\n    except ParsingError as bad_cfg:\n        raise ValueError(f\"Could not parse {config_file}\") from bad_cfg\n    except AssertionError:\n        raise FileNotFoundError(f\"Could not open {config_file}\")\n\n    match_criteria: dict[str, tuple[str, ...]] = {}\n\n    for section in parser.sections():\n        normalized = (\n            section.lower().replace(\" \", \"\").replace(\"-\", \"\").replace(\"_\", \"\")\n        )\n        if normalized.endswith(\"s\"):\n            normalized = normalized[:-1]  # lazy de-pluralization\n        if normalized in (\"linkfolder\", \"folder\"):\n            normalized = \"link-folders\"\n        if normalized in (\"minecraft\", \"version\", \"minecraftversion\"):\n            normalized = \"minecraft\"\n        if normalized in (\"modloader\", \"loader\"):\n            normalized = \"modloader\"\n        if normalized in (\"instance\", \"tag\", \"host\"):\n            normalized += \"s\"  # lazy re-pluralization\n\n        if normalized == \"propertie\":  # lulz\n            # TODO check to make sure properties hasn't been read before\n            # most of this section gets ignored\n            priority = parser[section].getint(\"priority\", 0)\n            # TODO: support specifying filters (and link-folders) in the properties section\n            continue\n        if normalized in match_criteria.keys():\n            raise ValueError(f\"{config_file} specifies {normalized} more than once\")\n\n        if normalized == \"minecraft\":\n            minecraft_versions = []\n            for key, value in parser[section].items():\n                if value is None:\n                    minecraft_versions.append(key)\n                elif key.lower().strip().startswith(\"version\"):\n                    minecraft_versions.append(value)\n                else:  # what happens if you specify \"&gt;=1.19\" or \"=1.12\"\n                    minecraft_versions.append(\"=\".join((key, value)))\n            match_criteria[\"minecraft\"] = tuple(minecraft_versions)\n        else:\n            # really hoping delimiter shenanigans doesn't show up anywhere else\n            match_criteria[normalized] = tuple(parser[section].keys())\n\n    link_folders = match_criteria.pop(\"link-folders\", ())\n\n    return cls(priority, name, root, tuple(match_criteria.items()), link_folders)\n</code></pre>"},{"location":"reference/enderchest/#enderchest.shulker_box.ShulkerBox.matches","title":"<code>matches(instance)</code>","text":"<p>Determine whether the shulker box matches the given instance</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>InstanceSpec</code> <p>The instance's specification</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the instance matches the shulker box's conditions, False otherwise.</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>def matches(self, instance: InstanceSpec) -&gt; bool:\n\"\"\"Determine whether the shulker box matches the given instance\n\n    Parameters\n    ----------\n    instance : InstanceSpec\n        The instance's specification\n\n    Returns\n    -------\n    bool\n        True if the instance matches the shulker box's conditions, False\n        otherwise.\n    \"\"\"\n    for condition, values in self.match_criteria:\n        match condition:  # these should have been normalized on read-in\n            case \"instances\":\n                for value in values:\n                    if fnmatch.fnmatchcase(instance.name, value):\n                        break\n                else:\n                    return False\n            case \"tags\":\n                for value in values:\n                    if fnmatch.filter(\n                        [tag.lower() for tag in instance.tags], value.lower()\n                    ):\n                        break\n                else:\n                    return False\n            case \"modloader\":\n                normalized: list[str] = sum(\n                    [_normalize_modloader(value) for value in values], []\n                )\n                for value in normalized:\n                    if fnmatch.filter(\n                        [\n                            loader.lower()\n                            for loader in _normalize_modloader(instance.modloader)\n                        ],\n                        value.lower(),\n                    ):\n                        break\n                else:\n                    return False\n            case \"minecraft\":\n                for value in values:\n                    if any(\n                        (\n                            _matches_version(value, version)\n                            for version in instance.minecraft_versions\n                        )\n                    ):\n                        break\n                else:\n                    return False\n            case \"hosts\":\n                # this is handled at a higher level\n                pass\n            case _:\n                raise NotImplementedError(\n                    f\"Don't know how to apply match condition {condition}.\"\n                )\n\n    return True\n</code></pre>"},{"location":"reference/enderchest/#enderchest.shulker_box.ShulkerBox.write_to_cfg","title":"<code>write_to_cfg(config_file=None)</code>","text":"<p>Write this shulker's configuration to INI</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path, optional</code> <p>The path to the config file, assuming you'd like to write the contents to file</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>An INI-syntax rendering of this shulker box's config</p>"},{"location":"reference/enderchest/#enderchest.shulker_box.ShulkerBox.write_to_cfg--notes","title":"Notes","text":"<p>The \"root\" attribute is ignored for this method</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>def write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n\"\"\"Write this shulker's configuration to INI\n\n    Parameters\n    ----------\n    config_file : Path, optional\n        The path to the config file, assuming you'd like to write the\n        contents to file\n\n    Returns\n    -------\n    str\n        An INI-syntax rendering of this shulker box's config\n\n    Notes\n    -----\n    The \"root\" attribute is ignored for this method\n    \"\"\"\n    config = ConfigParser(allow_no_value=True)\n    config.add_section(\"properties\")\n    config.set(\"properties\", \"priority\", str(self.priority))\n    config.set(\"properties\", \"last_modified\", dt.datetime.now().isoformat(sep=\" \"))\n    config.set(\n        \"properties\", \"generated_by_enderchest_version\", get_versions()[\"version\"]\n    )\n\n    for condition, values in self.match_criteria:\n        config.add_section(condition)\n        for value in values:\n            config.set(condition, value)\n\n    config.add_section(\"link-folders\")\n    for folder in self.link_folders:\n        config.set(\"link-folders\", folder)\n\n    buffer = StringIO()\n    buffer.write(f\"; {os.path.join(self.name, fs.SHULKER_BOX_CONFIG_NAME)}\\n\")\n    config.write(buffer)\n    buffer.seek(0)  # rewind\n\n    if config_file:\n        config_file.write_text(buffer.read())\n        buffer.seek(0)\n    return buffer.read()\n</code></pre>"},{"location":"reference/enderchest/cli/","title":"cli","text":"<p>Command-line interface</p>"},{"location":"reference/enderchest/cli/#enderchest.cli.parse_args","title":"<code>parse_args(argv)</code>","text":"<p>Parse the provided command-line options to determine the action to perform and the arguments to pass to the action</p> <p>Parameters:</p> Name Type Description Default <code>argv</code> <code>list-like of str (sys.argv)</code> <p>The options passed into the command line</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The action method that will be called</p> <code>str</code> <p>The root of the minecraft folder (parent of the EnderChest) where the action will be perfomed</p> <code>int</code> <p>The verbosity level of the operation (in terms of log levels)</p> <code>dict</code> <p>Any additional options that will be given to the action method</p> Source code in <code>enderchest/cli.py</code> <pre><code>def parse_args(argv: Sequence[str]) -&gt; tuple[Action, Path, int, dict[str, Any]]:\n\"\"\"Parse the provided command-line options to determine the action to perform and\n    the arguments to pass to the action\n\n    Parameters\n    ----------\n    argv : list-like of str (sys.argv)\n        The options passed into the command line\n\n    Returns\n    -------\n    Callable\n        The action method that will be called\n    str\n        The root of the minecraft folder (parent of the EnderChest)\n        where the action will be perfomed\n    int\n        The verbosity level of the operation (in terms of log levels)\n    dict\n        Any additional options that will be given to the action method\n\n    \"\"\"\n    actions: dict[str, Action] = {}\n    aliases: dict[str, str] = {}\n    descriptions: dict[str, str] = {}\n    root_description: str = \"\"\n    for commands, description, method in ACTIONS:\n        for command in commands:\n            aliases[command] = commands[0]\n        actions[commands[0]] = method\n        descriptions[commands[0]] = description\n        root_description += f\"\\n\\t{commands[0]}\\n\\t\\tto {description}\"\n\n    enderchest_parser = argparse.ArgumentParser(\n        prog=\"enderchest\",\n        description=(\n            f\"v{get_versions()['version']}\\n\"\n            \"\\nsyncing and linking for all your Minecraft instances\"\n        ),\n        formatter_class=argparse.RawTextHelpFormatter,\n    )\n\n    enderchest_parser.add_argument(\n        \"-v\",  # don't worry--this doesn't actually conflict with --verbose\n        \"--version\",\n        action=\"version\",\n        version=f\"%(prog)s v{get_versions()['version']}\",\n    )\n\n    # these are really just for the sake of --help\n    # (the parsed args aren't actually used)\n    enderchest_parser.add_argument(\n        \"action\",\n        help=f\"the action to perform. Options are:{root_description}\",\n        type=str,\n    )\n    enderchest_parser.add_argument(\n        \"arguments\",\n        nargs=\"*\",\n        help=\"any additional arguments for the specific action.\"\n        \" To learn more, try: enderchest {action} -h\",\n    )\n\n    action_parsers: dict[str, argparse.ArgumentParser] = {}\n    for command in actions.keys():\n        parser = argparse.ArgumentParser(\n            prog=f\"enderchest {command}\", description=descriptions[command]\n        )\n        root = parser.add_mutually_exclusive_group()\n        root.add_argument(\n            \"root\",\n            nargs=\"?\",\n            help=(\n                \"optionally specify your root minecraft directory.\"\n                \"  If no path is given, the current working directory will be used.\"\n            ),\n            type=Path,\n        )\n        root.add_argument(\n            \"--root\",\n            dest=\"root_flag\",\n            help=\"specify your root minecraft directory\",\n            type=Path,\n        )\n\n        # I'm actually okay with -vvqvqqv hilarity\n        parser.add_argument(\n            \"--verbose\",\n            \"-v\",\n            action=\"count\",\n            default=0,\n            help=\"increase the amount of information that's printed\",\n        )\n        parser.add_argument(\n            \"--quiet\",\n            \"-q\",\n            action=\"count\",\n            default=0,\n            help=\"decrease the amount of information that's printed\",\n        )\n        action_parsers[command] = parser\n\n    # craft options\n    craft_parser = action_parsers[\"craft\"]\n    craft_parser.add_argument(\n        \"--from\",\n        dest=\"copy_from\",\n        help=(\n            \"provide the URI (e.g. rsync://deck@my-steam-deck/home/deck/) of a\"\n            \" remote EnderChest installation that can be used\"\n            \" to boostrap the creation of this one.\"\n        ),\n    )\n    craft_parser.add_argument(\n        \"-r\",\n        \"--remote\",\n        dest=\"remotes\",\n        action=\"append\",\n        help=(\n            \"provide the URI (e.g. rsync://deck@my-steam-deck/home/deck/) of a\"\n            \" remote EnderChest installation to register with this one\"\n        ),\n    )\n    craft_parser.add_argument(\n        \"-i\",\n        \"--instance\",\n        dest=\"instance_search_paths\",\n        action=\"append\",\n        type=Path,\n        help=\"specify a folder to search for Minecraft installations in\",\n    )\n    craft_parser.add_argument(\n        \"--overwrite\",\n        action=\"store_true\",\n        help=(\n            \"if there's already an EnderChest installation in this location,\"\n            \" overwrite its configuration\"\n        ),\n    )\n\n    # shulker box craft options\n    shulker_craft_parser = action_parsers[f\"craft {_shulker_aliases[0]}\"]\n    shulker_craft_parser.add_argument(\n        \"name\",\n        help=\"specify the name for this shulker box\",\n    )\n    shulker_craft_parser.add_argument(\n        \"--priority\",\n        \"-p\",\n        help=\"specify the link priority for this shulker box (higher = linked later)\",\n    )\n    shulker_craft_parser.add_argument(\n        \"-i\",\n        \"--instance\",\n        dest=\"instances\",\n        action=\"append\",\n        help=\"only link instances with one of the provided names to this shulker box\",\n    )\n    shulker_craft_parser.add_argument(\n        \"-t\",\n        \"--tag\",\n        dest=\"tags\",\n        action=\"append\",\n        help=\"only link instances with one of the provided tags to this shulker box\",\n    )\n    shulker_craft_parser.add_argument(\n        \"-e\",\n        \"--enderchest\",\n        dest=\"hosts\",\n        action=\"append\",\n        help=(\n            \"only link instances registered to one of the provided EnderChest\"\n            \" installations with this shulker box\"\n        ),\n    )\n    shulker_craft_parser.add_argument(\n        \"-l\",\n        \"--folder\",\n        dest=\"link_folders\",\n        action=\"append\",\n        help=(\n            \"specify the name of a folder inside this shulker box\"\n            \" that should be linked completely\"\n        ),\n    )\n    shulker_craft_parser.add_argument(\n        \"--overwrite\",\n        action=\"store_true\",\n        help=(\n            \"if there's already a shulker box with the specified name,\"\n            \" overwrite its configuration\"\n        ),\n    )\n\n    # place options\n    place_parser = action_parsers[\"place\"]\n    place_parser.add_argument(\n        \"-k\",\n        \"--keep-broken-links\",\n        action=\"store_false\",\n        dest=\"cleanup\",\n        help=\"do not remove broken links from instances\",\n    )\n    error_handling = place_parser.add_mutually_exclusive_group()\n    error_handling.add_argument(\n        \"--stop-at-first-failure\",\n        \"-x\",\n        action=\"store_true\",\n        help=\"stop linking at the first issue\",\n    )\n    error_handling.add_argument(\n        \"--ignore-errors\", action=\"store_true\", help=\"ignore any linking errors\"\n    )\n    error_handling.add_argument(\n        \"--errors\",\n        \"-e\",\n        choices=(\n            \"prompt\",\n            \"ignore\",\n            \"skip\",\n            \"skip-instance\",\n            \"skip-shulker-box\",\n            \"abort\",\n        ),\n        default=\"prompt\",\n        help=\"specify how to handle linking errors (default behavior is to prompt after every error)\",\n    )\n\n    # gather instance options\n    gather_instance_parser = action_parsers[f\"gather\"]\n    gather_instance_parser.add_argument(\n        \"search_paths\",\n        nargs=\"+\",\n        action=\"extend\",\n        type=Path,\n        help=\"specify a folder or folders to search for Minecraft installations\",\n    )\n    instance_type = gather_instance_parser.add_mutually_exclusive_group()\n    instance_type.add_argument(\n        \"--official\",\n        \"-o\",\n        action=\"store_true\",\n        help=\"specify that these are instances managed by the official launcher\",\n    )\n    instance_type.add_argument(\n        \"--mmc\",\n        \"-m\",\n        action=\"store_true\",\n        help=\"specify that these are MultiMC-like instances\",\n    )\n\n    # gather remote options\n    gather_remote_parser = action_parsers[f\"gather {_remote_aliases[0]}\"]\n    gather_remote_parser.add_argument(\n        \"remotes\",\n        nargs=\"+\",\n        action=\"extend\",\n        help=(\n            \"provide URIs (e.g. rsync://deck@my-steam-deck/home/deck/) of any\"\n            \" remote EnderChest installation to register with this one.\"\n            \"Note: you should not use this method if the alias (name) of the\"\n            \"remote does not match the remote's hostname (in this example,\"\n            '\"my-steam-deck\").'\n        ),\n    )\n\n    # list instances options\n\n    # list shulkers options\n\n    # list shulker options\n    list_shulker_parser = action_parsers[f\"{_list_aliases[0]} {_shulker_aliases[0]}\"]\n    list_shulker_parser.add_argument(\n        \"shulker_box_name\", help=\"The name of the shulker box to query\"\n    )\n\n    # open options\n\n    # close options\n\n    _ = enderchest_parser.parse_args(argv[1:2])  # check for --help and --version\n\n    for command in sorted(aliases.keys(), key=lambda x: -len(x)):  # longest first\n        if \" \".join((*argv[1:], \"\")).startswith(command + \" \"):\n            action_kwargs = vars(\n                action_parsers[aliases[command]].parse_args(\n                    argv[1 + len(command.split()) :]\n                )\n            )\n            root_arg = action_kwargs.pop(\"root\")\n            root_flag = action_kwargs.pop(\"root_flag\")\n\n            verbosity = action_kwargs.pop(\"verbose\") - action_kwargs.pop(\"quiet\")\n\n            log_level = logging.INFO - 10 * verbosity\n            if log_level == logging.NOTSET:  # that's 0, annoyingly enough\n                log_level -= 1\n\n            return (\n                actions[aliases[command]],\n                Path(root_arg or root_flag or os.getcwd()),\n                log_level,\n                action_kwargs,\n            )\n    else:\n        enderchest_parser.print_help(sys.stderr)\n        sys.exit(1)\n</code></pre>"},{"location":"reference/enderchest/craft/","title":"craft","text":"<p>Functionality for setting up the folder structure of both chests and shulker boxes</p>"},{"location":"reference/enderchest/craft/#enderchest.craft.craft_ender_chest","title":"<code>craft_ender_chest(minecraft_root, copy_from=None, instance_search_paths=None, remotes=None, overwrite=False)</code>","text":"<p>Craft an EnderChest, either from the specified keyword arguments, or interactively via prompts</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff is in (or, at least, the one inside which you want to create your EnderChest)</p> required <code>copy_from</code> <code>URI, optional</code> <p>Optionally bootstrap your configuration by pulling the list of remotes from an existing remote EnderChest</p> <code>None</code> <code>instance_search_paths</code> <code>list of Paths, optional</code> <p>Any paths to search for Minecraft instances</p> <code>None</code> <code>remotes</code> <code>list of URIs or (URI, str) tuples, optional</code> <p>Any remotes you wish you manually specify. If used with <code>copy_from</code>, these will overwrite any remotes pulled from the remote EnderChest. When a (URI, str) tuple is provided, the second value will be used as the name/alias of the remote.</p> <code>None</code> <code>overwrite</code> <code>bool, optional</code> <p>This method will not overwrite an EnderChest instance installed within the <code>minecraft_root</code> unless the user provides <code>overwrite=True</code></p> <code>False</code>"},{"location":"reference/enderchest/craft/#enderchest.craft.craft_ender_chest--notes","title":"Notes","text":"<ul> <li>The guided / interactive specifier will only be used if no other keyword   arguments are provided (not even <code>overwrite=True</code>)</li> <li>The instance searcher will first attempt to parse any instances it finds   as official-launcher Minecrafts and then, if that doesn't work, will try   parsing them as MultiMC-style instances.</li> <li>The instance searcher is fully recursive, so keep that in mind before   passing in, say \"/\"</li> </ul> Source code in <code>enderchest/craft.py</code> <pre><code>def craft_ender_chest(\n    minecraft_root: Path,\n    copy_from: str | ParseResult | None = None,\n    instance_search_paths: Iterable[str | Path] | None = None,\n    remotes: Iterable[str | ParseResult | tuple[str, str] | tuple[ParseResult, str]]\n    | None = None,\n    overwrite: bool = False,\n) -&gt; None:\n\"\"\"Craft an EnderChest, either from the specified keyword arguments, or\n    interactively via prompts\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff is in (or, at least, the\n        one inside which you want to create your EnderChest)\n    copy_from : URI, optional\n        Optionally bootstrap your configuration by pulling the list of remotes\n        from an existing remote EnderChest\n    instance_search_paths : list of Paths, optional\n        Any paths to search for Minecraft instances\n    remotes : list of URIs or (URI, str) tuples, optional\n        Any remotes you wish you manually specify. If used with `copy_from`, these\n        will overwrite any remotes pulled from the remote EnderChest. When a\n        (URI, str) tuple is provided, the second value will be used as the\n        name/alias of the remote.\n    overwrite : bool, optional\n        This method will not overwrite an EnderChest instance installed within\n        the `minecraft_root` unless the user provides `overwrite=True`\n\n    Notes\n    -----\n    - The guided / interactive specifier will only be used if no other keyword\n      arguments are provided (not even `overwrite=True`)\n    - The instance searcher will first attempt to parse any instances it finds\n      as official-launcher Minecrafts and then, if that doesn't work, will try\n      parsing them as MultiMC-style instances.\n    - The instance searcher is fully recursive, so keep that in mind before\n      passing in, say \"/\"\n    \"\"\"\n    if (\n        copy_from is None\n        and instance_search_paths is None\n        and remotes is None\n        and not overwrite\n    ):\n        # then we go interactive\n        try:\n            ender_chest = specify_ender_chest_from_prompt(minecraft_root)\n        except (FileExistsError, RuntimeError):\n            CRAFT_LOGGER.error(\"Aborting\")\n            return\n    else:\n        try:\n            fs.ender_chest_config(minecraft_root, check_exists=True)\n            exist_message = (\n                f\"There is already an EnderChest installed to {minecraft_root}\"\n            )\n            if overwrite:\n                CRAFT_LOGGER.warning(exist_message)\n            else:\n                CRAFT_LOGGER.error(exist_message)\n                CRAFT_LOGGER.error(\"Aborting\")\n                return\n        except FileNotFoundError:\n            pass  # no existing chest? no problem!\n\n        ender_chest = EnderChest(minecraft_root)\n\n        for search_path in instance_search_paths or ():\n            for instance in gather_minecraft_instances(\n                minecraft_root, Path(search_path), None\n            ):\n                ender_chest.register_instance(instance)\n\n        if copy_from:\n            try:\n                for remote, alias in fetch_remotes_from_a_remote_ender_chest(copy_from):\n                    ender_chest.register_remote(remote, alias)\n            except (RuntimeError, ValueError) as fetch_fail:\n                CRAFT_LOGGER.warning(\n                    f\"Could not fetch remotes from {copy_from}:\\n  {fetch_fail}\"\n                )\n\n        for extra_remote in remotes or ():\n            if isinstance(extra_remote, (str, ParseResult)):\n                ender_chest.register_remote(extra_remote)\n            else:\n                ender_chest.register_remote(*extra_remote)\n\n    create_ender_chest(minecraft_root, ender_chest)\n    CRAFT_LOGGER.info(\n        \"\\nNow craft some shulker boxes via\\n$ enderchest craft shulker_box\\n\"\n    )\n</code></pre>"},{"location":"reference/enderchest/craft/#enderchest.craft.craft_shulker_box","title":"<code>craft_shulker_box(minecraft_root, name, priority=None, link_folders=None, instances=None, tags=None, hosts=None, overwrite=False)</code>","text":"<p>Craft a shulker box, either from the specified keyword arguments, or interactively via prompts</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>name</code> <code>str</code> <p>A name to give to this shulker box</p> required <code>priority</code> <code>int, optional</code> <p>The priority for linking assets in the shulker box (higher priority shulkers are linked last)</p> <code>None</code> <code>link_folders</code> <code>list of str, optional</code> <p>The folders that should be linked in their entirety</p> <code>None</code> <code>instances</code> <code>list of str, optional</code> <p>The names of the instances you'd like to link to this shulker box</p> <code>None</code> <code>tags</code> <code>list of str, optional</code> <p>You can instead (see notes) provide a list of tags where any instances with those tags will be linked to this shulker box</p> <code>None</code> <code>hosts</code> <code>list of str, optional</code> <p>The EnderChest installations that this shulker box should be applied to</p> <code>None</code> <code>overwrite</code> <code>bool, optional</code> <p>This method will not overwrite an existing shulker box unless the user provides <code>overwrite=True</code></p> <code>False</code>"},{"location":"reference/enderchest/craft/#enderchest.craft.craft_shulker_box--notes","title":"Notes","text":"<ul> <li>The guided / interactive specifier will only be used if no other keyword   arguments are provided (not even <code>overwrite=True</code>)</li> <li>The conditions specified by instances, tags and hosts are ANDed   together--that is, if an instance is listed explicitly, but it doesn't   match a provided tag, it will not link to this shulker box</li> <li>Wildcards are supported for instances, tags and hosts (but not link-folders)</li> <li>Not specifying instances, tags or hosts is equivalent to providing <code>[\"*\"]</code></li> <li>When values are provided to the keyword arguments, no validation is performed   to ensure that they are valid or actively in use</li> </ul> Source code in <code>enderchest/craft.py</code> <pre><code>def craft_shulker_box(\n    minecraft_root: Path,\n    name: str,\n    priority: int | None = None,\n    link_folders: Sequence[str] | None = None,\n    instances: Sequence[str] | None = None,\n    tags: Sequence[str] | None = None,\n    hosts: Sequence[str] | None = None,\n    overwrite: bool = False,\n):\n\"\"\"Craft a shulker box, either from the specified keyword arguments, or\n    interactively via prompts\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    name : str\n        A name to give to this shulker box\n    priority : int, optional\n        The priority for linking assets in the shulker box (higher priority\n        shulkers are linked last)\n    link_folders : list of str, optional\n        The folders that should be linked in their entirety\n    instances : list of str, optional\n        The names of the instances you'd like to link to this shulker box\n    tags : list of str, optional\n        You can instead (see notes) provide a list of tags where any instances\n        with those tags will be linked to this shulker box\n    hosts : list of str, optional\n        The EnderChest installations that this shulker box should be applied to\n    overwrite : bool, optional\n        This method will not overwrite an existing shulker box unless the user\n        provides `overwrite=True`\n\n    Notes\n    -----\n    - The guided / interactive specifier will only be used if no other keyword\n      arguments are provided (not even `overwrite=True`)\n    - The conditions specified by instances, tags and hosts are ANDed\n      together--that is, if an instance is listed explicitly, but it doesn't\n      match a provided tag, it will not link to this shulker box\n    - Wildcards are supported for instances, tags and hosts (but not link-folders)\n    - Not specifying instances, tags or hosts is equivalent to providing `[\"*\"]`\n    - When values are provided to the keyword arguments, no validation is performed\n      to ensure that they are valid or actively in use\n    \"\"\"\n    if not is_valid_filename(name):\n        CRAFT_LOGGER.error(f\"{name} is not a valid name: must be useable as a filename\")\n        return\n\n    try:\n        if (\n            priority is None\n            and link_folders is None\n            and instances is None\n            and tags is None\n            and hosts is None\n            and not overwrite\n        ):\n            try:\n                shulker_box = specify_shulker_box_from_prompt(minecraft_root, name)\n            except FileExistsError as seat_taken:\n                CRAFT_LOGGER.error(seat_taken)\n                CRAFT_LOGGER.error(\"Aborting\")\n                return\n        else:\n            config_path = fs.shulker_box_config(minecraft_root, name)\n            if config_path.exists():\n                exist_message = (\n                    f\"There is already a shulker box named {name}\"\n                    f\" in {fs.ender_chest_folder(minecraft_root)}\"\n                )\n                if overwrite:\n                    CRAFT_LOGGER.warning(exist_message)\n                else:\n                    CRAFT_LOGGER.error(exist_message)\n                    CRAFT_LOGGER.error(\"Aborting\")\n                    return\n            match_criteria: list[tuple[str, tuple[str, ...]]] = []\n            if instances is not None:\n                match_criteria.append((\"instances\", tuple(instances)))\n            if tags is not None:\n                match_criteria.append((\"tags\", tuple(tags)))\n            if hosts is not None:\n                match_criteria.append((\"hosts\", tuple(hosts)))\n            shulker_box = ShulkerBox(\n                priority=priority or 0,\n                name=name,\n                root=minecraft_root,\n                match_criteria=tuple(match_criteria),\n                link_folders=tuple(link_folders or ()),\n            )\n    except FileNotFoundError as no_ender_chest:\n        CRAFT_LOGGER.error(no_ender_chest)\n        return\n\n    create_shulker_box(minecraft_root, shulker_box)\n</code></pre>"},{"location":"reference/enderchest/craft/#enderchest.craft.specify_ender_chest_from_prompt","title":"<code>specify_ender_chest_from_prompt(minecraft_root)</code>","text":"<p>Parse an EnderChest based on interactive user input</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff is in (or, at least, the one inside which you want to create your EnderChest)</p> required <p>Returns:</p> Type Description <code>EnderChest</code> <p>The resulting EnderChest</p> Source code in <code>enderchest/craft.py</code> <pre><code>def specify_ender_chest_from_prompt(minecraft_root: Path) -&gt; EnderChest:\n\"\"\"Parse an EnderChest based on interactive user input\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff is in (or, at least, the\n        one inside which you want to create your EnderChest)\n\n    Returns\n    -------\n    EnderChest\n        The resulting EnderChest\n    \"\"\"\n    try:\n        root = fs.ender_chest_folder(minecraft_root)\n        CRAFT_LOGGER.info(\n            f\"This will overwrite the EnderChest configuration at {root}.\"\n        )\n        if not confirm(default=False):\n            message = f\"Aborting: {fs.ender_chest_config(minecraft_root)} exists.\"\n            raise FileExistsError(message)\n    except FileNotFoundError:\n        # good! Then we don't already have an EnderChest here\n        CRAFT_LOGGER.debug(f\"{minecraft_root} does not already contain an EnderChest\")\n        pass\n\n    instances: list[InstanceSpec] = []\n\n    while True:\n        search_home = prompt(\n            \"Would you like to search your home directory for the official launcher?\",\n            suggestion=\"Y/n\",\n        ).lower()\n        if search_home == \"\" or search_home in YES:\n            instances.extend(\n                gather_minecraft_instances(minecraft_root, Path.home(), official=True)\n            )\n        elif search_home not in NO:\n            continue\n        break\n\n    while True:\n        search_here = prompt(\n            \"Would you like to search the current directory for MultiMC-type instances?\",\n            suggestion=\"Y/n\",\n        ).lower()\n        if search_here == \"\" or search_here in YES:\n            instances.extend(\n                gather_minecraft_instances(minecraft_root, Path(), official=False)\n            )\n        elif search_here not in NO:\n            continue\n        break\n\n    if minecraft_root.absolute() != Path().absolute():\n        while True:\n            search_mc_folder = prompt(\n                f\"Would you like to search {minecraft_root} for MultiMC-type instances?\",\n                suggestion=\"Y/n\",\n            ).lower()\n            if search_mc_folder == \"\" or search_here in YES:\n                instances.extend(\n                    gather_minecraft_instances(\n                        minecraft_root, minecraft_root, official=False\n                    )\n                )\n            elif search_mc_folder not in NO:\n                continue\n            break\n\n    CRAFT_LOGGER.info(\n        \"\\nYou can always add more instances later using\"\n        \"\\n$ enderchest gather minecraft\\n\"\n    )\n\n    while True:\n        remotes: list[tuple[ParseResult, str]] = []\n        remote_uri = prompt(\n            \"Would you like to grab the list of remotes from another EnderChest?\"\n            \"\\nIf so, enter the URI of that EnderChest now (leave empty to skip).\"\n        )\n        if remote_uri == \"\":\n            break\n        try:\n            remotes.extend(fetch_remotes_from_a_remote_ender_chest(remote_uri))\n        except Exception as fetch_fail:\n            CRAFT_LOGGER.error(\n                f\"Could not fetch remotes from {remote_uri}\\n  {fetch_fail}\"\n            )\n            if confirm(default=True):\n                break\n\n    CRAFT_LOGGER.info(\n        \"\\nYou can always add more remotes later using\"\n        \"\\n$ enderchest gather enderchest\\n\"\n    )\n\n    while True:\n        protocol = (\n            prompt(\n                (\n                    \"Specify the method for syncing with this EnderChest.\"\n                    \"\\nSupported protocols are: \" + \", \".join(sync.SUPPORTED_PROTOCOLS)\n                ),\n                suggestion=sync.DEFAULT_PROTOCOL,\n            ).lower()\n            or sync.DEFAULT_PROTOCOL\n        )\n\n        if protocol not in sync.SUPPORTED_PROTOCOLS:\n            CRAFT_LOGGER.error(\"Unsupported protocol\\n\")\n            continue\n        break\n\n    while True:\n        default_netloc = sync.get_default_netloc()\n        netloc = (\n            prompt(\n                (\n                    \"What's the address for accessing this machine?\"\n                    \"\\n(hostname or IP address, plus often a username)\"\n                ),\n                suggestion=default_netloc,\n            )\n            or default_netloc\n        )\n\n        uri = ParseResult(\n            scheme=protocol,\n            netloc=netloc,\n            path=minecraft_root.as_posix(),\n            params=\"\",\n            query=\"\",\n            fragment=\"\",\n        )\n        if not uri.hostname:\n            CRAFT_LOGGER.error(\"Invalid hostname\")\n            continue\n        break\n\n    while True:\n        name = (\n            prompt(\"Provide a name for this EnderChest\", suggestion=uri.hostname)\n            or uri.hostname\n        )\n        if name in (alias for _, alias in remotes):\n            CRAFT_LOGGER.error(\n                f\"The name {name} is already in use. Choose a different name.\"\n            )\n            continue\n        break\n\n    ender_chest = EnderChest(uri, name, remotes, instances)\n\n    CRAFT_LOGGER.info(\n        \"\\n\"\n        + ender_chest.write_to_cfg()\n        + \"\\nPreparing to generate an EnderChest with the above configuration.\"\n    )\n\n    if not confirm(default=True):\n        raise RuntimeError(\"EnderChest creation aborted.\")\n\n    return ender_chest\n</code></pre>"},{"location":"reference/enderchest/craft/#enderchest.craft.specify_shulker_box_from_prompt","title":"<code>specify_shulker_box_from_prompt(minecraft_root, name)</code>","text":"<p>Parse a shulker box based on interactive user input</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>name</code> <code>str</code> <p>The name to give to the shulker box</p> required <p>Returns:</p> Type Description <code>ShulkerBox</code> <p>The resulting ShulkerBox</p> Source code in <code>enderchest/craft.py</code> <pre><code>def specify_shulker_box_from_prompt(minecraft_root: Path, name: str) -&gt; ShulkerBox:\n\"\"\"Parse a shulker box based on interactive user input\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    name : str\n        The name to give to the shulker box\n\n    Returns\n    -------\n    ShulkerBox\n        The resulting ShulkerBox\n    \"\"\"\n    shulker_root = fs.shulker_box_root(minecraft_root, name)\n    if shulker_root in shulker_root.parent.glob(\"*\"):\n        if not shulker_root.is_dir():\n            raise FileExistsError(\n                f\"A file named {name} already exists in your EnderChest folder.\"\n            )\n        CRAFT_LOGGER.warning(\n            f\"There is already a folder named {name} in your EnderChest folder.\"\n        )\n        if not confirm(default=False):\n            raise FileExistsError(\n                f\"There is already a folder named {name} in your EnderChest folder.\"\n            )\n\n    shulker_box = ShulkerBox(0, name, shulker_root, (), ())\n\n    def refresh_ender_chest_instance_list() -&gt; Sequence[InstanceSpec]:\n\"\"\"The primary reason to lambda-fy this is to re-print the instance list.\"\"\"\n        return load_ender_chest_instances(minecraft_root)\n\n    instances = refresh_ender_chest_instance_list()\n\n    explicit_type = \"name\"\n    if len(instances) &gt; 0:\n        explicit_type = \"number\"\n    while True:\n        selection_type = prompt(\n            f\"Would you like to specify instances by [F]ilter or by [N]{explicit_type[1:]}?\"\n        ).lower()\n        match selection_type:\n            case \"f\" | \"filter\":\n                shulker_box = _prompt_for_filters(shulker_box, instances)\n            case \"n\":\n                if explicit_type == \"name\":\n                    shulker_box = _prompt_for_instance_names(shulker_box)\n                else:  # if explicit_type == \"number\"\n                    shulker_box = _prompt_for_instance_numbers(\n                        shulker_box, instances, refresh_ender_chest_instance_list\n                    )\n            case \"name\":\n                # yeah, this is always available\n                shulker_box = _prompt_for_instance_names(shulker_box)\n            case \"number\":\n                if explicit_type == \"name\":\n                    continue\n                shulker_box = _prompt_for_instance_numbers(\n                    shulker_box, instances, refresh_ender_chest_instance_list\n                )\n            case _:\n                continue\n        break\n\n    while True:\n        selection_type = prompt(\n            \"Folders to Link?\"\n            \"\\nUse the [S]tandard set, [M]anually specify or do [N]one?\"\n            \"\\nThe standard set is: \" + \", \".join(STANDARD_LINK_FOLDERS)\n        ).lower()\n        match selection_type:\n            case \"n\" | \"none\":\n                link_folders: tuple[str, ...] = ()\n            case \"s\" | \"standard\" | \"standard set\":\n                link_folders = STANDARD_LINK_FOLDERS\n            case \"m\" | \"manual\" | \"manually specify\":\n                folder_choices = prompt(\n                    \"Specify the folders to link using a comma-separated list\"\n                    \" (wildcards are not allowed)\"\n                )\n                link_folders = tuple(\n                    folder.strip() for folder in folder_choices.split(\",\")\n                )\n            case _:\n                continue\n        break\n\n    shulker_box = shulker_box._replace(link_folders=link_folders)\n\n    while True:\n        _ = load_shulker_boxes(minecraft_root)  # to display some log messages\n        value = (\n            prompt(\n                (\n                    \"What priority value should be assigned to this shulker box?\"\n                    \"\\nhigher number = applied later\"\n                ),\n                suggestion=\"0\",\n            )\n            or \"0\"\n        )\n        try:\n            priority = int(value)\n        except ValueError:\n            continue\n        break\n\n    _ = load_ender_chest_remotes(minecraft_root)  # to display some log messages\n    values = (\n        prompt(\n            (\n                \"What hosts (EnderChest installations) should use this shulker box?\"\n                \"\\nProvide a comma-separated list (wildcards are allowed)\"\n                \"\\nand remember to include the name of this EnderChest\"\n                f'(\"{load_ender_chest(minecraft_root).name}\")'\n            ),\n            suggestion=\"*\",\n        )\n        or \"*\"\n    )\n    shulker_box._replace(\n        match_criteria=shulker_box.match_criteria\n        + ((\"hosts\", tuple(host.strip() for host in values.split(\",\"))),)\n    )\n\n    shulker_box = shulker_box._replace(priority=priority)\n\n    CRAFT_LOGGER.info(\n        \"\\n\"\n        + shulker_box.write_to_cfg()\n        + \"Preparing to generate a shulker box with the above configuration.\"\n    )\n\n    if not confirm(default=True):\n        raise RuntimeError(\"Shulker box creation aborted.\")\n\n    return shulker_box\n</code></pre>"},{"location":"reference/enderchest/enderchest/","title":"enderchest","text":"<p>Specification and configuration of an EnderChest</p>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.EnderChest","title":"<code>EnderChest</code>  <code>dataclass</code>","text":"<p>Configuration of an EnderChest</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>URI or Path</code> <p>The \"address\" of this EnderChest, ideally as it can be accessed from other EnderChest installations, including both the path to where the EnderChest folder can be found (that is, the parent of the EnderChest folder itself, aka the \"minecraft_root\"), its net location including credentials, and the protocol that should be used to perform the syncing. All that being said, if just a path is provided, the constructor will try to figure out the rest.</p> required <code>name</code> <code>str, optional</code> <p>A unique name to give to this EnderChest installation. If None is provided, this will be taken from the hostname of the supplied URI.</p> <code>None</code> <code>instances</code> <code>list-like of InstanceSpec, optional</code> <p>The list of instances to register with this EnderChest installation</p> <code>None</code> <code>remotes</code> <code>list-like of URI, or (URI, str) tuples</code> <p>A list of other installations that this EnderChest should be aware of (for syncing purposes). When a (URI, str) tuple is provided, the second value will be used as the name/alias of the remote.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The unique name of this EnderChest installation. This is most commonly the computer's hostname, but one can configure multiple EnderChests to coexist on the same system (either for the sake of having a \"cold\" backup or for multi-user systems).</p> <code>uri</code> <code>str</code> <p>The complete URI of this instance</p> <code>root</code> <code>Path</code> <p>The path to this EnderChest folder</p> <code>instances</code> <code>list-like of InstanceSpec</code> <p>The instances registered with this EnderChest</p> <code>remotes</code> <code>list-like of (ParseResult, str) pairs</code> <p>The other EnderChest installations this EnderChest is aware of, paired with their aliases</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>@dataclass(init=False, repr=False)\nclass EnderChest:\n\"\"\"Configuration of an EnderChest\n\n    Parameters\n    ----------\n    uri : URI or Path\n        The \"address\" of this EnderChest, ideally as it can be accessed from other\n        EnderChest installations, including both the path to where\n        the EnderChest folder can be found (that is, the parent of the\n        EnderChest folder itself, aka the \"minecraft_root\"), its net location\n        including credentials, and the protocol that should be used to perform\n        the syncing. All that being said, if just a path is provided, the\n        constructor will try to figure out the rest.\n    name : str, optional\n        A unique name to give to this EnderChest installation. If None is\n        provided, this will be taken from the hostname of the supplied URI.\n    instances : list-like of InstanceSpec, optional\n        The list of instances to register with this EnderChest installation\n    remotes : list-like of URI, or (URI, str) tuples\n        A list of other installations that this EnderChest should be aware of\n        (for syncing purposes). When a (URI, str) tuple is provided, the\n        second value will be used as the name/alias of the remote.\n\n    Attributes\n    ----------\n    name : str\n        The unique name of this EnderChest installation. This is most commonly\n        the computer's hostname, but one can configure multiple EnderChests\n        to coexist on the same system (either for the sake of having a \"cold\"\n        backup or for multi-user systems).\n    uri : str\n        The complete URI of this instance\n    root : Path\n        The path to this EnderChest folder\n    instances : list-like of InstanceSpec\n        The instances registered with this EnderChest\n    remotes : list-like of (ParseResult, str) pairs\n        The other EnderChest installations this EnderChest is aware of, paired\n        with their aliases\n    \"\"\"\n\n    name: str\n    _uri: ParseResult\n    _instances: list[i.InstanceSpec]\n\n    _remotes: dict[str, ParseResult]\n\n    def __init__(\n        self,\n        uri: str | ParseResult | Path,\n        name: str | None = None,\n        remotes: Iterable[str | ParseResult | tuple[str, str] | tuple[ParseResult, str]]\n        | None = None,\n        instances: Iterable[i.InstanceSpec] | None = None,\n    ):\n        try:\n            if isinstance(uri, ParseResult):\n                self._uri = uri\n            elif isinstance(uri, Path):\n                self._uri = urlparse(uri.absolute().as_uri())\n            else:\n                self._uri = urlparse(uri)\n        except AttributeError as parse_problem:\n            raise ValueError(f\"{uri} is not a valid URI\") from parse_problem\n\n        if not self._uri.netloc:\n            self._uri = self._uri._replace(netloc=sync.get_default_netloc())\n        if not self._uri.scheme:\n            self._uri = self._uri._replace(scheme=sync.DEFAULT_PROTOCOL)\n\n        self.name = name or self._uri.hostname or gethostname()\n\n        self._instances = []\n        self._remotes = {}\n\n        for instance in instances or ():\n            self.register_instance(instance)\n\n        for remote in remotes or ():\n            if isinstance(remote, (str, ParseResult)):\n                self.register_remote(remote)\n            else:\n                self.register_remote(*remote)\n\n    @property\n    def uri(self) -&gt; str:\n        return self._uri.geturl()\n\n    def __repr__(self) -&gt; str:\n        return f\"EnderChest({self.uri, self.name})\"\n\n    @property\n    def root(self) -&gt; Path:\n        return fs.ender_chest_folder(Path(self._uri.path))\n\n    @property\n    def instances(self) -&gt; tuple[i.InstanceSpec, ...]:\n        return tuple(self._instances)\n\n    def register_instance(self, instance: i.InstanceSpec) -&gt; i.InstanceSpec:\n\"\"\"Register a new Minecraft installation\n\n        Parameters\n        ----------\n        instance : InstanceSpec\n            The instance to register\n\n        Returns\n        -------\n        InstanceSpec\n            The spec of the instance as it was actually registered (in case the\n            name changed or somesuch)\n\n        Notes\n        -----\n        - If the instance's name is already assigned to a registered instance,\n          this method will choose a new one\n        - If this instance shares a path with an existing instance, it will\n          replace that instance\n        \"\"\"\n        self._instances = [\n            old_instance\n            for old_instance in self._instances\n            if not i.equals(Path(self._uri.path), instance, old_instance)\n        ]\n        name = instance.name\n        counter = 0\n        taken_names = {old_instance.name for old_instance in self._instances}\n        while True:\n            if name not in taken_names:\n                break\n            counter += 1\n            name = f\"{instance.name}.{counter}\"\n\n        GATHER_LOGGER.debug(f\"Registering instance {instance.name} at {instance.root}\")\n        self._instances.append(instance._replace(name=name))\n        return self._instances[-1]\n\n    @property\n    def remotes(self) -&gt; tuple[tuple[ParseResult, str], ...]:\n        return tuple((remote, alias) for alias, remote in self._remotes.items())\n\n    def register_remote(\n        self, remote: str | ParseResult, alias: str | None = None\n    ) -&gt; None:\n\"\"\"Register a new remote EnderChest installation (or update an existing\n        registry)\n\n        Parameters\n        ----------\n        remote : URI\n            The URI of the remote\n        alias : str, optional\n            an alias to give to this remote. If None is provided, the URI's hostname\n            will be used.\n\n        Raises\n        ------\n        ValueError\n            If the provided remote is invalid\n        \"\"\"\n        try:\n            remote = remote if isinstance(remote, ParseResult) else urlparse(remote)\n            alias = alias or remote.hostname\n            if not alias:\n                raise AttributeError(f\"{remote.geturl()} has no hostname\")\n            GATHER_LOGGER.debug(f\"Registering remote {remote.geturl()} ({alias})\")\n            self._remotes[alias] = remote\n        except AttributeError as parse_problem:\n            raise ValueError(f\"{remote} is not a valid URI\") from parse_problem\n\n    @classmethod\n    def from_cfg(cls, config_file: Path) -&gt; \"EnderChest\":\n\"\"\"Parse an EnderChest from its config file\n\n        Parameters\n        ----------\n        config_file : Path\n            The path to the config file\n\n        Returns\n        -------\n        EnderChest\n            The resulting EnderChest\n\n        Raises\n        ------\n        ValueError\n            If the config file at that location cannot be parsed\n        FileNotFoundError\n            If there is no config file at the specified location\n        \"\"\"\n        parser = ConfigParser(\n            allow_no_value=True, delimiters=(\"=\",), inline_comment_prefixes=(\";\",)\n        )\n        try:\n            assert parser.read(config_file)\n        except ParsingError as bad_cfg:\n            raise ValueError(f\"Could not parse {config_file}\") from bad_cfg\n        except AssertionError:\n            raise FileNotFoundError(f\"Could not open {config_file}\")\n\n        # All I'm gonna say is that Windows pathing is the worst\n        path = urlparse(config_file.absolute().parent.parent.as_uri()).path\n\n        instances: list[i.InstanceSpec] = []\n        remotes: list[str | tuple[str, str]] = []\n\n        scheme: str | None = None\n        netloc: str | None = None\n        name: str | None = None\n\n        for section in parser.sections():\n            if section == \"properties\":\n                scheme = parser[section].get(\"sync-protocol\")\n                netloc = parser[section].get(\"address\")\n                name = parser[section].get(\"name\")\n            elif section == \"remotes\":\n                for remote in parser[section].items():\n                    if remote[1] is None:\n                        remotes.append(remote[0])\n                    else:\n                        remotes.append((remote[1], remote[0]))\n            else:\n                instances.append(i.InstanceSpec.from_cfg(parser[section]))\n\n        scheme = scheme or sync.DEFAULT_PROTOCOL\n        netloc = netloc or sync.get_default_netloc()\n        uri = ParseResult(\n            scheme=scheme, netloc=netloc, path=path, params=\"\", query=\"\", fragment=\"\"\n        )\n\n        return EnderChest(uri, name, remotes, instances)\n\n    def write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n\"\"\"Write this EnderChest's configuration to INI\n\n        Parameters\n        ----------\n        config_file : Path, optional\n            The path to the config file, assuming you'd like to write the\n            contents to file\n\n        Returns\n        -------\n        str\n            An INI-syntax rendering of this EnderChest's config\n\n        Notes\n        -----\n        The \"root\" attribute is ignored for this method\n        \"\"\"\n        config = ConfigParser(allow_no_value=True)\n        config.add_section(\"properties\")\n        config.set(\"properties\", \"name\", self.name)\n        config.set(\"properties\", \"address\", self._uri.netloc)\n        config.set(\"properties\", \"sync-protocol\", self._uri.scheme)\n        config.set(\"properties\", \"last_modified\", dt.datetime.now().isoformat(sep=\" \"))\n        config.set(\n            \"properties\", \"generated_by_enderchest_version\", get_versions()[\"version\"]\n        )\n\n        config.add_section(\"remotes\")\n        for uri, name in self.remotes:\n            if name != uri.hostname:\n                config.set(\"remotes\", name, uri.geturl())\n            else:\n                config.set(\"remotes\", uri.geturl())\n        for instance in self.instances:\n            config.add_section(instance.name)\n            config.set(instance.name, \"root\", str(instance.root))\n            config.set(\n                instance.name,\n                \"minecraft_version\",\n                _list_to_ini(instance.minecraft_versions),\n            )\n            config.set(instance.name, \"modloader\", instance.modloader)\n            config.set(\n                instance.name,\n                \"tags\",\n                _list_to_ini(instance.tags),\n            )\n\n        buffer = StringIO()\n        buffer.write(f\"; {fs.ENDER_CHEST_CONFIG_NAME}\\n\")\n        config.write(buffer)\n        buffer.seek(0)  # rewind\n\n        if config_file:\n            config_file.write_text(buffer.read())\n            buffer.seek(0)\n        return buffer.read()\n</code></pre>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.EnderChest.from_cfg","title":"<code>from_cfg(config_file)</code>  <code>classmethod</code>","text":"<p>Parse an EnderChest from its config file</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path</code> <p>The path to the config file</p> required <p>Returns:</p> Type Description <code>EnderChest</code> <p>The resulting EnderChest</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the config file at that location cannot be parsed</p> <code>FileNotFoundError</code> <p>If there is no config file at the specified location</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>@classmethod\ndef from_cfg(cls, config_file: Path) -&gt; \"EnderChest\":\n\"\"\"Parse an EnderChest from its config file\n\n    Parameters\n    ----------\n    config_file : Path\n        The path to the config file\n\n    Returns\n    -------\n    EnderChest\n        The resulting EnderChest\n\n    Raises\n    ------\n    ValueError\n        If the config file at that location cannot be parsed\n    FileNotFoundError\n        If there is no config file at the specified location\n    \"\"\"\n    parser = ConfigParser(\n        allow_no_value=True, delimiters=(\"=\",), inline_comment_prefixes=(\";\",)\n    )\n    try:\n        assert parser.read(config_file)\n    except ParsingError as bad_cfg:\n        raise ValueError(f\"Could not parse {config_file}\") from bad_cfg\n    except AssertionError:\n        raise FileNotFoundError(f\"Could not open {config_file}\")\n\n    # All I'm gonna say is that Windows pathing is the worst\n    path = urlparse(config_file.absolute().parent.parent.as_uri()).path\n\n    instances: list[i.InstanceSpec] = []\n    remotes: list[str | tuple[str, str]] = []\n\n    scheme: str | None = None\n    netloc: str | None = None\n    name: str | None = None\n\n    for section in parser.sections():\n        if section == \"properties\":\n            scheme = parser[section].get(\"sync-protocol\")\n            netloc = parser[section].get(\"address\")\n            name = parser[section].get(\"name\")\n        elif section == \"remotes\":\n            for remote in parser[section].items():\n                if remote[1] is None:\n                    remotes.append(remote[0])\n                else:\n                    remotes.append((remote[1], remote[0]))\n        else:\n            instances.append(i.InstanceSpec.from_cfg(parser[section]))\n\n    scheme = scheme or sync.DEFAULT_PROTOCOL\n    netloc = netloc or sync.get_default_netloc()\n    uri = ParseResult(\n        scheme=scheme, netloc=netloc, path=path, params=\"\", query=\"\", fragment=\"\"\n    )\n\n    return EnderChest(uri, name, remotes, instances)\n</code></pre>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.EnderChest.register_instance","title":"<code>register_instance(instance)</code>","text":"<p>Register a new Minecraft installation</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>InstanceSpec</code> <p>The instance to register</p> required <p>Returns:</p> Type Description <code>InstanceSpec</code> <p>The spec of the instance as it was actually registered (in case the name changed or somesuch)</p>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.EnderChest.register_instance--notes","title":"Notes","text":"<ul> <li>If the instance's name is already assigned to a registered instance,   this method will choose a new one</li> <li>If this instance shares a path with an existing instance, it will   replace that instance</li> </ul> Source code in <code>enderchest/enderchest.py</code> <pre><code>def register_instance(self, instance: i.InstanceSpec) -&gt; i.InstanceSpec:\n\"\"\"Register a new Minecraft installation\n\n    Parameters\n    ----------\n    instance : InstanceSpec\n        The instance to register\n\n    Returns\n    -------\n    InstanceSpec\n        The spec of the instance as it was actually registered (in case the\n        name changed or somesuch)\n\n    Notes\n    -----\n    - If the instance's name is already assigned to a registered instance,\n      this method will choose a new one\n    - If this instance shares a path with an existing instance, it will\n      replace that instance\n    \"\"\"\n    self._instances = [\n        old_instance\n        for old_instance in self._instances\n        if not i.equals(Path(self._uri.path), instance, old_instance)\n    ]\n    name = instance.name\n    counter = 0\n    taken_names = {old_instance.name for old_instance in self._instances}\n    while True:\n        if name not in taken_names:\n            break\n        counter += 1\n        name = f\"{instance.name}.{counter}\"\n\n    GATHER_LOGGER.debug(f\"Registering instance {instance.name} at {instance.root}\")\n    self._instances.append(instance._replace(name=name))\n    return self._instances[-1]\n</code></pre>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.EnderChest.register_remote","title":"<code>register_remote(remote, alias=None)</code>","text":"<p>Register a new remote EnderChest installation (or update an existing registry)</p> <p>Parameters:</p> Name Type Description Default <code>remote</code> <code>URI</code> <p>The URI of the remote</p> required <code>alias</code> <code>str, optional</code> <p>an alias to give to this remote. If None is provided, the URI's hostname will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided remote is invalid</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>def register_remote(\n    self, remote: str | ParseResult, alias: str | None = None\n) -&gt; None:\n\"\"\"Register a new remote EnderChest installation (or update an existing\n    registry)\n\n    Parameters\n    ----------\n    remote : URI\n        The URI of the remote\n    alias : str, optional\n        an alias to give to this remote. If None is provided, the URI's hostname\n        will be used.\n\n    Raises\n    ------\n    ValueError\n        If the provided remote is invalid\n    \"\"\"\n    try:\n        remote = remote if isinstance(remote, ParseResult) else urlparse(remote)\n        alias = alias or remote.hostname\n        if not alias:\n            raise AttributeError(f\"{remote.geturl()} has no hostname\")\n        GATHER_LOGGER.debug(f\"Registering remote {remote.geturl()} ({alias})\")\n        self._remotes[alias] = remote\n    except AttributeError as parse_problem:\n        raise ValueError(f\"{remote} is not a valid URI\") from parse_problem\n</code></pre>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.EnderChest.write_to_cfg","title":"<code>write_to_cfg(config_file=None)</code>","text":"<p>Write this EnderChest's configuration to INI</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path, optional</code> <p>The path to the config file, assuming you'd like to write the contents to file</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>An INI-syntax rendering of this EnderChest's config</p>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.EnderChest.write_to_cfg--notes","title":"Notes","text":"<p>The \"root\" attribute is ignored for this method</p> Source code in <code>enderchest/enderchest.py</code> <pre><code>def write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n\"\"\"Write this EnderChest's configuration to INI\n\n    Parameters\n    ----------\n    config_file : Path, optional\n        The path to the config file, assuming you'd like to write the\n        contents to file\n\n    Returns\n    -------\n    str\n        An INI-syntax rendering of this EnderChest's config\n\n    Notes\n    -----\n    The \"root\" attribute is ignored for this method\n    \"\"\"\n    config = ConfigParser(allow_no_value=True)\n    config.add_section(\"properties\")\n    config.set(\"properties\", \"name\", self.name)\n    config.set(\"properties\", \"address\", self._uri.netloc)\n    config.set(\"properties\", \"sync-protocol\", self._uri.scheme)\n    config.set(\"properties\", \"last_modified\", dt.datetime.now().isoformat(sep=\" \"))\n    config.set(\n        \"properties\", \"generated_by_enderchest_version\", get_versions()[\"version\"]\n    )\n\n    config.add_section(\"remotes\")\n    for uri, name in self.remotes:\n        if name != uri.hostname:\n            config.set(\"remotes\", name, uri.geturl())\n        else:\n            config.set(\"remotes\", uri.geturl())\n    for instance in self.instances:\n        config.add_section(instance.name)\n        config.set(instance.name, \"root\", str(instance.root))\n        config.set(\n            instance.name,\n            \"minecraft_version\",\n            _list_to_ini(instance.minecraft_versions),\n        )\n        config.set(instance.name, \"modloader\", instance.modloader)\n        config.set(\n            instance.name,\n            \"tags\",\n            _list_to_ini(instance.tags),\n        )\n\n    buffer = StringIO()\n    buffer.write(f\"; {fs.ENDER_CHEST_CONFIG_NAME}\\n\")\n    config.write(buffer)\n    buffer.seek(0)  # rewind\n\n    if config_file:\n        config_file.write_text(buffer.read())\n        buffer.seek(0)\n    return buffer.read()\n</code></pre>"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.create_ender_chest","title":"<code>create_ender_chest(minecraft_root, ender_chest)</code>","text":"<p>Create an EnderChest based on the provided configuration</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff is in (or, at least, the one inside which you want to create your EnderChest)</p> required <code>ender_chest</code> <code>EnderChest</code> <p>The spec of the chest to create</p> required"},{"location":"reference/enderchest/enderchest/#enderchest.enderchest.create_ender_chest--notes","title":"Notes","text":"<ul> <li>The \"root\" attribute of the EnderChest config will be ignored--instead   the EnderChest will be created at /EnderChest <li>This method does not check to see if there is already an EnderChest set   up at the specified location--if one exists, its config will   be overwritten</li> Source code in <code>enderchest/enderchest.py</code> <pre><code>def create_ender_chest(minecraft_root: Path, ender_chest: EnderChest) -&gt; None:\n\"\"\"Create an EnderChest based on the provided configuration\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff is in (or, at least, the\n        one inside which you want to create your EnderChest)\n    ender_chest : EnderChest\n        The spec of the chest to create\n\n    Notes\n    -----\n    - The \"root\" attribute of the EnderChest config will be ignored--instead\n      the EnderChest will be created at &lt;minecraft_root&gt;/EnderChest\n    - This method does not check to see if there is already an EnderChest set\n      up at the specified location--if one exists, its config will\n      be overwritten\n    \"\"\"\n    root = fs.ender_chest_folder(minecraft_root, check_exists=False)\n    root.mkdir(exist_ok=True)\n\n    config_path = fs.ender_chest_config(minecraft_root, check_exists=False)\n    ender_chest.write_to_cfg(config_path)\n    CRAFT_LOGGER.info(f\"EnderChest configuration written to {config_path}\")\n</code></pre>"},{"location":"reference/enderchest/filesystem/","title":"filesystem","text":"<p>Functionality for managing the EnderChest and shulker box config files and folders</p>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.ender_chest_config","title":"<code>ender_chest_config(minecraft_root, check_exists=True)</code>","text":"<p>Given a minecraft root directory, return the path to the EnderChest config file</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>check_exists</code> <code>bool, optional</code> <p>By default, this method will raise an error if the enderchest config file does not already exist. To disable that check, call this method with <code>check_exists=False</code></p> <code>True</code> <p>Returns:</p> Type Description <code>Path</code> <p>The path to the EnderChest config file</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the EnderChest config file isn't where it's supposed to be (and checking hasn't been disabled)</p>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.ender_chest_config--notes","title":"Notes","text":"<p>This method does not check if the config file is valid</p> Source code in <code>enderchest/filesystem.py</code> <pre><code>def ender_chest_config(minecraft_root, check_exists: bool = True) -&gt; Path:\n\"\"\"Given a minecraft root directory, return the path to the EnderChest\n    config file\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    check_exists : bool, optional\n        By default, this method will raise an error if the enderchest config\n        file does not already exist. To disable that check, call this method\n        with `check_exists=False`\n\n    Returns\n    -------\n    Path\n        The path to the EnderChest config file\n\n    Raises\n    ------\n    FileNotFoundError\n        If the EnderChest config file isn't where it's supposed to be (and\n        checking hasn't been disabled)\n\n    Notes\n    -----\n    This method does not check if the config file is valid\n    \"\"\"\n    config_path = minecraft_root / ENDER_CHEST_FOLDER_NAME / ENDER_CHEST_CONFIG_NAME\n\n    if check_exists and not config_path.exists():\n        raise FileNotFoundError(\n            f\"No valid EnderChest installation exists within {minecraft_root}\"\n        )\n    return config_path\n</code></pre>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.ender_chest_folder","title":"<code>ender_chest_folder(minecraft_root, check_exists=True)</code>","text":"<p>Given a minecraft root directory, return the path to the EnderChest folder</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>check_exists</code> <code>bool, optional</code> <p>By default, this method will raise an error if no EnderChest exists at that location (meaning no folder or no enderchest config file in that folder). To disable that check, call this method with <code>check_exists=False</code></p> <code>True</code> <p>Returns:</p> Type Description <code>Path</code> <p>The path to the EnderChest folder</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If no valid EnderChest installation exists within the given minecraft root (and checking hasn't been disabled)</p> Source code in <code>enderchest/filesystem.py</code> <pre><code>def ender_chest_folder(minecraft_root: Path, check_exists: bool = True) -&gt; Path:\n\"\"\"Given a minecraft root directory, return the path to the EnderChest\n    folder\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    check_exists : bool, optional\n        By default, this method will raise an error if no EnderChest exists\n        at that location (meaning no folder or no enderchest config file in\n        that folder). To disable that check, call this method with\n        `check_exists=False`\n\n    Returns\n    -------\n    Path\n        The path to the EnderChest folder\n\n    Raises\n    ------\n    FileNotFoundError\n        If no valid EnderChest installation exists within the given\n        minecraft root (and checking hasn't been disabled)\n    \"\"\"\n    return ender_chest_config(minecraft_root, check_exists=check_exists).parent\n</code></pre>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.minecraft_folders","title":"<code>minecraft_folders(search_path)</code>","text":"<p>Find all .minecraft folders within a given search path</p> <p>Parameters:</p> Name Type Description Default <code>search_path</code> <code>Path</code> <p>The directory to search</p> required <p>Returns:</p> Type Description <code>list-like of paths</code> <p>The paths to all the .minecraft folders this method could find</p>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.minecraft_folders--notes","title":"Notes","text":"<p>This method does not check to make sure that those .minecraft folders contain valid minecraft instances, just that they exist</p> Source code in <code>enderchest/filesystem.py</code> <pre><code>def minecraft_folders(search_path: Path) -&gt; Iterable[Path]:\n\"\"\"Find all .minecraft folders within a given search path\n\n    Parameters\n    ----------\n    search_path : Path\n        The directory to search\n\n    Returns\n    -------\n    list-like of paths\n        The paths to all the .minecraft folders this method could find\n\n    Notes\n    -----\n    This method does not check to make sure that those .minecraft folders\n    contain valid minecraft instances, just that they exist\n    \"\"\"\n    return search_path.rglob(\".minecraft\")\n</code></pre>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.shulker_box_config","title":"<code>shulker_box_config(minecraft_root, shulker_box_name)</code>","text":"<p>Generate the path to a shulker box config file, given its name and the minecraft root directory</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The path to the shulker box folder</p>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.shulker_box_config--notes","title":"Notes","text":"<p>This method does not check a shulker box config exists at that location</p> Source code in <code>enderchest/filesystem.py</code> <pre><code>def shulker_box_config(minecraft_root: Path, shulker_box_name: str) -&gt; Path:\n\"\"\"Generate the path to a shulker box config file, given its name and\n    the minecraft root directory\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n\n    Returns\n    -------\n    Path\n        The path to the shulker box folder\n\n    Notes\n    -----\n    This method does not check a shulker box config exists at that location\n    \"\"\"\n    return shulker_box_root(minecraft_root, shulker_box_name) / SHULKER_BOX_CONFIG_NAME\n</code></pre>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.shulker_box_configs","title":"<code>shulker_box_configs(minecraft_root)</code>","text":"<p>Find all shulker box configs on the system</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <p>Returns:</p> Type Description <code>list-like of paths</code> <p>The paths to all the shulker box configs on the system</p>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.shulker_box_configs--notes","title":"Notes","text":"<p>This method does not check to make sure those config files are valid, just that they exist</p> Source code in <code>enderchest/filesystem.py</code> <pre><code>def shulker_box_configs(minecraft_root: Path) -&gt; Iterable[Path]:\n\"\"\"Find all shulker box configs on the system\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n\n    Returns\n    -------\n    list-like of paths\n        The paths to all the shulker box configs on the system\n\n    Notes\n    -----\n    This method does not check to make sure those config files are valid,\n    just that they exist\n    \"\"\"\n    GATHER_LOGGER.debug(f\"Searching for shulker configs within {minecraft_root}\")\n    return ender_chest_folder(minecraft_root).glob(f\"*/{SHULKER_BOX_CONFIG_NAME}\")\n</code></pre>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.shulker_box_root","title":"<code>shulker_box_root(minecraft_root, shulker_box_name)</code>","text":"<p>Generate the path to the root of a shulker box, given its name and the minecraft root directory</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The path to the shulker box folder</p>"},{"location":"reference/enderchest/filesystem/#enderchest.filesystem.shulker_box_root--notes","title":"Notes","text":"<p>This method does not check a shulker box exists at that location</p> Source code in <code>enderchest/filesystem.py</code> <pre><code>def shulker_box_root(minecraft_root: Path, shulker_box_name: str) -&gt; Path:\n\"\"\"Generate the path to the root of a shulker box, given its name and the\n    minecraft root directory\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n\n    Returns\n    -------\n    Path\n        The path to the shulker box folder\n\n    Notes\n    -----\n    This method does not check a shulker box exists at that location\n    \"\"\"\n    return ender_chest_folder(minecraft_root) / shulker_box_name\n</code></pre>"},{"location":"reference/enderchest/gather/","title":"gather","text":"<p>Functionality for finding, resolving and parsing local installations and instances</p>"},{"location":"reference/enderchest/gather/#enderchest.gather.gather_metadata_for_mmc_instance","title":"<code>gather_metadata_for_mmc_instance(minecraft_folder, instgroups_file=None)</code>","text":"<p>Parse files to generate metadata for a MultiMC-like instance</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_folder</code> <code>Path</code> <p>The path to the installation's .minecraft folder</p> required <code>instgroups_file</code> <code>Path</code> <p>The path to instgroups.json. If None is provided, this method will look for it two directories up from the minecraft folder</p> <code>None</code> <p>Returns:</p> Type Description <code>InstanceSpec</code> <p>The metadata for this instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If this is not a valid MMC-like Minecraft instance</p>"},{"location":"reference/enderchest/gather/#enderchest.gather.gather_metadata_for_mmc_instance--notes","title":"Notes","text":"<p>If this method is failing to find the appropriate files, you may want to try ensuring that minecraft_folder is an absolute path.</p> Source code in <code>enderchest/gather.py</code> <pre><code>def gather_metadata_for_mmc_instance(\n    minecraft_folder: Path, instgroups_file: Path | None = None\n) -&gt; InstanceSpec:\n\"\"\"Parse files to generate metadata for a MultiMC-like instance\n\n    Parameters\n    ----------\n    minecraft_folder : Path\n        The path to the installation's .minecraft folder\n    instgroups_file : Path\n        The path to instgroups.json. If None is provided, this method will\n        look for it two directories up from the minecraft folder\n\n    Returns\n    -------\n    InstanceSpec\n        The metadata for this instance\n\n    Raises\n    ------\n    ValueError\n        If this is not a valid MMC-like Minecraft instance\n\n    Notes\n    -----\n    If this method is failing to find the appropriate files, you may want\n    to try ensuring that minecraft_folder is an absolute path.\n    \"\"\"\n    mmc_pack_file = minecraft_folder.parent / \"mmc-pack.json\"\n    try:\n        with mmc_pack_file.open() as mmc_json:\n            components: list[dict] = json.load(mmc_json)[\"components\"]\n\n        version: str | None = None\n        modloader: str | None = None\n\n        for component in components:\n            match component.get(\"uid\"), component.get(\"cachedName\", \"\"):\n                case \"net.minecraft\", _:\n                    version = component[\"version\"]\n                case \"net.fabricmc.fabric-loader\", _:\n                    modloader = \"Fabric Loader\"\n                case \"org.quiltmc.quilt-loader\", _:\n                    modloader = \"Quilt Loader\"\n                case (\"net.minecraftforge\", _) | (_, \"Forge\"):\n                    modloader = \"Forge\"\n                case _, name if name.endswith(\"oader\"):\n                    modloader = name\n                case _:\n                    continue\n        if version is None:\n            raise KeyError(\"Could not find a net.minecraft component\")\n    except FileNotFoundError as no_json:\n        raise ValueError(f\"Could not find {mmc_pack_file}\") from no_json\n    except json.JSONDecodeError as bad_json:\n        raise ValueError(\n            f\"{mmc_pack_file} is corrupt and could not be parsed\"\n        ) from bad_json\n    except KeyError as weird_json:\n        raise ValueError(\n            f\"Could not parse metadata from {mmc_pack_file}\"\n        ) from weird_json\n\n    name = minecraft_folder.parent.name\n\n    tags: list[str] = []\n\n    if name == \"\":\n        GATHER_LOGGER.warn(\n            \"Could not resolve the name of the parent folder\"\n            \" and thus could not load tags.\"\n        )\n    else:\n        instgroups_file = (\n            instgroups_file or minecraft_folder.parent.parent / \"instgroups.json\"\n        )\n\n        try:\n            with instgroups_file.open() as groups_json:\n                groups: dict[str, dict] = json.load(groups_json)[\"groups\"]\n            for tag, metadata in groups.items():\n                # interestingly this comes from the folder name, not the actual name\n                if name in metadata.get(\"instances\", ()):\n                    tags.append(tag)\n\n        except FileNotFoundError as no_json:\n            GATHER_LOGGER.warn(\n                f\"Could not find {instgroups_file} and thus could not load tags\"\n            )\n        except json.JSONDecodeError as bad_json:\n            GATHER_LOGGER.warn(\n                f\"{instgroups_file} is corrupt and could not be parsed for tags\"\n            )\n        except KeyError as weird_json:\n            GATHER_LOGGER.warn(f\"Could not parse tags from {instgroups_file}\")\n\n    instance_cfg = minecraft_folder.parent / \"instance.cfg\"\n\n    try:\n        parser = ConfigParser(allow_no_value=True)\n        parser.read_string(\"[instance]\\n\" + instance_cfg.read_text())\n        name = parser[\"instance\"][\"name\"]\n    except FileNotFoundError as no_cfg:\n        GATHER_LOGGER.warn(\n            f\"Could not find {instance_cfg} and thus could not load the instance name\"\n        )\n    except ParsingError as no_cfg:\n        GATHER_LOGGER.warn(\n            f\"{instance_cfg} is corrupt and could not be parsed the instance name\"\n        )\n    except KeyError as weird_json:\n        GATHER_LOGGER.warn(f\"Could not parse instance name from {instance_cfg}\")\n\n    if name == \"\":\n        raise ValueError(\"Could not determine the name of the instance.\")\n\n    return InstanceSpec(name, minecraft_folder, (version,), modloader, tuple(tags))\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.gather_metadata_for_official_instance","title":"<code>gather_metadata_for_official_instance(minecraft_folder, name='official')</code>","text":"<p>Parse files to generate metadata for an official Minecraft installation</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_folder</code> <code>Path</code> <p>The path to the installation's .minecraft folder</p> required <code>name</code> <code>str, optional</code> <p>A name or alias to give to the instance. If None is provided, the default name is \"official\"</p> <code>'official'</code> <p>Returns:</p> Type Description <code>InstanceSpec</code> <p>The metadata for this instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If this is not a valid official Minecraft installation</p>"},{"location":"reference/enderchest/gather/#enderchest.gather.gather_metadata_for_official_instance--notes","title":"Notes","text":"<p>This method will always consider this instance to be vanilla, with no modloader. If a Forge or Fabric executable is installed inside this instance, the precise name of that version of that modded minecraft will be included in the version list.</p> Source code in <code>enderchest/gather.py</code> <pre><code>def gather_metadata_for_official_instance(\n    minecraft_folder: Path, name: str = \"official\"\n) -&gt; InstanceSpec:\n\"\"\"Parse files to generate metadata for an official Minecraft installation\n\n    Parameters\n    ----------\n    minecraft_folder : Path\n        The path to the installation's .minecraft folder\n    name : str, optional\n        A name or alias to give to the instance. If None is provided, the\n        default name is \"official\"\n\n    Returns\n    -------\n    InstanceSpec\n        The metadata for this instance\n\n    Raises\n    ------\n    ValueError\n        If this is not a valid official Minecraft installation\n\n    Notes\n    -----\n    This method will always consider this instance to be vanilla, with no\n    modloader. If a Forge or Fabric executable is installed inside this\n    instance, the precise name of that version of that modded minecraft\n    will be included in the version list.\n    \"\"\"\n    launcher_profile_file = minecraft_folder / \"launcher_profiles.json\"\n    try:\n        with launcher_profile_file.open() as lp_json:\n            launcher_profiles = json.load(lp_json)\n        raw_versions: list[str] = [\n            profile[\"lastVersionId\"]\n            for profile in launcher_profiles[\"profiles\"].values()\n        ]\n    except FileNotFoundError as no_json:\n        raise ValueError(f\"Could not find {launcher_profile_file}\") from no_json\n    except json.JSONDecodeError as bad_json:\n        raise ValueError(\n            f\"{launcher_profile_file} is corrupt and could not be parsed\"\n        ) from bad_json\n    except KeyError as weird_json:\n        raise ValueError(\n            f\"Could not parse metadata from {launcher_profile_file}\"\n        ) from weird_json\n\n    version_manifest_file = minecraft_folder / \"versions\" / \"version_manifest_v2.json\"\n    try:\n        with version_manifest_file.open() as vm_json:\n            version_lookup: dict[str, str] = json.load(vm_json)[\"latest\"]\n    except FileNotFoundError as no_json:\n        raise ValueError(f\"Could not find {version_manifest_file}\") from no_json\n    except json.JSONDecodeError as bad_json:\n        raise ValueError(\n            f\"{version_manifest_file} is corrupt and could not be parsed\"\n        ) from bad_json\n    except KeyError as weird_json:\n        GATHER_LOGGER.warn(\n            f\"{version_manifest_file} has no latest-version lookup.\"\n            \"\\nPlease check the parsed metadata to ensure that it's accurate.\",\n        )\n        version_lookup = {}\n\n    versions: list[str] = []\n    tags: list[str] = [\"vanilla\"]\n    for version in raw_versions:\n        if version.startswith(\"latest-\"):\n            mapped_version = version_lookup.get(version[len(\"latest-\") :])\n            if mapped_version is not None:\n                versions.append(mapped_version)\n                tags.append(version)\n                continue\n        versions.append(version)\n\n    return InstanceSpec(name, minecraft_folder, tuple(versions), None, tuple(tags))\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.gather_minecraft_instances","title":"<code>gather_minecraft_instances(minecraft_root, search_path, official)</code>","text":"<p>Search the specified directory for Minecraft installations and return any that are can be found and parsed</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder). This will be used to construct relative paths.</p> required <code>search_path</code> <code>Path</code> <p>The path to search</p> required <code>official</code> <code>bool or None</code> <p>Whether we expect that the instances found in this location will be: - from the official launcher (official=True) - from a MultiMC-style launcher (official=False) - a mix / unsure (official=None)</p> required <p>Returns:</p> Type Description <code>list of InstanceSpec</code> <p>A list of parsed instances</p>"},{"location":"reference/enderchest/gather/#enderchest.gather.gather_minecraft_instances--notes","title":"Notes","text":"<ul> <li>If a minecraft installation is found but cannot be parsed   (or parsed as specified) this method will report that failure but then   continue on.</li> <li>As a corollary, if no valid Minecraft installations can be found, this   method will return an empty list.</li> </ul> Source code in <code>enderchest/gather.py</code> <pre><code>def gather_minecraft_instances(\n    minecraft_root: Path, search_path: Path, official: bool | None\n) -&gt; list[InstanceSpec]:\n\"\"\"Search the specified directory for Minecraft installations and return\n    any that are can be found and parsed\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder). This will be used to\n        construct relative paths.\n    search_path : Path\n        The path to search\n    official : bool or None\n        Whether we expect that the instances found in this location will be:\n          - from the official launcher (official=True)\n          - from a MultiMC-style launcher (official=False)\n          - a mix / unsure (official=None)\n\n    Returns\n    -------\n    list of InstanceSpec\n        A list of parsed instances\n\n    Notes\n    -----\n    - If a minecraft installation is found but cannot be parsed\n      (or parsed as specified) this method will report that failure but then\n      continue on.\n    - As a corollary, if _no_ valid Minecraft installations can be found, this\n      method will return an empty list.\n    \"\"\"\n    instances: list[InstanceSpec] = []\n    for folder in fs.minecraft_folders(search_path):\n        folder_path = folder.absolute()\n        GATHER_LOGGER.debug(f\"Found minecraft installation at {folder}\")\n        if official is not False:\n            try:\n                instances.append(gather_metadata_for_official_instance(folder_path))\n                GATHER_LOGGER.info(\n                    f\"Gathered official Minecraft installation from {folder}\"\n                )\n                continue\n            except ValueError as not_official:\n                GATHER_LOGGER.log(\n                    logging.DEBUG if official is None else logging.WARNING,\n                    (f\"{folder} is not an official instance:\" f\"\\n{not_official}\",),\n                )\n        if official is not True:\n            try:\n                instances.append(gather_metadata_for_mmc_instance(folder_path))\n                GATHER_LOGGER.info(\n                    f\"Gathered MMC-like Minecraft installation from {folder}\"\n                )\n                continue\n            except ValueError as not_mmc:\n                GATHER_LOGGER.log(\n                    logging.DEBUG if official is None else logging.WARNING,\n                    f\"{folder} is not an MMC-like instance:\\n{not_mmc}\",\n                )\n        GATHER_LOGGER.warning(\n            f\"{folder_path} does not appear to be a valid Minecraft instance\"\n        )\n    for i, mc_instance in enumerate(instances):\n        try:\n            instances[i] = mc_instance._replace(\n                root=mc_instance.root.relative_to(minecraft_root)\n            )\n        except ValueError:\n            # TODO: if not Windows, try making relative to \"~\"\n            pass  # instance isn't inside the minecraft root\n    return instances\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_ender_chest","title":"<code>load_ender_chest(minecraft_root)</code>","text":"<p>Load the configuration from the enderchest.cfg file in the EnderChest folder.</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <p>Returns:</p> Type Description <code>EnderChest</code> <p>The EnderChest configuration</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If no EnderChest folder exists in the given minecraft root or if no enderchest.cfg file exists within that EnderChest folder</p> Source code in <code>enderchest/gather.py</code> <pre><code>def load_ender_chest(minecraft_root: Path) -&gt; EnderChest:\n\"\"\"Load the configuration from the enderchest.cfg file in the EnderChest\n    folder.\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n\n    Returns\n    -------\n    EnderChest\n        The EnderChest configuration\n\n    Raises\n    ------\n    FileNotFoundError\n        If no EnderChest folder exists in the given minecraft root or if no\n        enderchest.cfg file exists within that EnderChest folder\n    \"\"\"\n    config_path = fs.ender_chest_config(minecraft_root)\n    GATHER_LOGGER.debug(f\"Loading {config_path}\")\n    ender_chest = EnderChest.from_cfg(config_path)\n    GATHER_LOGGER.debug(f\"Parsed EnderChest installation from {minecraft_root}\")\n    return ender_chest\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_ender_chest_instances","title":"<code>load_ender_chest_instances(minecraft_root, log_level=logging.INFO)</code>","text":"<p>Get the list of instances registered with the EnderChest located in the minecraft root</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>log_level</code> <code>int, optional</code> <p>By default, this method will report out the minecraft instances it finds at the INFO level. You can optionally pass in a lower (or higher) level if this method is being called from another method where that information is redundant or overly verbose.</p> <code>logging.INFO</code> <p>Returns:</p> Type Description <code>list of InstanceSpec</code> <p>The instances registered with the EnderChest</p>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_ender_chest_instances--notes","title":"Notes","text":"<p>If no EnderChest is installed in the given location, then this will return an empty list rather than failing outright.</p> Source code in <code>enderchest/gather.py</code> <pre><code>def load_ender_chest_instances(\n    minecraft_root: Path, log_level: int = logging.INFO\n) -&gt; Sequence[InstanceSpec]:\n\"\"\"Get the list of instances registered with the EnderChest located in the\n    minecraft root\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    log_level : int, optional\n        By default, this method will report out the minecraft instances it\n        finds at the INFO level. You can optionally pass in a lower (or higher)\n        level if this method is being called from another method where that\n        information is redundant or overly verbose.\n\n    Returns\n    -------\n    list of InstanceSpec\n        The instances registered with the EnderChest\n\n    Notes\n    -----\n    If no EnderChest is installed in the given location, then this will return\n    an empty list rather than failing outright.\n    \"\"\"\n    try:\n        ender_chest = load_ender_chest(minecraft_root)\n        instances: Sequence[InstanceSpec] = ender_chest.instances\n    except (FileNotFoundError, ValueError) as bad_chest:\n        GATHER_LOGGER.error(\n            f\"Could not load EnderChest from {minecraft_root}:\\n  {bad_chest}\"\n        )\n        instances = []\n    if len(instances) == 0:\n        GATHER_LOGGER.warning(\n            f\"There are no instances registered to the {minecraft_root} EnderChest\",\n        )\n    else:\n        GATHER_LOGGER.log(\n            log_level,\n            \"These are the instances that are currently registered\"\n            f\" to the {minecraft_root} EnderChest:\\n\"\n            + \"\\n\".join(\n                [\n                    f\"  {i + 1}. {_render_instance(instance)})\"\n                    for i, instance in enumerate(instances)\n                ]\n            ),\n        )\n    return instances\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_ender_chest_remotes","title":"<code>load_ender_chest_remotes(minecraft_root, log_level=logging.INFO)</code>","text":"<p>Load all remote EnderChest installations registered with this one</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <p>Returns:</p> Name Type Description <code>list of (URI, str) tuples</code> <p>The URIs of the remote EnderChests, paired with their aliases</p> <code>log_level</code> <code>int, optional</code> <p>By default, this method will report out the minecraft instances it finds at the INFO level. You can optionally pass in a lower (or higher) level if this method is being called from another method where that information is redundant or overly verbose.</p>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_ender_chest_remotes--notes","title":"Notes","text":"<p>If no EnderChest is installed in the given location, then this will return an empty list rather than failing outright.</p> Source code in <code>enderchest/gather.py</code> <pre><code>def load_ender_chest_remotes(\n    minecraft_root: Path, log_level: int = logging.INFO\n) -&gt; list[tuple[ParseResult, str]]:\n\"\"\"Load all remote EnderChest installations registered with this one\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n\n    Returns\n    -------\n    list of (URI, str) tuples\n        The URIs of the remote EnderChests, paired with their aliases\n    log_level : int, optional\n        By default, this method will report out the minecraft instances it\n        finds at the INFO level. You can optionally pass in a lower (or higher)\n        level if this method is being called from another method where that\n        information is redundant or overly verbose.\n\n    Notes\n    -----\n    If no EnderChest is installed in the given location, then this will return\n    an empty list rather than failing outright.\n    \"\"\"\n    try:\n        ender_chest = load_ender_chest(minecraft_root)\n        remotes: Sequence[tuple[ParseResult, str]] = ender_chest.remotes\n    except (FileNotFoundError, ValueError) as bad_chest:\n        GATHER_LOGGER.error(\n            f\"Could not load EnderChest from {minecraft_root}:\\n  {bad_chest}\"\n        )\n        remotes = ()\n\n    if len(remotes) == 0:\n        GATHER_LOGGER.warning(\n            f\"There are no remotes registered to the {minecraft_root} EnderChest\"\n        )\n        return []\n\n    report = (\n        \"These are the remote EnderChest installations registered\"\n        f\" to the one installed at {minecraft_root}\"\n    )\n    remote_list: list[tuple[ParseResult, str]] = []\n    for remote, alias in remotes:\n        report += f\"\\n  - {render_remote(alias, remote)}\"\n        remote_list.append((remote, alias))\n    GATHER_LOGGER.log(log_level, report)\n    return remote_list\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_shulker_box_matches","title":"<code>load_shulker_box_matches(minecraft_root, shulker_box_name)</code>","text":"<p>Get the list of registered instances that link to the specified shulker box</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>shulker_box_name</code> <code>str</code> <p>The name of the shulker box you're asking about</p> required <p>Returns:</p> Type Description <code>list of InstanceSpec</code> <p>The instances that are / should be linked to the specified shulker box</p> Source code in <code>enderchest/gather.py</code> <pre><code>def load_shulker_box_matches(\n    minecraft_root: Path, shulker_box_name: str\n) -&gt; Sequence[InstanceSpec]:\n\"\"\"Get the list of registered instances that link to the specified shulker box\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    shulker_box_name : str\n        The name of the shulker box you're asking about\n\n    Returns\n    -------\n    list of InstanceSpec\n        The instances that are / should be linked to the specified shulker box\n    \"\"\"\n    try:\n        config_file = fs.shulker_box_config(minecraft_root, shulker_box_name)\n    except FileNotFoundError:\n        GATHER_LOGGER.error(f\"No EnderChest is installed in {minecraft_root}\")\n        return ()\n    try:\n        shulker_box = _load_shulker_box(config_file)\n    except (FileNotFoundError, ValueError) as bad_box:\n        GATHER_LOGGER.error(\n            f\"Could not load shulker box {shulker_box_name}\\n  {bad_box}\"\n        )\n        return ()\n\n    instances = load_ender_chest_instances(minecraft_root, log_level=logging.DEBUG)\n    if not instances:\n        return instances\n\n    if shulker_box is None:\n        return ()\n    matches = [instance for instance in instances if shulker_box.matches(instance)]\n\n    if len(matches) == 0:\n        report = \"does not link to by any registered instances\"\n    else:\n        report = \"is linked to by the following instancs:\\n\" + \"\\n\".join(\n            f\"  - {_render_instance(instance)}\" for instance in matches\n        )\n\n    GATHER_LOGGER.info(f\"The shulker box {_render_shulker_box(shulker_box)} {report}\")\n\n    return matches\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_shulker_boxes","title":"<code>load_shulker_boxes(minecraft_root, log_level=logging.INFO)</code>","text":"<p>Load all shulker boxes in the EnderChest folder and return them in the order in which they should be linked.</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>log_level</code> <code>int, optional</code> <p>By default, this method will report out the minecraft instances it finds at the INFO level. You can optionally pass in a lower (or higher) level if this method is being called from another method where that information is redundant or overly verbose.</p> <code>logging.INFO</code> <p>Returns:</p> Type Description <code>list of ShulkerBoxes</code> <p>The shulker boxes found in the EnderChest folder, ordered in terms of the sequence in which they should be linked</p>"},{"location":"reference/enderchest/gather/#enderchest.gather.load_shulker_boxes--notes","title":"Notes","text":"<p>If no EnderChest is installed in the given location, then this will return an empty list rather than failing outright.</p> Source code in <code>enderchest/gather.py</code> <pre><code>def load_shulker_boxes(\n    minecraft_root: Path, log_level: int = logging.INFO\n) -&gt; list[ShulkerBox]:\n\"\"\"Load all shulker boxes in the EnderChest folder and return them in the\n    order in which they should be linked.\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    log_level : int, optional\n        By default, this method will report out the minecraft instances it\n        finds at the INFO level. You can optionally pass in a lower (or higher)\n        level if this method is being called from another method where that\n        information is redundant or overly verbose.\n\n    Returns\n    -------\n    list of ShulkerBoxes\n        The shulker boxes found in the EnderChest folder, ordered in terms of\n        the sequence in which they should be linked\n\n    Notes\n    -----\n    If no EnderChest is installed in the given location, then this will return\n    an empty list rather than failing outright.\n    \"\"\"\n    shulker_boxes: list[ShulkerBox] = []\n\n    try:\n        for shulker_config in fs.shulker_box_configs(minecraft_root):\n            try:\n                shulker_boxes.append(_load_shulker_box(shulker_config))\n            except (FileNotFoundError, ValueError) as bad_shulker:\n                GATHER_LOGGER.warning(\n                    f\"{bad_shulker}\\n  Skipping shulker box {shulker_config.parent.name}\"\n                )\n\n    except FileNotFoundError:\n        GATHER_LOGGER.error(f\"There is no EnderChest installed within {minecraft_root}\")\n        return []\n\n    shulker_boxes = sorted(shulker_boxes)\n\n    if len(shulker_boxes) == 0:\n        GATHER_LOGGER.warning(\n            f\"There are no shulker boxes within the {minecraft_root} EnderChest\"\n        )\n    else:\n        GATHER_LOGGER.log(\n            log_level,\n            f\"These are the shulker boxes within the {minecraft_root} EnderChest,\"\n            \"\\nlisted in the order in which they are linked:\\n\"\n            + \"\\n\".join(\n                f\"  {shulker_box.priority}. {_render_shulker_box(shulker_box)}\"\n                for shulker_box in shulker_boxes\n            ),\n        )\n    return shulker_boxes\n</code></pre>"},{"location":"reference/enderchest/gather/#enderchest.gather.update_ender_chest","title":"<code>update_ender_chest(minecraft_root, search_paths=None, official=None, remotes=None)</code>","text":"<p>Orchestration method that coordinates the onboarding of new instances or EnderChest installations</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder).</p> required <code>search_paths</code> <code>list of Paths, optional</code> <p>The local search paths to look for Minecraft installations within. Be warned that this search is performed recursively.</p> <code>None</code> <code>official</code> <code>bool | None, optional</code> <p>Optionally specify whether the Minecraft instances you expect to find are from the official launcher (<code>official=True</code>) or a MultiMC-derivative (<code>official=False</code>).</p> <code>None</code> <code>remotes</code> <code>list of URIs or (URI, str) tuples, optional</code> <p>Any remotes you wish to register to this instance. When a (URI, str) tuple is provided, the second value will be used as the name/alias of the remote. If there is already a remote specified with the given alias, this method will replace it.</p> <code>None</code> Source code in <code>enderchest/gather.py</code> <pre><code>def update_ender_chest(\n    minecraft_root: Path,\n    search_paths: Iterable[str | Path] | None = None,\n    official: bool | None = None,\n    remotes: Iterable[str | ParseResult | tuple[str, str] | tuple[ParseResult, str]]\n    | None = None,\n) -&gt; None:\n\"\"\"Orchestration method that coordinates the onboarding of new instances or\n    EnderChest installations\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder).\n    search_paths : list of Paths, optional\n        The local search paths to look for Minecraft installations within.\n        Be warned that this search is performed recursively.\n    official : bool | None, optional\n        Optionally specify whether the Minecraft instances you expect to find\n        are from the official launcher (`official=True`) or a MultiMC-derivative\n        (`official=False`).\n    remotes : list of URIs or (URI, str) tuples, optional\n        Any remotes you wish to register to this instance. When a (URI, str) tuple\n        is provided, the second value will be used as the name/alias of the remote.\n        If there is already a remote specified with the given alias, this method will\n        replace it.\n    \"\"\"\n    try:\n        ender_chest = load_ender_chest(minecraft_root)\n    except (FileNotFoundError, ValueError) as bad_chest:\n        GATHER_LOGGER.error(\n            f\"Could not load EnderChest from {minecraft_root}:\\n  {bad_chest}\"\n        )\n        return\n    for search_path in search_paths or ():\n        for instance in gather_minecraft_instances(\n            minecraft_root, Path(search_path), official=official\n        ):\n            _ = ender_chest.register_instance(instance)\n    for remote in remotes or ():\n        try:\n            if isinstance(remote, (str, ParseResult)):\n                ender_chest.register_remote(remote)\n            else:\n                ender_chest.register_remote(*remote)\n        except ValueError as bad_remote:\n            GATHER_LOGGER.warning(bad_remote)\n\n    create_ender_chest(minecraft_root, ender_chest)\n</code></pre>"},{"location":"reference/enderchest/instance/","title":"instance","text":"<p>Specification of a Minecraft instance</p>"},{"location":"reference/enderchest/instance/#enderchest.instance.InstanceSpec","title":"<code>InstanceSpec</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Specification of a Minecraft instance</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The \"display name\" for the instance</p> required <code>root</code> <code>Path</code> <p>The path to its \".minecraft\" folder</p> required <code>minecraft_versions</code> <code>list-like of str</code> <p>The minecraft versions of this instance. This is typically a 1-tuple, but some loaders (such as the official one) will just comingle all your assets together across all profiles</p> required <code>modloader</code> <code>str or None</code> <p>The (display) name of the modloader, or None if this is a vanilla instance</p> required <code>tags</code> <code>list-like of str</code> <p>The tags assigned to this instance</p> required Source code in <code>enderchest/instance.py</code> <pre><code>class InstanceSpec(NamedTuple):\n\"\"\"Specification of a Minecraft instance\n    Parameters\n    ----------\n    name : str\n        The \"display name\" for the instance\n    root : Path\n        The path to its \".minecraft\" folder\n    minecraft_versions : list-like of str\n        The minecraft versions of this instance. This is typically a 1-tuple,\n        but some loaders (such as the official one) will just comingle all\n        your assets together across all profiles\n    modloader : str or None\n        The (display) name of the modloader, or None if this is a vanilla\n        instance\n    tags : list-like of str\n        The tags assigned to this instance\n    \"\"\"\n\n    name: str\n    root: Path\n    minecraft_versions: tuple[str, ...]\n    modloader: str | None\n    tags: tuple[str, ...]\n\n    @classmethod\n    def from_cfg(cls, section: SectionProxy) -&gt; \"InstanceSpec\":\n\"\"\"Parse an instance spec as read in from the enderchest config file\n\n        Parameters\n        ----------\n        section : dict-like of str to str\n            The section in the enderchest config as parsed by a ConfigParser\n\n        Returns\n        -------\n        InstanceSpec\n            The resulting InstanceSpec\n\n        Raises\n        ------\n        KeyError\n            If a required key is absent\n        ValueError\n            If a required entry cannot be parsed\n        \"\"\"\n        return cls(\n            section.name,\n            Path(section[\"root\"]),\n            tuple(section[\"minecraft_version\"].strip().split()),\n            section.get(\"modloader\", None),\n            tuple(\n                tag.strip()\n                for tag in section.get(\"tags\", \"\")\n                .replace(\",\", \"\\n\")\n                .strip()\n                .split(\"\\n\")\n            ),\n        )\n</code></pre>"},{"location":"reference/enderchest/instance/#enderchest.instance.InstanceSpec.from_cfg","title":"<code>from_cfg(section)</code>  <code>classmethod</code>","text":"<p>Parse an instance spec as read in from the enderchest config file</p> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>dict-like of str to str</code> <p>The section in the enderchest config as parsed by a ConfigParser</p> required <p>Returns:</p> Type Description <code>InstanceSpec</code> <p>The resulting InstanceSpec</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If a required key is absent</p> <code>ValueError</code> <p>If a required entry cannot be parsed</p> Source code in <code>enderchest/instance.py</code> <pre><code>@classmethod\ndef from_cfg(cls, section: SectionProxy) -&gt; \"InstanceSpec\":\n\"\"\"Parse an instance spec as read in from the enderchest config file\n\n    Parameters\n    ----------\n    section : dict-like of str to str\n        The section in the enderchest config as parsed by a ConfigParser\n\n    Returns\n    -------\n    InstanceSpec\n        The resulting InstanceSpec\n\n    Raises\n    ------\n    KeyError\n        If a required key is absent\n    ValueError\n        If a required entry cannot be parsed\n    \"\"\"\n    return cls(\n        section.name,\n        Path(section[\"root\"]),\n        tuple(section[\"minecraft_version\"].strip().split()),\n        section.get(\"modloader\", None),\n        tuple(\n            tag.strip()\n            for tag in section.get(\"tags\", \"\")\n            .replace(\",\", \"\\n\")\n            .strip()\n            .split(\"\\n\")\n        ),\n    )\n</code></pre>"},{"location":"reference/enderchest/instance/#enderchest.instance.equals","title":"<code>equals(minecraft_root, instance, other_instance)</code>","text":"<p>Determine whether two instances point to the same location</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The starting location (the parent of where your EnderChest folder lives)</p> required <code>instance</code> <code>InstanceSpec</code> <p>the first instance</p> required <code>other_instance</code> <code>InstanceSpec</code> <p>the instance to compare it against</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if and only if the two instances have the same root, with regards to the provided <code>minecraft_root</code></p> Source code in <code>enderchest/instance.py</code> <pre><code>def equals(\n    minecraft_root: Path, instance: InstanceSpec, other_instance: InstanceSpec\n) -&gt; bool:\n\"\"\"Determine whether two instances point to the same location\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The starting location (the parent of where your EnderChest folder lives)\n    instance : InstanceSpec\n        the first instance\n    other_instance : InstanceSpec\n        the instance to compare it against\n\n    Returns\n    -------\n    bool\n        True if and only if the two instances have the same root, with regards\n        to the provided `minecraft_root`\n    \"\"\"\n    path = minecraft_root / instance.root.expanduser()\n    other_path = minecraft_root / other_instance.root.expanduser()\n    return path.expanduser().resolve() == other_path.expanduser().resolve()\n</code></pre>"},{"location":"reference/enderchest/loggers/","title":"loggers","text":"<p>Loggers for the various EnderChest actions</p>"},{"location":"reference/enderchest/place/","title":"place","text":"<p>Symlinking functionality</p>"},{"location":"reference/enderchest/place/#enderchest.place.link_resource","title":"<code>link_resource(resource_path, shulker_root, instance_root)</code>","text":"<p>Create a symlink for the specified resource from an instance's space pointing to the tagged file / folder living inside a shulker box.</p> <p>Parameters:</p> Name Type Description Default <code>resource_path</code> <code>str or Path</code> <p>Location of the resource relative to the instance's \".minecraft\" folder</p> required <code>shulker_root</code> <code>Path</code> <p>The path to the shulker box</p> required <code>instance_root</code> <code>Path</code> <p>The path to the instance's \".minecraft\" folder</p> required <p>Raises:</p> Type Description <code>NotADirectoryError</code> <p>If a file already exists where you're attempting to place the symlink</p> <code>OSError</code> <p>If a non-empty directory already exists where you're attempting to place the symlink</p>"},{"location":"reference/enderchest/place/#enderchest.place.link_resource--notes","title":"Notes","text":"<ul> <li>This method will create any folders that do not exist within an instance</li> <li>This method will overwrite existing symlinks and empty folders   but will not overwrite or delete any actual files.</li> </ul> Source code in <code>enderchest/place.py</code> <pre><code>def link_resource(\n    resource_path: str | Path, shulker_root: Path, instance_root: Path\n) -&gt; None:\n\"\"\"Create a symlink for the specified resource from an instance's space\n    pointing to the tagged file / folder living inside a shulker box.\n\n    Parameters\n    ----------\n    resource_path : str or Path\n        Location of the resource relative to the instance's \".minecraft\" folder\n    shulker_root : Path\n        The path to the shulker box\n    instance_root : Path\n        The path to the instance's \".minecraft\" folder\n\n    Raises\n    ------\n    NotADirectoryError\n        If a file already exists where you're attempting to place the symlink\n    OSError\n        If a non-empty directory already exists where you're attempting to\n        place the symlink\n\n    Notes\n    -----\n    - This method will create any folders that do not exist within an instance\n    - This method will overwrite existing symlinks and empty folders\n      but will not overwrite or delete any actual files.\n    \"\"\"\n    instance_path = (instance_root / resource_path).expanduser().absolute()\n    instance_path.parent.mkdir(parents=True, exist_ok=True)\n\n    relative_path = os.path.relpath(\n        (shulker_root / resource_path).expanduser().absolute(), instance_path.parent\n    )\n\n    if instance_path.is_symlink():\n        # remove previous symlink in this spot\n        PLACE_LOGGER.debug(f\"Removing old link at {instance_path}\")\n        instance_path.unlink()\n    else:\n        try:\n            os.rmdir(instance_path)\n            PLACE_LOGGER.debug(f\"Removed empty diretory at {instance_path}\")\n        except FileNotFoundError:\n            pass  # A-OK\n\n    PLACE_LOGGER.debug(f\"Linking {instance_path} to {relative_path}\")\n    os.symlink(\n        relative_path,\n        instance_path,\n        target_is_directory=(shulker_root / resource_path).is_dir(),\n    )\n</code></pre>"},{"location":"reference/enderchest/place/#enderchest.place.place_ender_chest","title":"<code>place_ender_chest(minecraft_root, cleanup=True, error_handling='abort', rollback=False)</code>","text":"<p>Link all instance files and folders to all shulker boxes</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>cleanup</code> <code>bool, optional</code> <p>By default, this method will remove any broken links in your instances and servers folders. To disable this behavior, pass in <code>cleanup=False</code></p> <code>True</code> <code>error_handling</code> <code>str, optional</code> <p>By default, if a linking failure occurs, this method will terminate immediately (<code>error_handling=abort</code>). Alternatively, - pass in <code>error_handling=\"ignore\"</code> to continue as if the link failure hadn't occrurred - pass in <code>error_handling=\"skip\"</code> to abort linking the current instance to the current shulker box but otherwise continue on - pass in <code>error_handling=\"skip-instance\"</code> to abort linking the current instance altogether but to otherwise continue on with other instances - pass in <code>error_handling=\"skip-shulker-box\"</code> to abort linking to the current shulker box altogether but to otherwise continue on with other boxes - pass in <code>error_handling=\"prompt\"</code> to ask what to do on each failure</p> <code>'abort'</code> <code>rollback</code> <p>In the future in the event of linking errors passing in <code>rollback=True</code> can be used to roll back any changes that have already been applied based on the error-handling method specified.</p> <code>False</code> Source code in <code>enderchest/place.py</code> <pre><code>def place_ender_chest(\n    minecraft_root: Path,\n    cleanup: bool = True,\n    error_handling: str = \"abort\",\n    rollback=False,\n) -&gt; None:\n\"\"\"Link all instance files and folders to all shulker boxes\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    cleanup : bool, optional\n        By default, this method will remove any broken links in your instances\n        and servers folders. To disable this behavior, pass in `cleanup=False`\n    error_handling : str, optional\n        By default, if a linking failure occurs, this method will terminate\n        immediately (`error_handling=abort`). Alternatively,\n          - pass in `error_handling=\"ignore\"` to continue as if the link failure\n            hadn't occrurred\n          - pass in `error_handling=\"skip\"` to abort linking the current instance\n            to the current shulker box but otherwise continue on\n          - pass in `error_handling=\"skip-instance\"` to abort linking the current\n            instance altogether but to otherwise continue on with other instances\n          - pass in `error_handling=\"skip-shulker-box\"` to abort linking to the current\n            shulker box altogether but to otherwise continue on with other boxes\n          - pass in `error_handling=\"prompt\"` to ask what to do on each failure\n    rollback: bool, optional\n        In the future in the event of linking errors passing in `rollback=True`\n        can be used to roll back any changes that have already been applied\n        based on the error-handling method specified.\n    \"\"\"\n    if rollback is not False:\n        raise NotImplementedError(\"Rollbacks are not currently supported\")\n\n    try:\n        host = load_ender_chest(minecraft_root).name\n    except (FileNotFoundError, ValueError) as bad_chest:\n        PLACE_LOGGER.error(\n            f\"Could not load EnderChest from {minecraft_root}:\\n  {bad_chest}\"\n        )\n        return\n\n    instances = load_ender_chest_instances(minecraft_root, log_level=logging.DEBUG)\n\n    shulker_boxes: list[ShulkerBox] = []\n\n    for shulker_box in load_shulker_boxes(minecraft_root, log_level=logging.DEBUG):\n        for condition, values in shulker_box.match_criteria:\n            if condition == \"hosts\":\n                if not any(\n                    fnmatch.fnmatchcase(host_spec.lower(), host.lower())\n                    for host_spec in values\n                ):\n                    PLACE_LOGGER.debug(\n                        f\"{shulker_box.name} is not intended\"\n                        f\" for linking to this host ({host})\"\n                    )\n                    break\n        else:\n            shulker_boxes.append(shulker_box)\n\n    skip_instances: list[InstanceSpec] = []\n\n    def handle_error(instance: InstanceSpec) -&gt; str:\n\"\"\"Centralized error-handling\n\n        Parameters\n        ----------\n        instance:\n            The current instance (in case it needs to be added to the skip list)\n\n        Returns\n        -------\n        str\n            Instructions on what to do next. Options are:\n              - return\n              - break\n              - coninue\n              - pass\n        \"\"\"\n        if error_handling == \"prompt\":\n            proceed_how = (\n                prompt(\n                    \"How would you like to proceed?\"\n                    \"\\n[Q]uit, [C]ontinue, abort linking the rest of this shulker/instance [M]atch?\"\n                    \"\\nskip the rest of this [I]nstance, skip the rest of this [S]hulker box?\",\n                    suggestion=\"I\",  # TODO: in my experience it's usally an instance issue\n                )\n                .lower()\n                .replace(\" \", \"\")\n                .replace(\"-\", \"\")\n                .replace(\"_\", \"\")\n            )\n            match proceed_how:\n                case \"\" | \"i\" | \"instance\" | \"skipinstance\":\n                    proceed_how = \"skip-instance\"\n                case \"q\" | \"quit\" | \"abort\" | \"exit\" | \"stop\":\n                    proceed_how = \"abort\"\n                case \"c\" | \"continue\" | \"ignore\":\n                    proceed_how = \"ignore\"\n                case \"m\" | \"match\" | \"skip\":\n                    proceed_how = \"skip\"\n                case \"s\" | \"shulker\" | \"shulkerbox\" | \"skipshulker\":\n                    proceed_how = \"skip-shulker\"\n                case _:\n                    PLACE_LOGGER.error(\"Invalid selection.\")\n                    return handle_error(instance)\n        else:\n            proceed_how = error_handling\n\n        match error_handling:\n            case \"abort\" | \"stop\" | \"quit\" | \"exit\":\n                PLACE_LOGGER.error(\"Aborting\")\n                return \"return\"\n            case \"ignore\":\n                PLACE_LOGGER.debug(\"Ignoring\")\n                return \"pass\"\n            case \"skip\":\n                PLACE_LOGGER.warning(\"Skipping the rest of this match\")\n                return \"continue\"\n            case \"skip-instance\":\n                PLACE_LOGGER.warning(\"Skipping any more linking from this instance\")\n                skip_instances.append(instance)\n                return \"continue\"\n            case \"skip-shulker-box\" | \"skip-shulkerbox\" | \"skip-shulker\":\n                PLACE_LOGGER.warning(\"Skipping any more linking into this shulker box\")\n                return \"break\"\n            case _:\n                raise ValueError(\n                    f\"Unrecognized error-handling method: {error_handling}\"\n                )\n\n    for shulker_box in shulker_boxes:\n        for instance in instances:\n            if not shulker_box.matches(instance):\n                continue\n            if instance in skip_instances:\n                continue\n\n            instance_root = (minecraft_root / instance.root.expanduser()).expanduser()\n\n            if not instance_root.exists():\n                PLACE_LOGGER.error(\n                    f\"No minecraft instance exists at {instance_root.expanduser().absolute()}\"\n                )\n                match handle_error(instance):\n                    case \"return\":\n                        return\n                    case \"break\":\n                        break\n                    case _:  # nothing to link, so might as well skip the rest\n                        continue\n\n            PLACE_LOGGER.info(f\"Linking {instance.root} to {shulker_box.name}\")\n\n            resources = set(shulker_box.root.expanduser().absolute().rglob(\"*\"))\n\n            match_exit = \"pass\"\n            for link_folder in shulker_box.link_folders:\n                resources -= {shulker_box.root / link_folder}\n                resources -= set((shulker_box.root / link_folder).rglob(\"*\"))\n                try:\n                    link_resource(link_folder, shulker_box.root, instance_root)\n                except (OSError, NotADirectoryError) as oh_no:\n                    PLACE_LOGGER.error(\n                        f\"Error linking shulker box {shulker_box.name}\"\n                        f\" to instance {instance.name}:\"\n                        f\"\\n{(instance.root / link_folder)} is a\"\n                        \" non-empty directory\"\n                    )\n                    match handle_error(instance):\n                        case \"return\":\n                            return\n                        case \"break\":\n                            match_exit = \"break\"\n                            break\n                        case \"continue\":\n                            match_exit = \"continue\"\n                            break\n                        case \"pass\":\n                            continue  # or pass--it's the end of the loop\n\n            if match_exit not in (\"break\", \"continue\"):\n                for resource in resources:\n                    if not resource.is_file():  # also excludes broken links\n                        continue\n                    resource_path = resource.relative_to(\n                        shulker_box.root.expanduser().absolute()\n                    )\n                    try:\n                        link_resource(\n                            resource_path,\n                            shulker_box.root,\n                            instance_root,\n                        )\n                    except (OSError, NotADirectoryError) as oh_no:\n                        PLACE_LOGGER.error(\n                            f\"Error linking shulker box {shulker_box.name}\"\n                            f\" to instance {instance.name}:\"\n                            f\"\\n{(instance.root / resource_path)}\"\n                            \" already exists\"\n                        )\n                        # TODO: option to record failure but keep going\n                        match handle_error(instance):\n                            case \"return\":\n                                return\n                            case \"break\":\n                                match_exit = \"break\"\n                                break\n                            case \"continue\":\n                                match_exit = \"continue\"  # technically does nothing\n                                break\n                            case \"pass\":\n                                continue  # or pass--it's the end of the loop\n\n            if cleanup:  # consider this a \"finally\"\n                # we clean up as we go, just in case of a failure\n                for file in instance_root.rglob(\"*\"):\n                    if not file.exists():\n                        PLACE_LOGGER.debug(f\"Removing broken link: {file}\")\n                        file.unlink()\n\n            if match_exit == \"break\":\n                break\n</code></pre>"},{"location":"reference/enderchest/prompt/","title":"prompt","text":"<p>Utilities for helping build interactive prompts</p>"},{"location":"reference/enderchest/prompt/#enderchest.prompt.confirm","title":"<code>confirm(default)</code>","text":"<p>Confirm that the user wishes to continue</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>bool</code> <p>Whether the default selection should be True (yes) or False (no)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the user has opted to continue</p> Source code in <code>enderchest/prompt.py</code> <pre><code>def confirm(default: bool) -&gt; bool:\n\"\"\"Confirm that the user wishes to continue\n\n    Parameters\n    ----------\n    default : bool\n        Whether the default selection should be True (yes) or False (no)\n\n    Returns\n    -------\n    bool\n        Whether the user has opted to continue\n    \"\"\"\n\n    confirm = prompt(\"Do you wish to continue?\", \"Y/n\" if default else \"y/N\")\n\n    if confirm == \"\":\n        return default\n\n    if confirm in YES:\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/enderchest/prompt/#enderchest.prompt.prompt","title":"<code>prompt(message, suggestion=None)</code>","text":"<p>Prompt the user and return the response</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The prompt message</p> required <code>suggestion</code> <code>str, optional</code> <p>A suggested input. If None is provided, no suggestion will be shown.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The user-provided response</p>"},{"location":"reference/enderchest/prompt/#enderchest.prompt.prompt--notes","title":"Notes","text":"<ul> <li>The output will be stripped of trailing and leading whitespace, but no   other validation or processing will be used.</li> <li>Regardless of whether a suggestion is provided, if the user provides an   empty input, this method will return an empty string. To reiterate: the   suggestion does not serve as a default / fallback value.</li> </ul> Source code in <code>enderchest/prompt.py</code> <pre><code>def prompt(message: str, suggestion: str | None = None) -&gt; str:\n\"\"\"Prompt the user and return the response\n\n    Parameters\n    ----------\n    message : str\n        The prompt message\n    suggestion : str, optional\n        A suggested input. If None is provided, no suggestion will be shown.\n\n    Returns\n    -------\n    str\n        The user-provided response\n\n    Notes\n    -----\n    - The output will be stripped of trailing and leading whitespace, but no\n      other validation or processing will be used.\n    - Regardless of whether a suggestion is provided, if the user provides an\n      empty input, this method will return an empty string. To reiterate: the\n      suggestion *does not serve* as a default / fallback value.\n    \"\"\"\n    lines = message.splitlines() + [\"\"]\n    message = \"\\n\".join(f\"{CURSOR} {line}\" for line in lines)\n    if suggestion is not None:\n        message += f\"[{suggestion}] \"\n    return input(message)\n</code></pre>"},{"location":"reference/enderchest/remote/","title":"remote","text":"<p>Higher-level functionality around synchronizing with different EnderCherts</p>"},{"location":"reference/enderchest/remote/#enderchest.remote.fetch_remotes_from_a_remote_ender_chest","title":"<code>fetch_remotes_from_a_remote_ender_chest(uri)</code>","text":"<p>Grab the list of EnderChests registered with the specified remote EnderChest</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>URI</code> <p>The URI to the remote Minecraft root</p> required <code>Returns</code> required <code>list</code> <p>The URIs of the remote EnderChests, paired with their aliases</p> required <code>Raises</code> required <code>RuntimeError</code> <p>If the remote list could not be pulled</p> required Source code in <code>enderchest/remote.py</code> <pre><code>def fetch_remotes_from_a_remote_ender_chest(\n    uri: str | ParseResult,\n) -&gt; list[tuple[ParseResult, str]]:\n\"\"\"Grab the list of EnderChests registered with the specified remote EnderChest\n    Parameters\n    ----------\n    uri : URI\n        The URI to the remote Minecraft root\n    Returns\n    -------\n    list of (URI, str) tuples\n        The URIs of the remote EnderChests, paired with their aliases\n    Raises\n    ------\n    RuntimeError\n        If the remote list could not be pulled\n    \"\"\"\n    remote_chest = load_remote_ender_chest(uri)\n    remotes: list[tuple[ParseResult, str]] = [(remote_chest._uri, remote_chest.name)]\n\n    remotes.extend(remote_chest.remotes)\n    SYNC_LOGGER.info(\n        \"Loaded the following remotes:\\n\"\n        + \"\\n\".join(f\"  - {render_remote(alias, uri)}\" for uri, alias in remotes)\n    )\n\n    if len(set(alias for _, alias in remotes)) != len(remotes):\n        raise RuntimeError(\n            f\"There are duplicates aliases in the list of remotes pulled from {uri}\"\n        )\n    return remotes\n</code></pre>"},{"location":"reference/enderchest/remote/#enderchest.remote.load_remote_ender_chest","title":"<code>load_remote_ender_chest(uri)</code>","text":"<p>Load an EnderChest configuration from another machine</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>URI</code> <p>The URI to the remote Minecraft root</p> required <code>Returns</code> required <code>EnderChest</code> <p>The remote EnderChest configuration</p> required <code>Raises</code> required <code>ValueError</code> <p>If the provided URI is invalid</p> required <code>RuntimeError</code> <p>If the config from the remote EnderChest could not be parsed</p> required Source code in <code>enderchest/remote.py</code> <pre><code>def load_remote_ender_chest(uri: str | ParseResult) -&gt; EnderChest:\n\"\"\"Load an EnderChest configuration from another machine\n    Parameters\n    ----------\n    uri : URI\n        The URI to the remote Minecraft root\n    Returns\n    -------\n    EnderChest\n        The remote EnderChest configuration\n    Raises\n    ------\n    ValueError\n        If the provided URI is invalid\n    RuntimeError\n        If the config from the remote EnderChest could not be parsed\n    \"\"\"\n    try:\n        uri = uri if isinstance(uri, ParseResult) else urlparse(uri)\n    except AttributeError as bad_uri:\n        raise ValueError(f\"{uri} is not a valid URI\") from bad_uri\n\n    remote_root = Path(uri.path)\n    remote_config_path = fs.ender_chest_config(remote_root, check_exists=False)\n    uri = uri._replace(path=remote_config_path.as_posix())\n\n    with remote_file(uri) as remote_config:\n        try:\n            return EnderChest.from_cfg(remote_config)\n        except ValueError as bad_chest:\n            raise RuntimeError(\n                f\"The remote EnderChest config downloaded from {uri.geturl()} could not be parsed.\"\n            ) from bad_chest\n</code></pre>"},{"location":"reference/enderchest/shulker_box/","title":"shulker_box","text":"<p>Specification and configuration of a shulker box</p>"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.ShulkerBox","title":"<code>ShulkerBox</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Specification of a ShulkerBox</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>The priority for linking assets in the shulker box (higher priority shulkers are linked last)</p> required <code>name</code> <code>str</code> <p>The name of the shulker box (which is incidetentally used to break priority ties)</p> required <code>root</code> <code>Path</code> <p>The path to the root of the shulker box</p> required <code>match_criteria</code> <code>list-like of tuples</code> <p>The parameters for matching instances to this shulker box. Each element consistents of: - the name of the condition - the matching values for that condition</p> <p>The logic applied is that an instance must match at least one value for each condition (so it's ANDing a collection of ORs)</p> required <code>link_folders</code> <code>list-like of str</code> <p>The folders that should be linked in their entirety</p> required"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.ShulkerBox--notes","title":"Notes","text":"<p>A shulker box specification is immutable, so making changes (such as updating the match critera) can only be done on copies created via the <code>_replace</code> method, inherited from the NamedTuple parent class.</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>class ShulkerBox(NamedTuple):\n\"\"\"Specification of a ShulkerBox\n\n    Parameters\n    ----------\n    priority : int\n        The priority for linking assets in the shulker box (higher priority\n        shulkers are linked last)\n    name : str\n        The name of the shulker box (which is incidetentally used to break\n        priority ties)\n    root : Path\n        The path to the root of the shulker box\n    match_criteria : list-like of tuples\n        The parameters for matching instances to this shulker box. Each element\n        consistents of:\n          - the name of the condition\n          - the matching values for that condition\n\n        The logic applied is that an instance must match at least one value\n        for each condition (so it's ANDing a collection of ORs)\n    link_folders : list-like of str\n        The folders that should be linked in their entirety\n\n    Notes\n    -----\n    A shulker box specification is immutable, so making changes (such as\n    updating the match critera) can only be done on copies created via the\n    `_replace` method, inherited from the NamedTuple parent class.\n    \"\"\"\n\n    priority: int\n    name: str\n    root: Path\n    match_criteria: tuple[tuple[str, tuple[str, ...]], ...]\n    link_folders: tuple[str, ...]\n\n    @classmethod\n    def from_cfg(cls, config_file: Path) -&gt; \"ShulkerBox\":\n\"\"\"Parse a shulker box from its config file\n\n        Parameters\n        ----------\n        config_file : Path\n            The path to the config file\n\n        Returns\n        -------\n        ShulkerBox\n            The resulting ShulkerBox\n\n        Raises\n        ------\n        ValueError\n            If the config file at that location cannot be parsed\n        FileNotFoundError\n            If there is no config file at the specified location\n        \"\"\"\n        priority = 0\n        root = config_file.parent\n        name = root.name\n        parser = ConfigParser(allow_no_value=True, inline_comment_prefixes=(\";\",))\n        try:\n            assert parser.read(config_file)\n        except ParsingError as bad_cfg:\n            raise ValueError(f\"Could not parse {config_file}\") from bad_cfg\n        except AssertionError:\n            raise FileNotFoundError(f\"Could not open {config_file}\")\n\n        match_criteria: dict[str, tuple[str, ...]] = {}\n\n        for section in parser.sections():\n            normalized = (\n                section.lower().replace(\" \", \"\").replace(\"-\", \"\").replace(\"_\", \"\")\n            )\n            if normalized.endswith(\"s\"):\n                normalized = normalized[:-1]  # lazy de-pluralization\n            if normalized in (\"linkfolder\", \"folder\"):\n                normalized = \"link-folders\"\n            if normalized in (\"minecraft\", \"version\", \"minecraftversion\"):\n                normalized = \"minecraft\"\n            if normalized in (\"modloader\", \"loader\"):\n                normalized = \"modloader\"\n            if normalized in (\"instance\", \"tag\", \"host\"):\n                normalized += \"s\"  # lazy re-pluralization\n\n            if normalized == \"propertie\":  # lulz\n                # TODO check to make sure properties hasn't been read before\n                # most of this section gets ignored\n                priority = parser[section].getint(\"priority\", 0)\n                # TODO: support specifying filters (and link-folders) in the properties section\n                continue\n            if normalized in match_criteria.keys():\n                raise ValueError(f\"{config_file} specifies {normalized} more than once\")\n\n            if normalized == \"minecraft\":\n                minecraft_versions = []\n                for key, value in parser[section].items():\n                    if value is None:\n                        minecraft_versions.append(key)\n                    elif key.lower().strip().startswith(\"version\"):\n                        minecraft_versions.append(value)\n                    else:  # what happens if you specify \"&gt;=1.19\" or \"=1.12\"\n                        minecraft_versions.append(\"=\".join((key, value)))\n                match_criteria[\"minecraft\"] = tuple(minecraft_versions)\n            else:\n                # really hoping delimiter shenanigans doesn't show up anywhere else\n                match_criteria[normalized] = tuple(parser[section].keys())\n\n        link_folders = match_criteria.pop(\"link-folders\", ())\n\n        return cls(priority, name, root, tuple(match_criteria.items()), link_folders)\n\n    def write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n\"\"\"Write this shulker's configuration to INI\n\n        Parameters\n        ----------\n        config_file : Path, optional\n            The path to the config file, assuming you'd like to write the\n            contents to file\n\n        Returns\n        -------\n        str\n            An INI-syntax rendering of this shulker box's config\n\n        Notes\n        -----\n        The \"root\" attribute is ignored for this method\n        \"\"\"\n        config = ConfigParser(allow_no_value=True)\n        config.add_section(\"properties\")\n        config.set(\"properties\", \"priority\", str(self.priority))\n        config.set(\"properties\", \"last_modified\", dt.datetime.now().isoformat(sep=\" \"))\n        config.set(\n            \"properties\", \"generated_by_enderchest_version\", get_versions()[\"version\"]\n        )\n\n        for condition, values in self.match_criteria:\n            config.add_section(condition)\n            for value in values:\n                config.set(condition, value)\n\n        config.add_section(\"link-folders\")\n        for folder in self.link_folders:\n            config.set(\"link-folders\", folder)\n\n        buffer = StringIO()\n        buffer.write(f\"; {os.path.join(self.name, fs.SHULKER_BOX_CONFIG_NAME)}\\n\")\n        config.write(buffer)\n        buffer.seek(0)  # rewind\n\n        if config_file:\n            config_file.write_text(buffer.read())\n            buffer.seek(0)\n        return buffer.read()\n\n    def matches(self, instance: InstanceSpec) -&gt; bool:\n\"\"\"Determine whether the shulker box matches the given instance\n\n        Parameters\n        ----------\n        instance : InstanceSpec\n            The instance's specification\n\n        Returns\n        -------\n        bool\n            True if the instance matches the shulker box's conditions, False\n            otherwise.\n        \"\"\"\n        for condition, values in self.match_criteria:\n            match condition:  # these should have been normalized on read-in\n                case \"instances\":\n                    for value in values:\n                        if fnmatch.fnmatchcase(instance.name, value):\n                            break\n                    else:\n                        return False\n                case \"tags\":\n                    for value in values:\n                        if fnmatch.filter(\n                            [tag.lower() for tag in instance.tags], value.lower()\n                        ):\n                            break\n                    else:\n                        return False\n                case \"modloader\":\n                    normalized: list[str] = sum(\n                        [_normalize_modloader(value) for value in values], []\n                    )\n                    for value in normalized:\n                        if fnmatch.filter(\n                            [\n                                loader.lower()\n                                for loader in _normalize_modloader(instance.modloader)\n                            ],\n                            value.lower(),\n                        ):\n                            break\n                    else:\n                        return False\n                case \"minecraft\":\n                    for value in values:\n                        if any(\n                            (\n                                _matches_version(value, version)\n                                for version in instance.minecraft_versions\n                            )\n                        ):\n                            break\n                    else:\n                        return False\n                case \"hosts\":\n                    # this is handled at a higher level\n                    pass\n                case _:\n                    raise NotImplementedError(\n                        f\"Don't know how to apply match condition {condition}.\"\n                    )\n\n        return True\n</code></pre>"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.ShulkerBox.from_cfg","title":"<code>from_cfg(config_file)</code>  <code>classmethod</code>","text":"<p>Parse a shulker box from its config file</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path</code> <p>The path to the config file</p> required <p>Returns:</p> Type Description <code>ShulkerBox</code> <p>The resulting ShulkerBox</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the config file at that location cannot be parsed</p> <code>FileNotFoundError</code> <p>If there is no config file at the specified location</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>@classmethod\ndef from_cfg(cls, config_file: Path) -&gt; \"ShulkerBox\":\n\"\"\"Parse a shulker box from its config file\n\n    Parameters\n    ----------\n    config_file : Path\n        The path to the config file\n\n    Returns\n    -------\n    ShulkerBox\n        The resulting ShulkerBox\n\n    Raises\n    ------\n    ValueError\n        If the config file at that location cannot be parsed\n    FileNotFoundError\n        If there is no config file at the specified location\n    \"\"\"\n    priority = 0\n    root = config_file.parent\n    name = root.name\n    parser = ConfigParser(allow_no_value=True, inline_comment_prefixes=(\";\",))\n    try:\n        assert parser.read(config_file)\n    except ParsingError as bad_cfg:\n        raise ValueError(f\"Could not parse {config_file}\") from bad_cfg\n    except AssertionError:\n        raise FileNotFoundError(f\"Could not open {config_file}\")\n\n    match_criteria: dict[str, tuple[str, ...]] = {}\n\n    for section in parser.sections():\n        normalized = (\n            section.lower().replace(\" \", \"\").replace(\"-\", \"\").replace(\"_\", \"\")\n        )\n        if normalized.endswith(\"s\"):\n            normalized = normalized[:-1]  # lazy de-pluralization\n        if normalized in (\"linkfolder\", \"folder\"):\n            normalized = \"link-folders\"\n        if normalized in (\"minecraft\", \"version\", \"minecraftversion\"):\n            normalized = \"minecraft\"\n        if normalized in (\"modloader\", \"loader\"):\n            normalized = \"modloader\"\n        if normalized in (\"instance\", \"tag\", \"host\"):\n            normalized += \"s\"  # lazy re-pluralization\n\n        if normalized == \"propertie\":  # lulz\n            # TODO check to make sure properties hasn't been read before\n            # most of this section gets ignored\n            priority = parser[section].getint(\"priority\", 0)\n            # TODO: support specifying filters (and link-folders) in the properties section\n            continue\n        if normalized in match_criteria.keys():\n            raise ValueError(f\"{config_file} specifies {normalized} more than once\")\n\n        if normalized == \"minecraft\":\n            minecraft_versions = []\n            for key, value in parser[section].items():\n                if value is None:\n                    minecraft_versions.append(key)\n                elif key.lower().strip().startswith(\"version\"):\n                    minecraft_versions.append(value)\n                else:  # what happens if you specify \"&gt;=1.19\" or \"=1.12\"\n                    minecraft_versions.append(\"=\".join((key, value)))\n            match_criteria[\"minecraft\"] = tuple(minecraft_versions)\n        else:\n            # really hoping delimiter shenanigans doesn't show up anywhere else\n            match_criteria[normalized] = tuple(parser[section].keys())\n\n    link_folders = match_criteria.pop(\"link-folders\", ())\n\n    return cls(priority, name, root, tuple(match_criteria.items()), link_folders)\n</code></pre>"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.ShulkerBox.matches","title":"<code>matches(instance)</code>","text":"<p>Determine whether the shulker box matches the given instance</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>InstanceSpec</code> <p>The instance's specification</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the instance matches the shulker box's conditions, False otherwise.</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>def matches(self, instance: InstanceSpec) -&gt; bool:\n\"\"\"Determine whether the shulker box matches the given instance\n\n    Parameters\n    ----------\n    instance : InstanceSpec\n        The instance's specification\n\n    Returns\n    -------\n    bool\n        True if the instance matches the shulker box's conditions, False\n        otherwise.\n    \"\"\"\n    for condition, values in self.match_criteria:\n        match condition:  # these should have been normalized on read-in\n            case \"instances\":\n                for value in values:\n                    if fnmatch.fnmatchcase(instance.name, value):\n                        break\n                else:\n                    return False\n            case \"tags\":\n                for value in values:\n                    if fnmatch.filter(\n                        [tag.lower() for tag in instance.tags], value.lower()\n                    ):\n                        break\n                else:\n                    return False\n            case \"modloader\":\n                normalized: list[str] = sum(\n                    [_normalize_modloader(value) for value in values], []\n                )\n                for value in normalized:\n                    if fnmatch.filter(\n                        [\n                            loader.lower()\n                            for loader in _normalize_modloader(instance.modloader)\n                        ],\n                        value.lower(),\n                    ):\n                        break\n                else:\n                    return False\n            case \"minecraft\":\n                for value in values:\n                    if any(\n                        (\n                            _matches_version(value, version)\n                            for version in instance.minecraft_versions\n                        )\n                    ):\n                        break\n                else:\n                    return False\n            case \"hosts\":\n                # this is handled at a higher level\n                pass\n            case _:\n                raise NotImplementedError(\n                    f\"Don't know how to apply match condition {condition}.\"\n                )\n\n    return True\n</code></pre>"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.ShulkerBox.write_to_cfg","title":"<code>write_to_cfg(config_file=None)</code>","text":"<p>Write this shulker's configuration to INI</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>Path, optional</code> <p>The path to the config file, assuming you'd like to write the contents to file</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>An INI-syntax rendering of this shulker box's config</p>"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.ShulkerBox.write_to_cfg--notes","title":"Notes","text":"<p>The \"root\" attribute is ignored for this method</p> Source code in <code>enderchest/shulker_box.py</code> <pre><code>def write_to_cfg(self, config_file: Path | None = None) -&gt; str:\n\"\"\"Write this shulker's configuration to INI\n\n    Parameters\n    ----------\n    config_file : Path, optional\n        The path to the config file, assuming you'd like to write the\n        contents to file\n\n    Returns\n    -------\n    str\n        An INI-syntax rendering of this shulker box's config\n\n    Notes\n    -----\n    The \"root\" attribute is ignored for this method\n    \"\"\"\n    config = ConfigParser(allow_no_value=True)\n    config.add_section(\"properties\")\n    config.set(\"properties\", \"priority\", str(self.priority))\n    config.set(\"properties\", \"last_modified\", dt.datetime.now().isoformat(sep=\" \"))\n    config.set(\n        \"properties\", \"generated_by_enderchest_version\", get_versions()[\"version\"]\n    )\n\n    for condition, values in self.match_criteria:\n        config.add_section(condition)\n        for value in values:\n            config.set(condition, value)\n\n    config.add_section(\"link-folders\")\n    for folder in self.link_folders:\n        config.set(\"link-folders\", folder)\n\n    buffer = StringIO()\n    buffer.write(f\"; {os.path.join(self.name, fs.SHULKER_BOX_CONFIG_NAME)}\\n\")\n    config.write(buffer)\n    buffer.seek(0)  # rewind\n\n    if config_file:\n        config_file.write_text(buffer.read())\n        buffer.seek(0)\n    return buffer.read()\n</code></pre>"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.create_shulker_box","title":"<code>create_shulker_box(minecraft_root, shulker_box)</code>","text":"<p>Create a shulker box folder based on the provided configuration</p> <p>Parameters:</p> Name Type Description Default <code>minecraft_root</code> <code>Path</code> <p>The root directory that your minecraft stuff (or, at least, the one that's the parent of your EnderChest folder)</p> required <code>shulker_box</code> <code>ShulkerBox</code> <p>The spec of the box to create</p> required"},{"location":"reference/enderchest/shulker_box/#enderchest.shulker_box.create_shulker_box--notes","title":"Notes","text":"<ul> <li>The \"root\" attribute of the ShulkerBox config will be ignored--instead   the shulker box will be created at   /EnderChest/ <li>This method will fail if there is no EnderChest set up in the minecraft   root</li> <li>This method does not check to see if there is already a shulker box   set up at the specificed location--if one exists, its config will   be overwritten</li> Source code in <code>enderchest/shulker_box.py</code> <pre><code>def create_shulker_box(minecraft_root: Path, shulker_box: ShulkerBox) -&gt; None:\n\"\"\"Create a shulker box folder based on the provided configuration\n\n    Parameters\n    ----------\n    minecraft_root : Path\n        The root directory that your minecraft stuff (or, at least, the one\n        that's the parent of your EnderChest folder)\n    shulker_box : ShulkerBox\n        The spec of the box to create\n\n    Notes\n    -----\n    - The \"root\" attribute of the ShulkerBox config will be ignored--instead\n      the shulker box will be created at\n      &lt;minecraft_root&gt;/EnderChest/&lt;shulker box name&gt;\n    - This method will fail if there is no EnderChest set up in the minecraft\n      root\n    - This method does not check to see if there is already a shulker box\n      set up at the specificed location--if one exists, its config will\n      be overwritten\n    \"\"\"\n    root = fs.shulker_box_root(minecraft_root, shulker_box.name)\n    root.mkdir(exist_ok=True)\n\n    for folder in (*DEFAULT_SHULKER_FOLDERS, *shulker_box.link_folders):\n        CRAFT_LOGGER.debug(f\"Creating {root / folder}\")\n        (root / folder).mkdir(exist_ok=True, parents=True)\n\n    config_path = fs.shulker_box_config(minecraft_root, shulker_box.name)\n    shulker_box.write_to_cfg(config_path)\n    CRAFT_LOGGER.info(f\"Shulker box configuration written to {config_path}\")\n</code></pre>"},{"location":"reference/enderchest/sync/","title":"sync","text":"<p>Low-level functionality for synchronizing across different machines</p>"},{"location":"reference/enderchest/sync/#enderchest.sync.get_default_netloc","title":"<code>get_default_netloc()</code>","text":"<p>Compile a netloc from environment variables, etc.</p> <p>Returns:</p> Type Description <code>str</code> <p>The default netloc, which is {user}@{hostname}</p> Source code in <code>enderchest/sync.py</code> <pre><code>def get_default_netloc() -&gt; str:\n\"\"\"Compile a netloc from environment variables, etc.\n\n    Returns\n    -------\n    str\n        The default netloc, which is {user}@{hostname}\n    \"\"\"\n    return f\"{getpass.getuser()}@{socket.gethostname()}\"\n</code></pre>"},{"location":"reference/enderchest/sync/#enderchest.sync.remote_file","title":"<code>remote_file(uri)</code>","text":"<p>Grab a file from a remote filesystem by its URI and read its contents</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>parsed URI</code> <p>The URI of the file to read</p> required <p>Yields:</p> Type Description <code>Path</code> <p>A path to a local (temp) copy of the file</p> Source code in <code>enderchest/sync.py</code> <pre><code>@contextmanager\ndef remote_file(uri: ParseResult) -&gt; Generator[Path, None, None]:\n\"\"\"Grab a file from a remote filesystem by its URI and read its contents\n\n    Parameters\n    ----------\n    uri : parsed URI\n        The URI of the file to read\n\n    Yields\n    ------\n    Path\n        A path to a local (temp) copy of the file\n    \"\"\"\n    raise NotImplementedError(\"Remote file access is not currently implemented\")\n</code></pre>"},{"location":"reference/enderchest/sync/#enderchest.sync.render_remote","title":"<code>render_remote(alias, uri)</code>","text":"<p>Render a remote to a descriptive string</p> <p>Parameters:</p> Name Type Description Default <code>alias</code> <code>str</code> <p>The name of the remote</p> required <code>uri</code> <code>ParseResult</code> <p>The parsed URI for the remote</p> required <p>Returns:</p> Type Description <code>str</code> <p>{uri_string} [({alias})]} (if different from the URI hostname)</p> Source code in <code>enderchest/sync.py</code> <pre><code>def render_remote(alias: str, uri: ParseResult) -&gt; str:\n\"\"\"Render a remote to a descriptive string\n\n    Parameters\n    ----------\n    alias : str\n        The name of the remote\n    uri : ParseResult\n        The parsed URI for the remote\n\n    Returns\n    -------\n    str\n        {uri_string} [({alias})]}\n            (if different from the URI hostname)\n    \"\"\"\n    uri_string = uri.geturl()\n\n    if uri.hostname != alias:\n        uri_string += f\" ({alias})\"\n    return uri_string\n</code></pre>"}]}