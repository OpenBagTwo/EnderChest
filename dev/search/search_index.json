{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"EnderChest","text":"<p>syncing and linking for all your Minecraft instances </p>"},{"location":"about/","title":"About Me","text":"<p>Hello!</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>enderchest<ul> <li>config</li> <li>craft</li> <li>sync</li> <li>cli</li> <li>place</li> </ul> </li> </ul>"},{"location":"reference/enderchest/","title":"enderchest","text":""},{"location":"reference/enderchest/#enderchest.contexts","title":"<code>contexts(root)</code>","text":"<p>Centrally define context directories based on the root folder</p> <p>Returns:</p> Type Description <code>Tuple of Paths</code> <p>The contexts, in order, - global : for syncing across all instances and servers - client-only : for syncing across all client instances - server-only : for syncing across all server instances - local-only : for local use only (don't sync) - other-locals : \"local-only\" folders from other installations (for distributed backups)</p>"},{"location":"reference/enderchest/#enderchest.contexts--notes","title":"Notes","text":"<ul> <li>Because \"global\" is a restricted keyword in Python, the namedtuple key for   this context is \"universal\"</li> <li>For all other contexts, the namedtuple key replaces a dash (not a valid token   character) with an underscore   `</li> </ul> Source code in <code>enderchest/__init__.py</code> <pre><code>def contexts(root: str | os.PathLike) -&gt; Contexts:\n\"\"\"Centrally define context directories based on the root folder\n\n    Returns\n    -------\n    Tuple of Paths\n        The contexts, in order,\n        - global : for syncing across all instances and servers\n        - client-only : for syncing across all client instances\n        - server-only : for syncing across all server instances\n        - local-only : for local use only (don't sync)\n        - other-locals : \"local-only\" folders from other installations\n                         (for distributed backups)\n\n    Notes\n    -----\n    - Because \"global\" is a restricted keyword in Python, the namedtuple key for\n      this context is \"universal\"\n    - For all other contexts, the namedtuple key replaces a dash (not a valid token\n      character) with an underscore   `\n    \"\"\"\n    ender_chest = Path(root).expanduser().resolve() / \"EnderChest\"\n\n    return Contexts(\n        ender_chest / \"global\",\n        ender_chest / \"client-only\",\n        ender_chest / \"server-only\",\n        ender_chest / \"local-only\",\n        ender_chest / \"other-locals\",\n    )\n</code></pre>"},{"location":"reference/enderchest/cli/","title":"cli","text":"<p>Command-line interface</p>"},{"location":"reference/enderchest/cli/#enderchest.cli.PassThroughParser","title":"<code>PassThroughParser</code>","text":"<p>Command-line argument parser that just collects any (non --help) flags into a list of arguments</p> Source code in <code>enderchest/cli.py</code> <pre><code>class PassThroughParser:\n\"\"\"Command-line argument parser that just collects any (non --help) flags\n    into a list of arguments\"\"\"\n\n    def __init__(self, **argparse_kwargs):\n        self._parser = argparse.ArgumentParser(**argparse_kwargs)\n\n    def add_argument(self, *args, **kwargs):\n        self._parser.add_argument(*args, **kwargs)\n\n    def parse_args(self, args) -&gt; argparse.Namespace:\n        if \"-h\" in args or \"--help\" in args:\n            return self._parser.parse_args([\"--help\"])\n\n        root: Path | None = None\n        if len(args) &gt; 0 and not args[0].startswith(\"-\"):\n            try:\n                root = Path(args[0])\n                args = args[1:]\n            except (TypeError, AttributeError):\n                # then hopefully it wasn't intended to be a path\n                pass\n\n        root = root or Path(os.getcwd())\n        dummy_namespace = argparse.Namespace()\n        dummy_namespace.__dict__ = {\"root\": root, \"command_line_args\": args}\n        return dummy_namespace\n</code></pre>"},{"location":"reference/enderchest/cli/#enderchest.cli.parse_args","title":"<code>parse_args(argv)</code>","text":"<p>Parse the provided command-line options to determine the action to perform and the arguments to pass to the action</p> <p>Parameters:</p> Name Type Description Default <code>argv</code> <code>list-like of str (sys.argv)</code> <p>The options passed into the command line</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The action method that will be called</p> <code>str</code> <p>The root of the minecraft folder (parent of the EnderChest) where the action will be perfomed</p> <code>dict</code> <p>Any additional options that will be given to the action method</p> Source code in <code>enderchest/cli.py</code> <pre><code>def parse_args(argv: Sequence[str]) -&gt; tuple[_Action, str, dict[str, Any]]:\n\"\"\"Parse the provided command-line options to determine the action to perform and\n    the arguments to pass to the action\n\n    Parameters\n    ----------\n    argv : list-like of str (sys.argv)\n        The options passed into the command line\n\n    Returns\n    -------\n    Callable\n        The action method that will be called\n    str\n        The root of the minecraft folder (parent of the EnderChest)\n        where the action will be perfomed\n    dict\n        Any additional options that will be given to the action method\n\n    \"\"\"\n    actions: dict[str, _Action] = {}\n    descriptions: dict[str, str] = {}\n    root_description: str = \"\"\n    for name, description, method in ACTIONS:\n        actions[name] = method\n        descriptions[name] = description\n        root_description += f\"\\n\\t{name}: to {description}\"\n\n    enderchest_parser = argparse.ArgumentParser(\n        prog=\"enderchest\",\n        description=(\n            f\"v{__version__}\\n\" \"\\nsyncing and linking for all your Minecraft instances\"\n        ),\n        formatter_class=argparse.RawTextHelpFormatter,\n    )\n\n    enderchest_parser.add_argument(\n        \"-v\", \"--version\", action=\"version\", version=f\"%(prog)s v{__version__}\"\n    )\n\n    enderchest_parser.add_argument(\n        \"action\",\n        help=f\"the action to perform. Options are:{root_description}\",\n        type=str,\n        choices=actions.keys(),\n    )\n    enderchest_parser.add_argument(\n        \"arguments\",\n        nargs=\"*\",\n        help=\"any additional arguments for the specific action.\"\n        \" To learn more, try: enderchest {action} -h\",\n    )\n\n    action_parsers: dict[str, argparse.ArgumentParser | PassThroughParser] = {}\n    for command in actions.keys():\n        if command in (\"open\", \"close\"):\n            parser: argparse.ArgumentParser | PassThroughParser = PassThroughParser(\n                prog=f\"enderchest {command}\", description=descriptions[command]\n            )\n        else:\n            parser = argparse.ArgumentParser(\n                prog=f\"enderchest {command}\", description=descriptions[command]\n            )\n        parser.add_argument(\n            \"root\",\n            nargs=\"?\",\n            help=(\n                \"optionally specify your root minecraft directory.\"\n                \"  If no path is given, the current working directory will be used.\"\n            ),\n            type=Path,\n            default=Path(os.getcwd()),\n        )\n        action_parsers[command] = parser\n\n    action_parsers[\"craft\"].add_argument(\n        \"-r\",\n        \"--remote\",\n        dest=\"remotes\",\n        action=\"append\",\n        help=\"specify a remote enderchest installation using the syntax\"\n        \" [user@]addreess:/path/to/enderchest\",\n    )\n\n    action_parsers[\"craft\"].add_argument(\n        \"-f\",\n        \"--file\",\n        dest=\"config_file\",\n        action=\"store\",\n        type=Path,\n        help=\"parse the enderchest installations to sync with from\"\n        \" the specified config file\",\n    )\n\n    action_parsers[\"craft\"].add_argument(\n        \"--overwrite\",\n        action=\"store_true\",\n        help=\"overwrite any existing sync scripts\",\n    )\n\n    action_parsers[\"place\"].add_argument(\n        \"-k\",\n        \"--keep-broken\",\n        action=\"store_false\",\n        dest=\"cleanup\",\n        help=\"do not remove broken links when performing place\",\n    )\n\n    for command in (\"open\", \"close\"):\n        action_parsers[command].add_argument(\n            \"command_line_args\",\n            nargs=\"*\",\n            help=\"any additional arguments to pass through to the script\",\n        )\n\n    root_args = enderchest_parser.parse_args(argv[1:2])\n    action: _Action = actions[root_args.action]\n    action_kwargs = vars(action_parsers[root_args.action].parse_args(argv[2:]))\n    root = action_kwargs.pop(\"root\")\n    return action, root, action_kwargs\n</code></pre>"},{"location":"reference/enderchest/config/","title":"config","text":"<p>Logic for parsing configuration files</p>"},{"location":"reference/enderchest/config/#enderchest.config.Config","title":"<code>Config</code>","text":"<p>The configuration spec for the EnderChest package</p> <p>Attributes:</p> Name Type Description <code>local_root</code> <code>str</code> <p>The path on the local installation of the minecraft directory (which should / will contain the EnderChest folder, along with the instances and servers directories)</p> <code>remotes</code> <code>list-like of RemoteSync</code> <p>The specifications of the remote EnderChest installations to sync with, complete with any wrapper commands</p> <code>craft_options</code> <code>dict</code> <p>Any additional options to pass to the craft command</p> Source code in <code>enderchest/config.py</code> <pre><code>class Config:\n\"\"\"The configuration spec for the EnderChest package\n\n    Attributes\n    ----------\n    local_root : str\n        The path on the local installation of the minecraft directory (which\n        should / will contain the EnderChest folder, along with the instances\n        and servers directories)\n    remotes : list-like of RemoteSync\n        The specifications of the remote EnderChest installations to sync with,\n        complete with any wrapper commands\n    craft_options: dict\n        Any additional options to pass to the craft command\n    \"\"\"\n\n    @classmethod\n    def _default_craft_options(cls) -&gt; dict:\n\"\"\"The default craft options if None are specified. Note that providing\n        *any* value to craft_options will completely replace this dict\"\"\"\n\n        # TODO: figure out how to to have\n        return {\n            \"local_alias\": None,\n            \"pre_open\": [],\n            \"pre_close\": [],\n            \"post_open\": [],\n            \"post_close\": [],\n        }\n\n    def __init__(\n        self,\n        local_root: str,\n        remotes: Sequence[RemoteSync],\n        craft_options: dict[str, Any] | None = None,\n    ):\n        self.local_root = local_root\n        self.remotes = remotes\n        self.craft_options = Config._default_craft_options()\n        if craft_options:\n            self.craft_options.update(craft_options)\n\n    @property\n    def _config(self) -&gt; ConfigParser:\n        parser = ConfigParser()\n        local: dict[str, str] = {\"root\": self.local_root}\n        if alias := self.craft_options[\"local_alias\"]:\n            local[\"name\"] = alias\n        parser[\"local\"] = local\n\n        options: dict[str, Any] = {}\n        for keyword, value in self.craft_options.items():\n            if keyword == \"local_alias\":\n                continue\n            if keyword in (\"pre_open\", \"pre_close\", \"post_open\", \"post_close\"):\n                options[keyword] = json.dumps(value)\n            else:\n                options[keyword] = value\n\n        parser[\"options\"] = options\n\n        for remote_sync in self.remotes:\n            remote = remote_sync.remote\n            remote_spec: dict[str, str] = {\n                \"host\": remote.host if remote.host else \"\",\n                \"root\": str(remote.root),\n            }\n            if username := remote.username:\n                remote_spec[\"username\"] = username\n            for wrapper in (\"pre_open\", \"pre_close\", \"post_open\", \"post_close\"):\n                if commands := getattr(remote_sync, wrapper):\n                    remote_spec[wrapper] = json.dumps(commands)\n            parser[remote.alias] = remote_spec\n        return parser\n\n    @property\n    def _asdict(self) -&gt; dict[str, Any]:\n        as_dict = {}\n        for section in self._config.sections():\n            as_dict[section] = {\n                keyword: self._config.get(section, keyword)\n                for keyword in self._config.options(section)\n            }\n        return as_dict\n\n    def __repr__(self) -&gt; str:\n        return repr(self._asdict)\n\n    def __eq__(self, other) -&gt; bool:\n        try:\n            return self._asdict == other._asdict\n        except AttributeError:\n            return self._asdict == other\n</code></pre>"},{"location":"reference/enderchest/config/#enderchest.config.parse_config","title":"<code>parse_config(contents)</code>","text":"<p>Parse the contents of a config file</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>str</code> <p>The raw config file contents</p> required <p>Returns:</p> Type Description <code>Config</code> <p>The parsed config file contents</p> Source code in <code>enderchest/config.py</code> <pre><code>def parse_config(contents: str) -&gt; Config:\n\"\"\"Parse the contents of a config file\n\n    Parameters\n    ----------\n    contents : str\n        The raw config file contents\n\n    Returns\n    -------\n    Config\n        The parsed config file contents\n    \"\"\"\n    parser = ConfigParser()\n    parser.read_string(contents)\n\n    if \"local\" not in parser:\n        raise ParsingError(\"Configuration must contain a [local] section\")\n    local_root, options = _parse_local_section(parser[\"local\"])\n    if \"options\" in parser:\n        more_options = _parse_options_section(parser[\"options\"])\n        for option, value in more_options.items():\n            if option in (\"pre_open\", \"pre_close\", \"post_open\", \"post_close\"):\n                options[option].extend(value)\n            elif option in options and value != options[option]:\n                raise ParsingError(f\"Found conflicting values for {option}\")\n            else:\n                options[option] = value\n\n    remotes = [\n        _parse_remote_section(parser[alias])\n        for alias in parser.sections()\n        if alias not in (\"local\", \"options\")\n    ]\n\n    return Config(local_root, remotes, options)\n</code></pre>"},{"location":"reference/enderchest/config/#enderchest.config.parse_config_file","title":"<code>parse_config_file(config_path)</code>","text":"<p>Parse a config file</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>path</code> <p>The path to the config file</p> required <p>Returns:</p> Type Description <code>Config</code> <p>The parsed config file contents</p> Source code in <code>enderchest/config.py</code> <pre><code>def parse_config_file(config_path: str | os.PathLike) -&gt; Config:\n\"\"\"Parse a config file\n\n    Parameters\n    ----------\n    config_path : path\n        The path to the config file\n\n    Returns\n    -------\n    Config\n        The parsed config file contents\n    \"\"\"\n    with open(config_path) as config_file:\n        return parse_config(config_file.read())\n</code></pre>"},{"location":"reference/enderchest/craft/","title":"craft","text":"<p>Utilities for setting up the folder structure</p>"},{"location":"reference/enderchest/craft/#enderchest.craft.craft_ender_chest","title":"<code>craft_ender_chest(root, *remotes, craft_folders_only=False, **sync_options)</code>","text":"<p>Create the EnderChest folder structure in the specified root directory as well as the sync scripts</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>path</code> <p>The root directory to put the EnderChest folder structure into</p> required <code>*remotes</code> <code>Remotes</code> <p>The remote installations to sync with</p> <code>()</code> <code>craft_folders_only</code> <code>bool, optional</code> <p>If set to True, this method will only set up the EnderChest folders and will not create any sync scripts.</p> <code>False</code> <code>**sync_options</code> <p>Any additional arguments to pass to the sync.link_to_other_chests()</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> Source code in <code>enderchest/craft.py</code> <pre><code>def craft_ender_chest(\n    root: str | os.PathLike,\n    *remotes: Remote | RemoteSync,\n    craft_folders_only: bool = False,\n    **sync_options\n) -&gt; None:\n\"\"\"Create the EnderChest folder structure in the specified root directory as well\n    as the sync scripts\n\n    Parameters\n    ----------\n    root : path\n        The root directory to put the EnderChest folder structure into\n    *remotes : Remotes / RemoteSyncs\n        The remote installations to sync with\n    craft_folders_only : bool, optional\n        If set to True, this method will only set up the EnderChest folders and will\n        not create any sync scripts.\n    **sync_options\n        Any additional arguments to pass to the sync.link_to_other_chests()\n\n    Returns\n    -------\n    None\n    \"\"\"\n    folders_for_contexts = _parse_folder_context_combos()\n    for context_type, context_root in contexts(root)._asdict().items():\n        context_root.mkdir(parents=True, exist_ok=True)\n        for folder in folders_for_contexts[context_type]:\n            (context_root / folder).mkdir(parents=True, exist_ok=True)\n\n    if not craft_folders_only:\n        link_to_other_chests(root, *remotes, **sync_options)\n</code></pre>"},{"location":"reference/enderchest/craft/#enderchest.craft.craft_ender_chest_from_config","title":"<code>craft_ender_chest_from_config(config)</code>","text":"<p>Craft the EnderChest folder structure and set up the sync scripts based on the contents of a config file</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config or path</code> <p>The path to a config file, or the parsed config itself</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>enderchest/craft.py</code> <pre><code>def craft_ender_chest_from_config(config: Config | str | os.PathLike) -&gt; None:\n\"\"\"Craft the EnderChest folder structure and set up the sync scripts based on the\n    contents of a config file\n\n    Parameters\n    ----------\n    config : Config or path\n        The path to a config file, or the parsed config itself\n\n    Returns\n    -------\n    None\n    \"\"\"\n    if not isinstance(config, Config):\n        config = parse_config_file(config)\n    craft_ender_chest(config.local_root, *config.remotes, **config.craft_options)\n</code></pre>"},{"location":"reference/enderchest/place/","title":"place","text":"<p>Utilities for performing the linking</p>"},{"location":"reference/enderchest/place/#enderchest.place.link_instance","title":"<code>link_instance(resource_path, instance_folder, destination, check_exists=True)</code>","text":"<p>Create a symlink for the specified resource from an instance's space pointing to the tagged file / folder living in the EnderChest folder.</p> <p>Parameters:</p> Name Type Description Default <code>resource_path</code> <code>str</code> <p>Location of the resource relative to the instance's \".minecraft\" folder</p> required <code>instance_folder</code> <code>Path</code> <p>the instance's folder (parent of \".minecraft\")</p> required <code>destination</code> <code>Path</code> <p>the location to link, where the file or older actually lives (inside the EnderChest folder)</p> required <code>check_exists</code> <code>bool, optional</code> <p>By default, this method will only create links if a \".minecraft\" folder exists in the instance_folder. To create links regardless, pass check_exists=False</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/enderchest/place/#enderchest.place.link_instance--notes","title":"Notes","text":"<ul> <li>This method will create any folders that do not exist within an instance, but only   if the instance folder exists and has contains a \".minecraft\" folder or if   check_exists is set to False</li> <li>This method will overwrite existing symlinks but will not overwrite any actual   files.</li> </ul> Source code in <code>enderchest/place.py</code> <pre><code>def link_instance(\n    resource_path: str, instance_folder: Path, destination: Path, check_exists=True\n) -&gt; None:\n\"\"\"Create a symlink for the specified resource from an instance's space pointing to\n    the tagged file / folder living in the EnderChest folder.\n\n    Parameters\n    ----------\n    resource_path : str\n        Location of the resource relative to the instance's \".minecraft\" folder\n    instance_folder : Path\n        the instance's folder (parent of \".minecraft\")\n    destination : Path\n        the location to link, where the file or older actually lives (inside the\n        EnderChest folder)\n    check_exists : bool, optional\n        By default, this method will only create links if a \".minecraft\" folder exists\n        in the instance_folder. To create links regardless, pass check_exists=False\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    - This method will create any folders that do not exist within an instance, but only\n      if the instance folder exists and has contains a \".minecraft\" folder *or* if\n      check_exists is set to False\n    - This method will overwrite existing symlinks but will not overwrite any actual\n      files.\n    \"\"\"\n    if not (instance_folder / \".minecraft\").exists() and check_exists:\n        return\n\n    instance_file = instance_folder / \".minecraft\" / resource_path\n    instance_file.parent.mkdir(parents=True, exist_ok=True)\n    relative_path = os.path.relpath(destination, instance_file.parent)\n    if instance_file.is_symlink():\n        # remove previous symlink in this spot\n        instance_file.unlink()\n    os.symlink(relative_path, instance_file)\n</code></pre>"},{"location":"reference/enderchest/place/#enderchest.place.link_server","title":"<code>link_server(resource_path, server_folder, destination, check_exists=True)</code>","text":"<p>Create a symlink for the specified resource from an server's space pointing to the tagged file / folder living in the EnderChest folder.</p> <p>Parameters:</p> Name Type Description Default <code>resource_path</code> <code>str</code> <p>Location of the resource relative to the instance's \".minecraft\" folder</p> required <code>server_folder</code> <code>Path</code> <p>the server's  folder</p> required <code>destination</code> <code>Path</code> <p>the location to link, where the file or older actually lives (inside the EnderChest folder)</p> required <code>check_exists</code> <code>bool, optional</code> <p>By default, this method will only create links if the server_folder exists. To create links regardless, pass check_exists=False</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/enderchest/place/#enderchest.place.link_server--notes","title":"Notes","text":"<ul> <li>This method will create any folders that do not exist within a server folder</li> <li>This method will overwrite existing symlinks but will not overwrite any actual   files</li> </ul> Source code in <code>enderchest/place.py</code> <pre><code>def link_server(\n    resource_path: str, server_folder: Path, destination: Path, check_exists=True\n) -&gt; None:\n\"\"\"Create a symlink for the specified resource from an server's space pointing to\n    the tagged file / folder living in the EnderChest folder.\n\n    Parameters\n    ----------\n    resource_path : str\n        Location of the resource relative to the instance's \".minecraft\" folder\n    server_folder : Path\n        the server's  folder\n    destination : Path\n        the location to link, where the file or older actually lives (inside the\n        EnderChest folder)\n    check_exists : bool, optional\n        By default, this method will only create links if the server_folder exists.\n        To create links regardless, pass check_exists=False\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    - This method will create any folders that do not exist within a server folder\n    - This method will overwrite existing symlinks but will not overwrite any actual\n      files\n    \"\"\"\n    if not server_folder.exists() and check_exists:\n        return\n    server_file = server_folder / resource_path\n    server_file.parent.mkdir(parents=True, exist_ok=True)\n    relative_path = os.path.relpath(destination, server_file.parent)\n    if server_file.is_symlink():\n        # remove previous symlink in this spot\n        server_file.unlink()\n    os.symlink(relative_path, server_file)\n</code></pre>"},{"location":"reference/enderchest/place/#enderchest.place.place_enderchest","title":"<code>place_enderchest(root, cleanup=True)</code>","text":"<p>Link all instance files and folders</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>path</code> <p>The root directory that contains the EnderChest directory, instances and servers</p> required <code>cleanup</code> <code>bool, optional</code> <p>By default, this method will remove any broken links in your instances and servers folders. To disable this behavior, pass in cleanup=False</p> <code>True</code> Source code in <code>enderchest/place.py</code> <pre><code>def place_enderchest(root: str | os.PathLike, cleanup: bool = True) -&gt; None:\n\"\"\"Link all instance files and folders\n\n    Parameters\n    ----------\n    root : path\n        The root directory that contains the EnderChest directory, instances and servers\n    cleanup : bool, optional\n        By default, this method will remove any broken links in your instances and\n        servers folders. To disable this behavior, pass in cleanup=False\n    \"\"\"\n    instances = Path(root) / \"instances\"\n    servers = Path(root) / \"servers\"\n    for context_type, context_root in contexts(root)._asdict().items():\n        make_server_links = context_type in (\"universal\", \"server_only\")\n        make_instance_links = context_type in (\"universal\", \"client_only\", \"local_only\")\n        assets = sorted(context_root.rglob(\"*@*\"))\n        for asset in assets:\n            if not asset.exists():\n                continue\n            path, *tags = str(asset.relative_to(context_root)).split(\"@\")\n            for tag in tags:\n                if make_instance_links:\n                    link_instance(path, instances / tag, asset)\n                if make_server_links:\n                    link_server(path, servers / _tokenize_server_name(tag), asset)\n    if cleanup:\n        for file in (*instances.rglob(\"*\"), *servers.rglob(\"*\")):\n            if not file.exists():\n                file.unlink()\n</code></pre>"},{"location":"reference/enderchest/sync/","title":"sync","text":"<p>Utilities for synchronizing chests across different computers</p>"},{"location":"reference/enderchest/sync/#enderchest.sync.Remote","title":"<code>Remote</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Specification of a remote EnderChest installation to sync with using rsync over ssh (other protocols are not explicitly supported).</p> <p>Attributes:</p> Name Type Description <code>host</code> <code>str</code> <p>The address (e.g. 127.0.0.1) or cname/URL (e.g. steamdeck.local) of the host you're syncing with.</p> <code>root</code> <code>path</code> <p>The root directory on the remote machine that contains all your minecraft stuff. Explicitly expects that the folder contains: your EnderChest folder; your Multi-MC-style instances folder; your servers.</p> <code>username</code> <code>str, optional</code> <p>The username for logging onto the remote machine. If None is specified on instantiation, it's assumed that you don't need a username to log into the server from this local.</p> <code>alias</code> <code>str</code> <p>A shorthand way to refer to the remote installation. If None is specified on instantiation, this will be the same as the host attribute.</p> <code>remote_folder</code> <code>str</code> <p>The full specification of the remote root, e.g. deck@steamdeck.local:~/minecraft</p>"},{"location":"reference/enderchest/sync/#enderchest.sync.Remote--notes","title":"Notes","text":"<p>This class is not designed to be safe against injection attacks and has none of the protections you'd get out of using, say, the urllib.parse module.</p> Source code in <code>enderchest/sync.py</code> <pre><code>class Remote(NamedTuple):\n\"\"\"Specification of a remote EnderChest installation to sync with using rsync over\n    ssh (other protocols are not explicitly supported).\n\n    Attributes\n    ----------\n    host : str\n        The address (_e.g._ 127.0.0.1) or cname/URL (_e.g._ steamdeck.local) of the\n        host you're syncing with.\n    root : path\n        The root directory on the remote machine that contains all your minecraft stuff.\n        Explicitly expects that the folder contains: your EnderChest folder;\n        your Multi-MC-style instances folder; your servers.\n    username : str, optional\n        The username for logging onto the remote machine. If None is specified on\n        instantiation, it's assumed that you don't need a username to log into the\n        server from this local.\n    alias : str\n        A shorthand way to refer to the remote installation. If None is specified on\n        instantiation, this will be the same as the host attribute.\n    remote_folder : str\n        The full specification of the remote root, _e.g._\n        deck@steamdeck.local:~/minecraft\n\n    Notes\n    -----\n    This class is not designed to be safe against injection attacks and has none of the\n    protections you'd get out of using, say, the urllib.parse module.\n    \"\"\"\n\n    host: str | None  # intentionally not in the docstring to use None for local mirror\n    root: str | os.PathLike\n    username: str | None = None\n    alias_: str | None = None\n\n    @property\n    def alias(self) -&gt; str:\n        return self.alias_ or self.host or Path(self.root).name\n\n    @property\n    def _encoded_root(self) -&gt; str:\n\"\"\"Shell-script safe version of the root folder.\n\n        Notes\n        -----\n        Can't just use shlex.quote directly because it tries to quote \"~\"\n        \"\"\"\n        root_string = str(self.root)\n        if root_string == \"~\":\n            return root_string\n        if root_string.startswith(\"~/\"):\n            return \"~/\" + shlex.quote(root_string[2:])\n        return shlex.quote(root_string)\n\n    @property\n    def remote_folder(self) -&gt; str:\n        if not self.host:\n            # then the \"remote\" is actually local\n            return self._encoded_root\n        if not self.username:\n            url = shlex.quote(self.host)\n        else:\n            url = f\"{self.username}@{shlex.quote(self.host)}\"\n        return f\"{url}:{self._encoded_root}\"\n\n    @classmethod\n    def from_string(cls, oneline_spec: str) -&gt; \"Remote\":\n        match oneline_spec.split(\":\"):\n            case [root]:\n                address: str | None = None\n            case address, *root:\n                root = \":\".join(root)\n            case _:\n                raise ValueError(f\"Unable to parse {oneline_spec} into a remote spec\")\n        if address is None:\n            username: str | None = None\n            host: str | None = None\n        else:\n            match address.split(\"@\"):\n                case [host]:\n                    username = None\n                case username, host:\n                    pass\n                case _:\n                    raise ValueError(\n                        f\"Unable to parse {oneline_spec} into a remote spec\"\n                    )\n        return Remote(host, root, username)\n</code></pre>"},{"location":"reference/enderchest/sync/#enderchest.sync.RemoteSync","title":"<code>RemoteSync</code>  <code>dataclass</code>","text":"<p>A specification of a remote and the commands to run pre- and post- syncing with the remote\"</p> <p>Attributes:</p> Name Type Description <code>remote</code> <code>Remote</code> <p>The remote to sync</p> <code>pre_open</code> <code>list of str</code> <p>Any commands to run before pulling in EnderChest changes from the remote</p> <code>pre_close</code> <code>list of str</code> <p>Any commands to run before pushing EnderChest changes to the remote</p> <code>post_open</code> <code>list of str</code> <p>Any commands to run after pulling in EnderChest changes from the remote</p> <code>post_close</code> <code>list of str</code> <p>Any commands to run after pushing EnderChest changes to the remote</p> Source code in <code>enderchest/sync.py</code> <pre><code>@dataclass\nclass RemoteSync:\n\"\"\"\n    A specification of a remote and the commands to run pre- and post- syncing\n    with the remote\"\n\n    Attributes\n    ----------\n    remote : Remote\n        The remote to sync\n    pre_open: list of str\n        Any commands to run before pulling in EnderChest changes from the remote\n    pre_close: list of str\n        Any commands to run before pushing EnderChest changes to the remote\n    post_open: list of str\n        Any commands to run after pulling in EnderChest changes from the remote\n    post_close: list of str\n        Any commands to run after pushing EnderChest changes to the remote\n    \"\"\"\n\n    remote: Remote\n    pre_open: Sequence[str] = field(default_factory=list)\n    pre_close: Sequence[str] = field(default_factory=list)\n    post_open: Sequence[str] = field(default_factory=list)\n    post_close: Sequence[str] = field(default_factory=list)\n</code></pre>"},{"location":"reference/enderchest/sync/#enderchest.sync.link_to_other_chests","title":"<code>link_to_other_chests(local_root, *remotes, local_alias=None, overwrite=False, omit_scare_message=False, pre_open=None, pre_close=None, post_open=None, post_close=None)</code>","text":"<p>Generate bash scripts for syncing to EnderChest installations on other computers. These will be saved in your EnderChest/local-only folder under <code>open.sh</code> (for pulling from remotes) and <code>close.sh</code> (for pushing to other remotes)</p> <p>Parameters:</p> Name Type Description Default <code>local_root</code> <code>path</code> <p>The local root directory that contains both the EnderChest directory, instances and servers</p> required <code>*remotes</code> <code>Remotes</code> <p>The remote installations to sync with</p> <code>()</code> <code>local_alias</code> <code>str, optional</code> <p>A shorthand way to refer to the local installation. This is what determines the name of the local settings backup folder inside remote \"other-locals\" folders. If None is specified, this computer's hostname will be used.</p> <code>None</code> <code>overwrite</code> <code>bool, optional</code> <p>By default, if an open/close script exists, this method will leave it alone. To instead overwrite any existing scripts, explicitly pass in the keyword argument overwrite=True</p> <code>False</code> <code>omit_scare_message</code> <code>bool, optional</code> <p>By default, the scripts this method generates are not runnable and tell the user to first open them in a text editor and look them over. If you really really trust this method and the use of it, pass in the keyword argument omit_scare_message=True to omit this safeguard and just make them runnable from the get-go.</p> <code>False</code> <code>pre_open</code> <code>Sequence[str] | None</code> <p>Any commands to run before pulling in EnderChest changes from the remotes</p> <code>None</code> <code>pre_close</code> <code>Sequence[str] | None</code> <p>Any commands to run before pushing EnderChest changes to the remotes</p> <code>None</code> <code>post_open</code> <code>Sequence[str] | None</code> <p>Any commands to run after pulling in EnderChest changes from the remotes</p> <code>None</code> <code>post_close</code> <code>Sequence[str] | None</code> <p>Any commands to run after pushing EnderChest changes to the remotes</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/enderchest/sync/#enderchest.sync.link_to_other_chests--warnings","title":"Warnings","text":"<p>If one of the scripts already exists, this method will emit a warning that generation of a new script is being kipped (if overwrite=True is not specified) or that the old script is being overwritten (if this method is called with overwrite=True).</p>"},{"location":"reference/enderchest/sync/#enderchest.sync.link_to_other_chests--notes","title":"Notes","text":"<ul> <li>This method is designed for flexibility and transparency over robustness and ease   of use. That means that you need to open the scripts this function generates   and look them over before ou can actually run them. This also gives you a chance   add your own tweaks and customizations before embedding the syncing into your   automations.</li> <li>The remotes are assumed to be specified in priority order   (top priority first), meaning the first remote:</li> <li>will be the first to receive local changes</li> <li>will be the first to try pulling remote changes from</li> </ul> Source code in <code>enderchest/sync.py</code> <pre><code>def link_to_other_chests(\n    local_root: str | os.PathLike,\n    *remotes: Remote | RemoteSync,\n    local_alias: str | None = None,\n    overwrite: bool = False,\n    omit_scare_message: bool = False,\n    pre_open: Sequence[str] | None = None,\n    pre_close: Sequence[str] | None = None,\n    post_open: Sequence[str] | None = None,\n    post_close: Sequence[str] | None = None,\n) -&gt; None:\n\"\"\"Generate bash scripts for syncing to EnderChest installations on other computers.\n    These will be saved in your EnderChest/local-only folder under `open.sh`\n    (for pulling from remotes) and `close.sh` (for pushing to other remotes)\n\n    Parameters\n    ----------\n    local_root : path\n        The local root directory that contains both the EnderChest directory, instances\n        and servers\n    *remotes : Remotes / RemoteSyncs\n        The remote installations to sync with\n    local_alias : str, optional\n        A shorthand way to refer to the local installation. This is what determines the\n        name of the local settings backup folder inside remote \"other-locals\" folders.\n        If None is specified, this computer's hostname will be used.\n    overwrite : bool, optional\n        By default, if an open/close script exists, this method will leave it alone.\n        To instead overwrite any existing scripts, explicitly pass in the keyword\n        argument overwrite=True\n    omit_scare_message : bool, optional\n        By default, the scripts this method generates are not runnable and tell the user\n        to first open them in a text editor and look them over. If you *really really\n        trust* this method and the use of it, pass in the keyword argument\n        omit_scare_message=True to omit this safeguard and just make them runnable from\n        the get-go.\n    pre_open: list of str, optional\n        Any commands to run before pulling in EnderChest changes from the remotes\n    pre_close: list of str, optional\n        Any commands to run before pushing EnderChest changes to the remotes\n    post_open: list of str, optional\n        Any commands to run after pulling in EnderChest changes from the remotes\n    post_close: list of str, optional\n        Any commands to run after pushing EnderChest changes to the remotes\n\n    Returns\n    -------\n    None\n\n    Warnings\n    --------\n    If one of the scripts already exists, this method will emit a warning that\n    generation of a new script is being kipped (if overwrite=True is not specified) or\n    that the old script is being overwritten (if this method is called with\n    overwrite=True).\n\n    Notes\n    -----\n    - This method is designed for flexibility and transparency over robustness and ease\n      of use. That means that **you need to open the scripts this function generates**\n      and look them over before ou can actually run them. This also gives you a chance\n      add your own tweaks and customizations before embedding the syncing into your\n      automations.\n    - The remotes are assumed to be specified in **priority order**\n      (top priority first), meaning the first remote:\n      - will be the first to receive local changes\n      - will be the first to try pulling remote changes from\n    \"\"\"\n    open_script = HEADER\n    close_script = HEADER\n\n    if not omit_scare_message:\n        open_script += SCARE_MESSAGE\n        close_script += SCARE_MESSAGE\n\n    open_script += \"\\n\"\n\n    if pre_open:\n        open_script += \"\".join([f\"{command}\\n\" for command in pre_open])\n    if pre_close:\n        close_script += \"\".join([f\"{command}\\n\" for command in pre_close])\n\n    for remote in remotes:\n        yeet, yoink = _build_rsync_scripts(\n            local_root, local_alias or socket.gethostname(), remote\n        )\n        close_script += \"\\n\" + yeet\n        open_script += \"{\\n    \" + \"\\n    \".join(yoink.split(\"\\n\")[:-1]) + \"\\n} || \"\n\n    open_script += \"\"\"{\n    echo \"Could not pull changes from any remote EnderChests.\"\n    echo \"Are you outside your local network?\"\n    exit 1\n}\n\"\"\"\n\n    if post_open:\n        open_script += \"\".join([f\"{command}\\n\" for command in post_open])\n    if post_close:\n        close_script += \"\".join([f\"{command}\\n\" for command in post_close])\n\n    for name, script in ((\"open\", open_script), (\"close\", close_script)):\n        script_path = contexts(local_root).local_only / f\"{name}.sh\"\n\n        if script_path.exists():\n            warning_message = f\"{name.title()} script already exists.\"\n\n            if not overwrite:\n                warning_message += \" Skipping.\"\n                warnings.warn(warning_message)\n                continue\n            else:\n                warning_message += \" Overwriting.\"\n                warnings.warn(warning_message)\n\n        script_path.write_text(script)\n        script_path.chmod(script_path.stat().st_mode | stat.S_IEXEC)\n</code></pre>"}]}