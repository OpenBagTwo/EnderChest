{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EnderChest syncing and linking for all your Minecraft instances","title":"Home"},{"location":"#enderchest","text":"syncing and linking for all your Minecraft instances","title":"EnderChest"},{"location":"about/","text":"About Me Hello!","title":"About"},{"location":"about/#about-me","text":"Hello!","title":"About Me"},{"location":"reference/SUMMARY/","text":"enderchest place craft sync cli config","title":"SUMMARY"},{"location":"reference/enderchest/","text":"contexts ( root ) Centrally define context directories based on the root folder Returns: Type Description Tuple of Paths The contexts, in order, - global : for syncing across all instances and servers - client-only : for syncing across all client instances - server-only : for syncing across all server instances - local-only : for local use only (don't sync) - other-locals : \"local-only\" folders from other installations (for distributed backups) Notes Because \"global\" is a restricted keyword in Python, the namedtuple key for this context is \"universal\" For all other contexts, the namedtuple key replaces a dash (not a valid token character) with an underscore ` Source code in enderchest/__init__.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def contexts ( root : str | os . PathLike ) -> Contexts : \"\"\"Centrally define context directories based on the root folder Returns ------- Tuple of Paths The contexts, in order, - global : for syncing across all instances and servers - client-only : for syncing across all client instances - server-only : for syncing across all server instances - local-only : for local use only (don't sync) - other-locals : \"local-only\" folders from other installations (for distributed backups) Notes ----- - Because \"global\" is a restricted keyword in Python, the namedtuple key for this context is \"universal\" - For all other contexts, the namedtuple key replaces a dash (not a valid token character) with an underscore ` \"\"\" ender_chest = Path ( root ) . expanduser () . resolve () / \"EnderChest\" return Contexts ( ender_chest / \"global\" , ender_chest / \"client-only\" , ender_chest / \"server-only\" , ender_chest / \"local-only\" , ender_chest / \"other-locals\" , )","title":"enderchest"},{"location":"reference/enderchest/#enderchest.contexts","text":"Centrally define context directories based on the root folder Returns: Type Description Tuple of Paths The contexts, in order, - global : for syncing across all instances and servers - client-only : for syncing across all client instances - server-only : for syncing across all server instances - local-only : for local use only (don't sync) - other-locals : \"local-only\" folders from other installations (for distributed backups)","title":"contexts()"},{"location":"reference/enderchest/#enderchest.contexts--notes","text":"Because \"global\" is a restricted keyword in Python, the namedtuple key for this context is \"universal\" For all other contexts, the namedtuple key replaces a dash (not a valid token character) with an underscore ` Source code in enderchest/__init__.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def contexts ( root : str | os . PathLike ) -> Contexts : \"\"\"Centrally define context directories based on the root folder Returns ------- Tuple of Paths The contexts, in order, - global : for syncing across all instances and servers - client-only : for syncing across all client instances - server-only : for syncing across all server instances - local-only : for local use only (don't sync) - other-locals : \"local-only\" folders from other installations (for distributed backups) Notes ----- - Because \"global\" is a restricted keyword in Python, the namedtuple key for this context is \"universal\" - For all other contexts, the namedtuple key replaces a dash (not a valid token character) with an underscore ` \"\"\" ender_chest = Path ( root ) . expanduser () . resolve () / \"EnderChest\" return Contexts ( ender_chest / \"global\" , ender_chest / \"client-only\" , ender_chest / \"server-only\" , ender_chest / \"local-only\" , ender_chest / \"other-locals\" , )","title":"Notes"},{"location":"reference/enderchest/cli/","text":"Command-line interface PassThroughParser Command-line argument parser that just collects any (non --help) flags into a list of arguments Source code in enderchest/cli.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 class PassThroughParser : \"\"\"Command-line argument parser that just collects any (non --help) flags into a list of arguments\"\"\" def __init__ ( self , ** argparse_kwargs ): self . _parser = argparse . ArgumentParser ( ** argparse_kwargs ) def add_argument ( self , * args , ** kwargs ): self . _parser . add_argument ( * args , ** kwargs ) def parse_args ( self , args ) -> argparse . Namespace : if \"-h\" in args or \"--help\" in args : return self . _parser . parse_args ([ \"--help\" ]) root : Path | None = None if len ( args ) > 0 and not args [ 0 ] . startswith ( \"-\" ): try : root = Path ( args [ 0 ]) args = args [ 1 :] except ( TypeError , AttributeError ): # then hopefully it wasn't intended to be a path pass root = root or Path ( os . getcwd ()) dummy_namespace = argparse . Namespace () dummy_namespace . __dict__ = { \"root\" : root , \"command_line_args\" : args } return dummy_namespace parse_args ( argv ) Parse the provided command-line options to determine the action to perform and the arguments to pass to the action Parameters: Name Type Description Default argv list-like of str (sys.argv) The options passed into the command line required Returns: Type Description Callable The action method that will be called str The root of the minecraft folder (parent of the EnderChest) where the action will be perfomed dict Any additional options that will be given to the action method Source code in enderchest/cli.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def parse_args ( argv : Sequence [ str ]) -> tuple [ _Action , str , dict [ str , Any ]]: \"\"\"Parse the provided command-line options to determine the action to perform and the arguments to pass to the action Parameters ---------- argv : list-like of str (sys.argv) The options passed into the command line Returns ------- Callable The action method that will be called str The root of the minecraft folder (parent of the EnderChest) where the action will be perfomed dict Any additional options that will be given to the action method \"\"\" actions : dict [ str , _Action ] = {} descriptions : dict [ str , str ] = {} root_description : str = \"\" for name , description , method in ACTIONS : actions [ name ] = method descriptions [ name ] = description root_description += f \" \\n\\t { name } : to { description } \" enderchest_parser = argparse . ArgumentParser ( prog = \"enderchest\" , description = ( f \"v { __version__ } \\n \" \" \\n syncing and linking for all your Minecraft instances\" ), formatter_class = argparse . RawTextHelpFormatter , ) enderchest_parser . add_argument ( \"action\" , help = f \"the action to perform. Options are: { root_description } \" , type = str , choices = actions . keys (), ) enderchest_parser . add_argument ( \"arguments\" , nargs = \"*\" , help = \"any additional arguments for the specific action.\" \" To learn more, try: enderchest {action} -h\" , ) action_parsers : dict [ str , argparse . ArgumentParser | PassThroughParser ] = {} for command in actions . keys (): if command in ( \"open\" , \"close\" ): parser : argparse . ArgumentParser | PassThroughParser = PassThroughParser ( prog = f \"enderchest { command } \" , description = descriptions [ command ] ) else : parser = argparse . ArgumentParser ( prog = f \"enderchest { command } \" , description = descriptions [ command ] ) parser . add_argument ( \"root\" , nargs = \"?\" , help = ( \"optionally specify your root minecraft directory.\" \" If no path is given, the current working directory will be used.\" ), type = Path , default = Path ( os . getcwd ()), ) action_parsers [ command ] = parser action_parsers [ \"craft\" ] . add_argument ( \"-r\" , \"--remote\" , dest = \"remotes\" , action = \"append\" , help = \"specify a remote enderchest installation using the syntax\" \" [user@]addreess:/path/to/enderchest\" , ) action_parsers [ \"craft\" ] . add_argument ( \"-f\" , \"--file\" , dest = \"config_file\" , action = \"store\" , type = Path , help = \"parse the enderchest installations to sync with from\" \" the specified config file\" , ) action_parsers [ \"craft\" ] . add_argument ( \"--overwrite\" , action = \"store_true\" , help = \"overwrite any existing sync scripts\" , ) action_parsers [ \"place\" ] . add_argument ( \"-k\" , \"--keep-broken\" , action = \"store_false\" , dest = \"cleanup\" , help = \"do not remove broken links when performing place\" , ) for command in ( \"open\" , \"close\" ): action_parsers [ command ] . add_argument ( \"command_line_args\" , nargs = \"*\" , help = \"any additional arguments to pass through to the script\" , ) root_args = enderchest_parser . parse_args ( argv [ 1 : 2 ]) action : _Action = actions [ root_args . action ] action_kwargs = vars ( action_parsers [ root_args . action ] . parse_args ( argv [ 2 :])) root = action_kwargs . pop ( \"root\" ) return action , root , action_kwargs","title":"cli"},{"location":"reference/enderchest/cli/#enderchest.cli.PassThroughParser","text":"Command-line argument parser that just collects any (non --help) flags into a list of arguments Source code in enderchest/cli.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 class PassThroughParser : \"\"\"Command-line argument parser that just collects any (non --help) flags into a list of arguments\"\"\" def __init__ ( self , ** argparse_kwargs ): self . _parser = argparse . ArgumentParser ( ** argparse_kwargs ) def add_argument ( self , * args , ** kwargs ): self . _parser . add_argument ( * args , ** kwargs ) def parse_args ( self , args ) -> argparse . Namespace : if \"-h\" in args or \"--help\" in args : return self . _parser . parse_args ([ \"--help\" ]) root : Path | None = None if len ( args ) > 0 and not args [ 0 ] . startswith ( \"-\" ): try : root = Path ( args [ 0 ]) args = args [ 1 :] except ( TypeError , AttributeError ): # then hopefully it wasn't intended to be a path pass root = root or Path ( os . getcwd ()) dummy_namespace = argparse . Namespace () dummy_namespace . __dict__ = { \"root\" : root , \"command_line_args\" : args } return dummy_namespace","title":"PassThroughParser"},{"location":"reference/enderchest/cli/#enderchest.cli.parse_args","text":"Parse the provided command-line options to determine the action to perform and the arguments to pass to the action Parameters: Name Type Description Default argv list-like of str (sys.argv) The options passed into the command line required Returns: Type Description Callable The action method that will be called str The root of the minecraft folder (parent of the EnderChest) where the action will be perfomed dict Any additional options that will be given to the action method Source code in enderchest/cli.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def parse_args ( argv : Sequence [ str ]) -> tuple [ _Action , str , dict [ str , Any ]]: \"\"\"Parse the provided command-line options to determine the action to perform and the arguments to pass to the action Parameters ---------- argv : list-like of str (sys.argv) The options passed into the command line Returns ------- Callable The action method that will be called str The root of the minecraft folder (parent of the EnderChest) where the action will be perfomed dict Any additional options that will be given to the action method \"\"\" actions : dict [ str , _Action ] = {} descriptions : dict [ str , str ] = {} root_description : str = \"\" for name , description , method in ACTIONS : actions [ name ] = method descriptions [ name ] = description root_description += f \" \\n\\t { name } : to { description } \" enderchest_parser = argparse . ArgumentParser ( prog = \"enderchest\" , description = ( f \"v { __version__ } \\n \" \" \\n syncing and linking for all your Minecraft instances\" ), formatter_class = argparse . RawTextHelpFormatter , ) enderchest_parser . add_argument ( \"action\" , help = f \"the action to perform. Options are: { root_description } \" , type = str , choices = actions . keys (), ) enderchest_parser . add_argument ( \"arguments\" , nargs = \"*\" , help = \"any additional arguments for the specific action.\" \" To learn more, try: enderchest {action} -h\" , ) action_parsers : dict [ str , argparse . ArgumentParser | PassThroughParser ] = {} for command in actions . keys (): if command in ( \"open\" , \"close\" ): parser : argparse . ArgumentParser | PassThroughParser = PassThroughParser ( prog = f \"enderchest { command } \" , description = descriptions [ command ] ) else : parser = argparse . ArgumentParser ( prog = f \"enderchest { command } \" , description = descriptions [ command ] ) parser . add_argument ( \"root\" , nargs = \"?\" , help = ( \"optionally specify your root minecraft directory.\" \" If no path is given, the current working directory will be used.\" ), type = Path , default = Path ( os . getcwd ()), ) action_parsers [ command ] = parser action_parsers [ \"craft\" ] . add_argument ( \"-r\" , \"--remote\" , dest = \"remotes\" , action = \"append\" , help = \"specify a remote enderchest installation using the syntax\" \" [user@]addreess:/path/to/enderchest\" , ) action_parsers [ \"craft\" ] . add_argument ( \"-f\" , \"--file\" , dest = \"config_file\" , action = \"store\" , type = Path , help = \"parse the enderchest installations to sync with from\" \" the specified config file\" , ) action_parsers [ \"craft\" ] . add_argument ( \"--overwrite\" , action = \"store_true\" , help = \"overwrite any existing sync scripts\" , ) action_parsers [ \"place\" ] . add_argument ( \"-k\" , \"--keep-broken\" , action = \"store_false\" , dest = \"cleanup\" , help = \"do not remove broken links when performing place\" , ) for command in ( \"open\" , \"close\" ): action_parsers [ command ] . add_argument ( \"command_line_args\" , nargs = \"*\" , help = \"any additional arguments to pass through to the script\" , ) root_args = enderchest_parser . parse_args ( argv [ 1 : 2 ]) action : _Action = actions [ root_args . action ] action_kwargs = vars ( action_parsers [ root_args . action ] . parse_args ( argv [ 2 :])) root = action_kwargs . pop ( \"root\" ) return action , root , action_kwargs","title":"parse_args()"},{"location":"reference/enderchest/config/","text":"Logic for parsing configuration files Config The configuration spec for the EnderChest package Attributes: Name Type Description local_root str The path on the local installation of the minecraft directory (which should / will contain the EnderChest folder, along with the instances and servers directories) remotes list-like of RemoteSync The specifications of the remote EnderChest installations to sync with, complete with any wrapper commands craft_options dict Any additional options to pass to the craft command Source code in enderchest/config.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 class Config : \"\"\"The configuration spec for the EnderChest package Attributes ---------- local_root : str The path on the local installation of the minecraft directory (which should / will contain the EnderChest folder, along with the instances and servers directories) remotes : list-like of RemoteSync The specifications of the remote EnderChest installations to sync with, complete with any wrapper commands craft_options: dict Any additional options to pass to the craft command \"\"\" @classmethod def _default_craft_options ( cls ) -> dict : \"\"\"The default craft options if None are specified. Note that providing *any* value to craft_options will completely replace this dict\"\"\" # TODO: figure out how to to have return { \"local_alias\" : None , \"pre_open\" : [], \"pre_close\" : [], \"post_open\" : [], \"post_close\" : [], } def __init__ ( self , local_root : str , remotes : Sequence [ RemoteSync ], craft_options : dict [ str , Any ] | None = None , ): self . local_root = local_root self . remotes = remotes self . craft_options = Config . _default_craft_options () if craft_options : self . craft_options . update ( craft_options ) @property def _config ( self ) -> ConfigParser : parser = ConfigParser () local : dict [ str , str ] = { \"root\" : self . local_root } if alias := self . craft_options [ \"local_alias\" ]: local [ \"name\" ] = alias parser [ \"local\" ] = local options : dict [ str , Any ] = {} for keyword , value in self . craft_options . items (): if keyword == \"local_alias\" : continue if keyword in ( \"pre_open\" , \"pre_close\" , \"post_open\" , \"post_close\" ): options [ keyword ] = json . dumps ( value ) else : options [ keyword ] = value parser [ \"options\" ] = options for remote_sync in self . remotes : remote = remote_sync . remote remote_spec : dict [ str , str ] = { \"host\" : remote . host if remote . host else \"\" , \"root\" : str ( remote . root ), } if username := remote . username : remote_spec [ \"username\" ] = username for wrapper in ( \"pre_open\" , \"pre_close\" , \"post_open\" , \"post_close\" ): if commands := getattr ( remote_sync , wrapper ): remote_spec [ wrapper ] = json . dumps ( commands ) parser [ remote . alias ] = remote_spec return parser @property def _asdict ( self ) -> dict [ str , Any ]: as_dict = {} for section in self . _config . sections (): as_dict [ section ] = { keyword : self . _config . get ( section , keyword ) for keyword in self . _config . options ( section ) } return as_dict def __repr__ ( self ) -> str : return repr ( self . _asdict ) def __eq__ ( self , other ) -> bool : try : return self . _asdict == other . _asdict except AttributeError : return self . _asdict == other parse_config ( contents ) Parse the contents of a config file Parameters: Name Type Description Default contents str The raw config file contents required Returns: Type Description Config The parsed config file contents Source code in enderchest/config.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def parse_config ( contents : str ) -> Config : \"\"\"Parse the contents of a config file Parameters ---------- contents : str The raw config file contents Returns ------- Config The parsed config file contents \"\"\" parser = ConfigParser () parser . read_string ( contents ) if \"local\" not in parser : raise ParsingError ( \"Configuration must contain a [local] section\" ) local_root , options = _parse_local_section ( parser [ \"local\" ]) if \"options\" in parser : more_options = _parse_options_section ( parser [ \"options\" ]) for option , value in more_options . items (): if option in ( \"pre_open\" , \"pre_close\" , \"post_open\" , \"post_close\" ): options [ option ] . extend ( value ) elif option in options and value != options [ option ]: raise ParsingError ( f \"Found conflicting values for { option } \" ) else : options [ option ] = value remotes = [ _parse_remote_section ( parser [ alias ]) for alias in parser . sections () if alias not in ( \"local\" , \"options\" ) ] return Config ( local_root , remotes , options ) parse_config_file ( config_path ) Parse a config file Parameters: Name Type Description Default config_path path The path to the config file required Returns: Type Description Config The parsed config file contents Source code in enderchest/config.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def parse_config_file ( config_path : str | os . PathLike ) -> Config : \"\"\"Parse a config file Parameters ---------- config_path : path The path to the config file Returns ------- Config The parsed config file contents \"\"\" with open ( config_path ) as config_file : return parse_config ( config_file . read ())","title":"config"},{"location":"reference/enderchest/config/#enderchest.config.Config","text":"The configuration spec for the EnderChest package Attributes: Name Type Description local_root str The path on the local installation of the minecraft directory (which should / will contain the EnderChest folder, along with the instances and servers directories) remotes list-like of RemoteSync The specifications of the remote EnderChest installations to sync with, complete with any wrapper commands craft_options dict Any additional options to pass to the craft command Source code in enderchest/config.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 class Config : \"\"\"The configuration spec for the EnderChest package Attributes ---------- local_root : str The path on the local installation of the minecraft directory (which should / will contain the EnderChest folder, along with the instances and servers directories) remotes : list-like of RemoteSync The specifications of the remote EnderChest installations to sync with, complete with any wrapper commands craft_options: dict Any additional options to pass to the craft command \"\"\" @classmethod def _default_craft_options ( cls ) -> dict : \"\"\"The default craft options if None are specified. Note that providing *any* value to craft_options will completely replace this dict\"\"\" # TODO: figure out how to to have return { \"local_alias\" : None , \"pre_open\" : [], \"pre_close\" : [], \"post_open\" : [], \"post_close\" : [], } def __init__ ( self , local_root : str , remotes : Sequence [ RemoteSync ], craft_options : dict [ str , Any ] | None = None , ): self . local_root = local_root self . remotes = remotes self . craft_options = Config . _default_craft_options () if craft_options : self . craft_options . update ( craft_options ) @property def _config ( self ) -> ConfigParser : parser = ConfigParser () local : dict [ str , str ] = { \"root\" : self . local_root } if alias := self . craft_options [ \"local_alias\" ]: local [ \"name\" ] = alias parser [ \"local\" ] = local options : dict [ str , Any ] = {} for keyword , value in self . craft_options . items (): if keyword == \"local_alias\" : continue if keyword in ( \"pre_open\" , \"pre_close\" , \"post_open\" , \"post_close\" ): options [ keyword ] = json . dumps ( value ) else : options [ keyword ] = value parser [ \"options\" ] = options for remote_sync in self . remotes : remote = remote_sync . remote remote_spec : dict [ str , str ] = { \"host\" : remote . host if remote . host else \"\" , \"root\" : str ( remote . root ), } if username := remote . username : remote_spec [ \"username\" ] = username for wrapper in ( \"pre_open\" , \"pre_close\" , \"post_open\" , \"post_close\" ): if commands := getattr ( remote_sync , wrapper ): remote_spec [ wrapper ] = json . dumps ( commands ) parser [ remote . alias ] = remote_spec return parser @property def _asdict ( self ) -> dict [ str , Any ]: as_dict = {} for section in self . _config . sections (): as_dict [ section ] = { keyword : self . _config . get ( section , keyword ) for keyword in self . _config . options ( section ) } return as_dict def __repr__ ( self ) -> str : return repr ( self . _asdict ) def __eq__ ( self , other ) -> bool : try : return self . _asdict == other . _asdict except AttributeError : return self . _asdict == other","title":"Config"},{"location":"reference/enderchest/config/#enderchest.config.parse_config","text":"Parse the contents of a config file Parameters: Name Type Description Default contents str The raw config file contents required Returns: Type Description Config The parsed config file contents Source code in enderchest/config.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def parse_config ( contents : str ) -> Config : \"\"\"Parse the contents of a config file Parameters ---------- contents : str The raw config file contents Returns ------- Config The parsed config file contents \"\"\" parser = ConfigParser () parser . read_string ( contents ) if \"local\" not in parser : raise ParsingError ( \"Configuration must contain a [local] section\" ) local_root , options = _parse_local_section ( parser [ \"local\" ]) if \"options\" in parser : more_options = _parse_options_section ( parser [ \"options\" ]) for option , value in more_options . items (): if option in ( \"pre_open\" , \"pre_close\" , \"post_open\" , \"post_close\" ): options [ option ] . extend ( value ) elif option in options and value != options [ option ]: raise ParsingError ( f \"Found conflicting values for { option } \" ) else : options [ option ] = value remotes = [ _parse_remote_section ( parser [ alias ]) for alias in parser . sections () if alias not in ( \"local\" , \"options\" ) ] return Config ( local_root , remotes , options )","title":"parse_config()"},{"location":"reference/enderchest/config/#enderchest.config.parse_config_file","text":"Parse a config file Parameters: Name Type Description Default config_path path The path to the config file required Returns: Type Description Config The parsed config file contents Source code in enderchest/config.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def parse_config_file ( config_path : str | os . PathLike ) -> Config : \"\"\"Parse a config file Parameters ---------- config_path : path The path to the config file Returns ------- Config The parsed config file contents \"\"\" with open ( config_path ) as config_file : return parse_config ( config_file . read ())","title":"parse_config_file()"},{"location":"reference/enderchest/craft/","text":"Utilities for setting up the folder structure craft_ender_chest ( root , * remotes , craft_folders_only = False , ** sync_options ) Create the EnderChest folder structure in the specified root directory as well as the sync scripts Parameters: Name Type Description Default root path The root directory to put the EnderChest folder structure into required *remotes Remotes The remote installations to sync with () craft_folders_only bool , optional If set to True, this method will only set up the EnderChest folders and will not create any sync scripts. False **sync_options Any additional arguments to pass to the sync.link_to_other_chests() {} Returns: Type Description None Source code in enderchest/craft.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def craft_ender_chest ( root : str | os . PathLike , * remotes : Remote | RemoteSync , craft_folders_only : bool = False , ** sync_options ) -> None : \"\"\"Create the EnderChest folder structure in the specified root directory as well as the sync scripts Parameters ---------- root : path The root directory to put the EnderChest folder structure into *remotes : Remotes / RemoteSyncs The remote installations to sync with craft_folders_only : bool, optional If set to True, this method will only set up the EnderChest folders and will not create any sync scripts. **sync_options Any additional arguments to pass to the sync.link_to_other_chests() Returns ------- None \"\"\" folders_for_contexts = _parse_folder_context_combos () for context_type , context_root in contexts ( root ) . _asdict () . items (): context_root . mkdir ( parents = True , exist_ok = True ) for folder in folders_for_contexts [ context_type ]: ( context_root / folder ) . mkdir ( parents = True , exist_ok = True ) if not craft_folders_only : link_to_other_chests ( root , * remotes , ** sync_options ) craft_ender_chest_from_config ( config ) Craft the EnderChest folder structure and set up the sync scripts based on the contents of a config file Parameters: Name Type Description Default config Config or path The path to a config file, or the parsed config itself required Returns: Type Description None Source code in enderchest/craft.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def craft_ender_chest_from_config ( config : Config | str | os . PathLike ) -> None : \"\"\"Craft the EnderChest folder structure and set up the sync scripts based on the contents of a config file Parameters ---------- config : Config or path The path to a config file, or the parsed config itself Returns ------- None \"\"\" if not isinstance ( config , Config ): config = parse_config_file ( config ) craft_ender_chest ( config . local_root , * config . remotes , ** config . craft_options )","title":"craft"},{"location":"reference/enderchest/craft/#enderchest.craft.craft_ender_chest","text":"Create the EnderChest folder structure in the specified root directory as well as the sync scripts Parameters: Name Type Description Default root path The root directory to put the EnderChest folder structure into required *remotes Remotes The remote installations to sync with () craft_folders_only bool , optional If set to True, this method will only set up the EnderChest folders and will not create any sync scripts. False **sync_options Any additional arguments to pass to the sync.link_to_other_chests() {} Returns: Type Description None Source code in enderchest/craft.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def craft_ender_chest ( root : str | os . PathLike , * remotes : Remote | RemoteSync , craft_folders_only : bool = False , ** sync_options ) -> None : \"\"\"Create the EnderChest folder structure in the specified root directory as well as the sync scripts Parameters ---------- root : path The root directory to put the EnderChest folder structure into *remotes : Remotes / RemoteSyncs The remote installations to sync with craft_folders_only : bool, optional If set to True, this method will only set up the EnderChest folders and will not create any sync scripts. **sync_options Any additional arguments to pass to the sync.link_to_other_chests() Returns ------- None \"\"\" folders_for_contexts = _parse_folder_context_combos () for context_type , context_root in contexts ( root ) . _asdict () . items (): context_root . mkdir ( parents = True , exist_ok = True ) for folder in folders_for_contexts [ context_type ]: ( context_root / folder ) . mkdir ( parents = True , exist_ok = True ) if not craft_folders_only : link_to_other_chests ( root , * remotes , ** sync_options )","title":"craft_ender_chest()"},{"location":"reference/enderchest/craft/#enderchest.craft.craft_ender_chest_from_config","text":"Craft the EnderChest folder structure and set up the sync scripts based on the contents of a config file Parameters: Name Type Description Default config Config or path The path to a config file, or the parsed config itself required Returns: Type Description None Source code in enderchest/craft.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def craft_ender_chest_from_config ( config : Config | str | os . PathLike ) -> None : \"\"\"Craft the EnderChest folder structure and set up the sync scripts based on the contents of a config file Parameters ---------- config : Config or path The path to a config file, or the parsed config itself Returns ------- None \"\"\" if not isinstance ( config , Config ): config = parse_config_file ( config ) craft_ender_chest ( config . local_root , * config . remotes , ** config . craft_options )","title":"craft_ender_chest_from_config()"},{"location":"reference/enderchest/place/","text":"Utilities for performing the linking link_instance ( resource_path , instance_folder , destination , check_exists = True ) Create a symlink for the specified resource from an instance's space pointing to the tagged file / folder living in the EnderChest folder. Parameters: Name Type Description Default resource_path str Location of the resource relative to the instance's \".minecraft\" folder required instance_folder Path the instance's folder (parent of \".minecraft\") required destination Path the location to link, where the file or older actually lives (inside the EnderChest folder) required check_exists bool , optional By default, this method will only create links if a \".minecraft\" folder exists in the instance_folder. To create links regardless, pass check_exists=False True Returns: Type Description None Notes This method will create any folders that do not exist within an instance, but only if the instance folder exists and has contains a \".minecraft\" folder or if check_exists is set to False This method will overwrite existing symlinks but will not overwrite any actual files. Source code in enderchest/place.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def link_instance ( resource_path : str , instance_folder : Path , destination : Path , check_exists = True ) -> None : \"\"\"Create a symlink for the specified resource from an instance's space pointing to the tagged file / folder living in the EnderChest folder. Parameters ---------- resource_path : str Location of the resource relative to the instance's \".minecraft\" folder instance_folder : Path the instance's folder (parent of \".minecraft\") destination : Path the location to link, where the file or older actually lives (inside the EnderChest folder) check_exists : bool, optional By default, this method will only create links if a \".minecraft\" folder exists in the instance_folder. To create links regardless, pass check_exists=False Returns ------- None Notes ----- - This method will create any folders that do not exist within an instance, but only if the instance folder exists and has contains a \".minecraft\" folder *or* if check_exists is set to False - This method will overwrite existing symlinks but will not overwrite any actual files. \"\"\" if not ( instance_folder / \".minecraft\" ) . exists () and check_exists : return instance_file = instance_folder / \".minecraft\" / resource_path instance_file . parent . mkdir ( parents = True , exist_ok = True ) relative_path = os . path . relpath ( destination , instance_file . parent ) if instance_file . is_symlink (): # remove previous symlink in this spot instance_file . unlink () os . symlink ( relative_path , instance_file ) link_server ( resource_path , server_folder , destination , check_exists = True ) Create a symlink for the specified resource from an server's space pointing to the tagged file / folder living in the EnderChest folder. Parameters: Name Type Description Default resource_path str Location of the resource relative to the instance's \".minecraft\" folder required server_folder Path the server's folder required destination Path the location to link, where the file or older actually lives (inside the EnderChest folder) required check_exists bool , optional By default, this method will only create links if the server_folder exists. To create links regardless, pass check_exists=False True Returns: Type Description None Notes This method will create any folders that do not exist within a server folder This method will overwrite existing symlinks but will not overwrite any actual files Source code in enderchest/place.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def link_server ( resource_path : str , server_folder : Path , destination : Path , check_exists = True ) -> None : \"\"\"Create a symlink for the specified resource from an server's space pointing to the tagged file / folder living in the EnderChest folder. Parameters ---------- resource_path : str Location of the resource relative to the instance's \".minecraft\" folder server_folder : Path the server's folder destination : Path the location to link, where the file or older actually lives (inside the EnderChest folder) check_exists : bool, optional By default, this method will only create links if the server_folder exists. To create links regardless, pass check_exists=False Returns ------- None Notes ----- - This method will create any folders that do not exist within a server folder - This method will overwrite existing symlinks but will not overwrite any actual files \"\"\" if not server_folder . exists () and check_exists : return server_file = server_folder / resource_path server_file . parent . mkdir ( parents = True , exist_ok = True ) relative_path = os . path . relpath ( destination , server_file . parent ) if server_file . is_symlink (): # remove previous symlink in this spot server_file . unlink () os . symlink ( relative_path , server_file ) place_enderchest ( root , cleanup = True ) Link all instance files and folders Parameters: Name Type Description Default root path The root directory that contains the EnderChest directory, instances and servers required cleanup bool , optional By default, this method will remove any broken links in your instances and servers folders. To disable this behavior, pass in cleanup=False True Source code in enderchest/place.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def place_enderchest ( root : str | os . PathLike , cleanup : bool = True ) -> None : \"\"\"Link all instance files and folders Parameters ---------- root : path The root directory that contains the EnderChest directory, instances and servers cleanup : bool, optional By default, this method will remove any broken links in your instances and servers folders. To disable this behavior, pass in cleanup=False \"\"\" instances = Path ( root ) / \"instances\" servers = Path ( root ) / \"servers\" for context_type , context_root in contexts ( root ) . _asdict () . items (): make_server_links = context_type in ( \"universal\" , \"server_only\" ) make_instance_links = context_type in ( \"universal\" , \"client_only\" , \"local_only\" ) assets = sorted ( context_root . rglob ( \"*@*\" )) for asset in assets : if not asset . exists (): continue path , * tags = str ( asset . relative_to ( context_root )) . split ( \"@\" ) for tag in tags : if make_instance_links : link_instance ( path , instances / tag , asset ) if make_server_links : link_server ( path , servers / _tokenize_server_name ( tag ), asset ) if cleanup : for file in ( * instances . rglob ( \"*\" ), * servers . rglob ( \"*\" )): if not file . exists (): file . unlink ()","title":"place"},{"location":"reference/enderchest/place/#enderchest.place.link_instance","text":"Create a symlink for the specified resource from an instance's space pointing to the tagged file / folder living in the EnderChest folder. Parameters: Name Type Description Default resource_path str Location of the resource relative to the instance's \".minecraft\" folder required instance_folder Path the instance's folder (parent of \".minecraft\") required destination Path the location to link, where the file or older actually lives (inside the EnderChest folder) required check_exists bool , optional By default, this method will only create links if a \".minecraft\" folder exists in the instance_folder. To create links regardless, pass check_exists=False True Returns: Type Description None","title":"link_instance()"},{"location":"reference/enderchest/place/#enderchest.place.link_instance--notes","text":"This method will create any folders that do not exist within an instance, but only if the instance folder exists and has contains a \".minecraft\" folder or if check_exists is set to False This method will overwrite existing symlinks but will not overwrite any actual files. Source code in enderchest/place.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def link_instance ( resource_path : str , instance_folder : Path , destination : Path , check_exists = True ) -> None : \"\"\"Create a symlink for the specified resource from an instance's space pointing to the tagged file / folder living in the EnderChest folder. Parameters ---------- resource_path : str Location of the resource relative to the instance's \".minecraft\" folder instance_folder : Path the instance's folder (parent of \".minecraft\") destination : Path the location to link, where the file or older actually lives (inside the EnderChest folder) check_exists : bool, optional By default, this method will only create links if a \".minecraft\" folder exists in the instance_folder. To create links regardless, pass check_exists=False Returns ------- None Notes ----- - This method will create any folders that do not exist within an instance, but only if the instance folder exists and has contains a \".minecraft\" folder *or* if check_exists is set to False - This method will overwrite existing symlinks but will not overwrite any actual files. \"\"\" if not ( instance_folder / \".minecraft\" ) . exists () and check_exists : return instance_file = instance_folder / \".minecraft\" / resource_path instance_file . parent . mkdir ( parents = True , exist_ok = True ) relative_path = os . path . relpath ( destination , instance_file . parent ) if instance_file . is_symlink (): # remove previous symlink in this spot instance_file . unlink () os . symlink ( relative_path , instance_file )","title":"Notes"},{"location":"reference/enderchest/place/#enderchest.place.link_server","text":"Create a symlink for the specified resource from an server's space pointing to the tagged file / folder living in the EnderChest folder. Parameters: Name Type Description Default resource_path str Location of the resource relative to the instance's \".minecraft\" folder required server_folder Path the server's folder required destination Path the location to link, where the file or older actually lives (inside the EnderChest folder) required check_exists bool , optional By default, this method will only create links if the server_folder exists. To create links regardless, pass check_exists=False True Returns: Type Description None","title":"link_server()"},{"location":"reference/enderchest/place/#enderchest.place.link_server--notes","text":"This method will create any folders that do not exist within a server folder This method will overwrite existing symlinks but will not overwrite any actual files Source code in enderchest/place.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def link_server ( resource_path : str , server_folder : Path , destination : Path , check_exists = True ) -> None : \"\"\"Create a symlink for the specified resource from an server's space pointing to the tagged file / folder living in the EnderChest folder. Parameters ---------- resource_path : str Location of the resource relative to the instance's \".minecraft\" folder server_folder : Path the server's folder destination : Path the location to link, where the file or older actually lives (inside the EnderChest folder) check_exists : bool, optional By default, this method will only create links if the server_folder exists. To create links regardless, pass check_exists=False Returns ------- None Notes ----- - This method will create any folders that do not exist within a server folder - This method will overwrite existing symlinks but will not overwrite any actual files \"\"\" if not server_folder . exists () and check_exists : return server_file = server_folder / resource_path server_file . parent . mkdir ( parents = True , exist_ok = True ) relative_path = os . path . relpath ( destination , server_file . parent ) if server_file . is_symlink (): # remove previous symlink in this spot server_file . unlink () os . symlink ( relative_path , server_file )","title":"Notes"},{"location":"reference/enderchest/place/#enderchest.place.place_enderchest","text":"Link all instance files and folders Parameters: Name Type Description Default root path The root directory that contains the EnderChest directory, instances and servers required cleanup bool , optional By default, this method will remove any broken links in your instances and servers folders. To disable this behavior, pass in cleanup=False True Source code in enderchest/place.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def place_enderchest ( root : str | os . PathLike , cleanup : bool = True ) -> None : \"\"\"Link all instance files and folders Parameters ---------- root : path The root directory that contains the EnderChest directory, instances and servers cleanup : bool, optional By default, this method will remove any broken links in your instances and servers folders. To disable this behavior, pass in cleanup=False \"\"\" instances = Path ( root ) / \"instances\" servers = Path ( root ) / \"servers\" for context_type , context_root in contexts ( root ) . _asdict () . items (): make_server_links = context_type in ( \"universal\" , \"server_only\" ) make_instance_links = context_type in ( \"universal\" , \"client_only\" , \"local_only\" ) assets = sorted ( context_root . rglob ( \"*@*\" )) for asset in assets : if not asset . exists (): continue path , * tags = str ( asset . relative_to ( context_root )) . split ( \"@\" ) for tag in tags : if make_instance_links : link_instance ( path , instances / tag , asset ) if make_server_links : link_server ( path , servers / _tokenize_server_name ( tag ), asset ) if cleanup : for file in ( * instances . rglob ( \"*\" ), * servers . rglob ( \"*\" )): if not file . exists (): file . unlink ()","title":"place_enderchest()"},{"location":"reference/enderchest/sync/","text":"Utilities for synchronizing chests across different computers Remote Bases: NamedTuple Specification of a remote EnderChest installation to sync with using rsync over ssh (other protocols are not explicitly supported). Attributes: Name Type Description host str The address ( e.g. 127.0.0.1) or cname/URL ( e.g. steamdeck.local) of the host you're syncing with. root path The root directory on the remote machine that contains all your minecraft stuff. Explicitly expects that the folder contains: your EnderChest folder; your Multi-MC-style instances folder; your servers. username str , optional The username for logging onto the remote machine. If None is specified on instantiation, it's assumed that you don't need a username to log into the server from this local. alias str A shorthand way to refer to the remote installation. If None is specified on instantiation, this will be the same as the host attribute. remote_folder str The full specification of the remote root, e.g. deck@steamdeck.local:~/minecraft Notes This class is not designed to be safe against injection attacks and has none of the protections you'd get out of using, say, the urllib.parse module. Source code in enderchest/sync.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class Remote ( NamedTuple ): \"\"\"Specification of a remote EnderChest installation to sync with using rsync over ssh (other protocols are not explicitly supported). Attributes ---------- host : str The address (_e.g._ 127.0.0.1) or cname/URL (_e.g._ steamdeck.local) of the host you're syncing with. root : path The root directory on the remote machine that contains all your minecraft stuff. Explicitly expects that the folder contains: your EnderChest folder; your Multi-MC-style instances folder; your servers. username : str, optional The username for logging onto the remote machine. If None is specified on instantiation, it's assumed that you don't need a username to log into the server from this local. alias : str A shorthand way to refer to the remote installation. If None is specified on instantiation, this will be the same as the host attribute. remote_folder : str The full specification of the remote root, _e.g._ deck@steamdeck.local:~/minecraft Notes ----- This class is not designed to be safe against injection attacks and has none of the protections you'd get out of using, say, the urllib.parse module. \"\"\" host : str | None # intentionally not in the docstring to use None for local mirror root : str | os . PathLike username : str | None = None alias_ : str | None = None @property def alias ( self ) -> str : return self . alias_ or self . host or Path ( self . root ) . name @property def _encoded_root ( self ) -> str : \"\"\"Shell-script safe version of the root folder. Notes ----- Can't just use shlex.quote directly because it tries to quote \"~\" \"\"\" root_string = str ( self . root ) if root_string == \"~\" : return root_string if root_string . startswith ( \"~/\" ): return \"~/\" + shlex . quote ( root_string [ 2 :]) return shlex . quote ( root_string ) @property def remote_folder ( self ) -> str : if not self . host : # then the \"remote\" is actually local return self . _encoded_root if not self . username : url = shlex . quote ( self . host ) else : url = f \" { self . username } @ { shlex . quote ( self . host ) } \" return f \" { url } : { self . _encoded_root } \" @classmethod def from_string ( cls , oneline_spec : str ) -> \"Remote\" : match oneline_spec . split ( \":\" ): case [ root ]: address : str | None = None case address , * root : root = \":\" . join ( root ) case _ : raise ValueError ( f \"Unable to parse { oneline_spec } into a remote spec\" ) if address is None : username : str | None = None host : str | None = None else : match address . split ( \"@\" ): case [ host ]: username = None case username , host : pass case _ : raise ValueError ( f \"Unable to parse { oneline_spec } into a remote spec\" ) return Remote ( host , root , username ) RemoteSync dataclass A specification of a remote and the commands to run pre- and post- syncing with the remote\" Attributes: Name Type Description remote Remote The remote to sync pre_open list of str Any commands to run before pulling in EnderChest changes from the remote pre_close list of str Any commands to run before pushing EnderChest changes to the remote post_open list of str Any commands to run after pulling in EnderChest changes from the remote post_close list of str Any commands to run after pushing EnderChest changes to the remote Source code in enderchest/sync.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 @dataclass class RemoteSync : \"\"\" A specification of a remote and the commands to run pre- and post- syncing with the remote\" Attributes ---------- remote : Remote The remote to sync pre_open: list of str Any commands to run before pulling in EnderChest changes from the remote pre_close: list of str Any commands to run before pushing EnderChest changes to the remote post_open: list of str Any commands to run after pulling in EnderChest changes from the remote post_close: list of str Any commands to run after pushing EnderChest changes to the remote \"\"\" remote : Remote pre_open : Sequence [ str ] = field ( default_factory = list ) pre_close : Sequence [ str ] = field ( default_factory = list ) post_open : Sequence [ str ] = field ( default_factory = list ) post_close : Sequence [ str ] = field ( default_factory = list ) link_to_other_chests ( local_root , * remotes , local_alias = None , overwrite = False , omit_scare_message = False , pre_open = None , pre_close = None , post_open = None , post_close = None ) Generate bash scripts for syncing to EnderChest installations on other computers. These will be saved in your EnderChest/local-only folder under open.sh (for pulling from remotes) and close.sh (for pushing to other remotes) Parameters: Name Type Description Default local_root path The local root directory that contains both the EnderChest directory, instances and servers required *remotes Remotes The remote installations to sync with () local_alias str , optional A shorthand way to refer to the local installation. This is what determines the name of the local settings backup folder inside remote \"other-locals\" folders. If None is specified, this computer's hostname will be used. None overwrite bool , optional By default, if an open/close script exists, this method will leave it alone. To instead overwrite any existing scripts, explicitly pass in the keyword argument overwrite=True False omit_scare_message bool , optional By default, the scripts this method generates are not runnable and tell the user to first open them in a text editor and look them over. If you really really trust this method and the use of it, pass in the keyword argument omit_scare_message=True to omit this safeguard and just make them runnable from the get-go. False pre_open Sequence [ str ] | None Any commands to run before pulling in EnderChest changes from the remotes None pre_close Sequence [ str ] | None Any commands to run before pushing EnderChest changes to the remotes None post_open Sequence [ str ] | None Any commands to run after pulling in EnderChest changes from the remotes None post_close Sequence [ str ] | None Any commands to run after pushing EnderChest changes to the remotes None Returns: Type Description None Warnings If one of the scripts already exists, this method will emit a warning that generation of a new script is being kipped (if overwrite=True is not specified) or that the old script is being overwritten (if this method is called with overwrite=True). Notes This method is designed for flexibility and transparency over robustness and ease of use. That means that you need to open the scripts this function generates and look them over before ou can actually run them. This also gives you a chance add your own tweaks and customizations before embedding the syncing into your automations. The remotes are assumed to be specified in priority order (top priority first), meaning the first remote: will be the first to receive local changes will be the first to try pulling remote changes from Source code in enderchest/sync.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def link_to_other_chests ( local_root : str | os . PathLike , * remotes : Remote | RemoteSync , local_alias : str | None = None , overwrite : bool = False , omit_scare_message : bool = False , pre_open : Sequence [ str ] | None = None , pre_close : Sequence [ str ] | None = None , post_open : Sequence [ str ] | None = None , post_close : Sequence [ str ] | None = None , ) -> None : \"\"\"Generate bash scripts for syncing to EnderChest installations on other computers. These will be saved in your EnderChest/local-only folder under `open.sh` (for pulling from remotes) and `close.sh` (for pushing to other remotes) Parameters ---------- local_root : path The local root directory that contains both the EnderChest directory, instances and servers *remotes : Remotes / RemoteSyncs The remote installations to sync with local_alias : str, optional A shorthand way to refer to the local installation. This is what determines the name of the local settings backup folder inside remote \"other-locals\" folders. If None is specified, this computer's hostname will be used. overwrite : bool, optional By default, if an open/close script exists, this method will leave it alone. To instead overwrite any existing scripts, explicitly pass in the keyword argument overwrite=True omit_scare_message : bool, optional By default, the scripts this method generates are not runnable and tell the user to first open them in a text editor and look them over. If you *really really trust* this method and the use of it, pass in the keyword argument omit_scare_message=True to omit this safeguard and just make them runnable from the get-go. pre_open: list of str, optional Any commands to run before pulling in EnderChest changes from the remotes pre_close: list of str, optional Any commands to run before pushing EnderChest changes to the remotes post_open: list of str, optional Any commands to run after pulling in EnderChest changes from the remotes post_close: list of str, optional Any commands to run after pushing EnderChest changes to the remotes Returns ------- None Warnings -------- If one of the scripts already exists, this method will emit a warning that generation of a new script is being kipped (if overwrite=True is not specified) or that the old script is being overwritten (if this method is called with overwrite=True). Notes ----- - This method is designed for flexibility and transparency over robustness and ease of use. That means that **you need to open the scripts this function generates** and look them over before ou can actually run them. This also gives you a chance add your own tweaks and customizations before embedding the syncing into your automations. - The remotes are assumed to be specified in **priority order** (top priority first), meaning the first remote: - will be the first to receive local changes - will be the first to try pulling remote changes from \"\"\" open_script = HEADER close_script = HEADER if not omit_scare_message : open_script += SCARE_MESSAGE close_script += SCARE_MESSAGE open_script += \" \\n \" if pre_open : open_script += \"\" . join ([ f \" { command } \\n \" for command in pre_open ]) if pre_close : close_script += \"\" . join ([ f \" { command } \\n \" for command in pre_close ]) for remote in remotes : yeet , yoink = _build_rsync_scripts ( local_root , local_alias or socket . gethostname (), remote ) close_script += \" \\n \" + yeet open_script += \"{ \\n \" + \" \\n \" . join ( yoink . split ( \" \\n \" )[: - 1 ]) + \" \\n } || \" open_script += \"\"\"{ echo \"Could not pull changes from any remote EnderChests.\" echo \"Are you outside your local network?\" exit 1 } \"\"\" if post_open : open_script += \"\" . join ([ f \" { command } \\n \" for command in post_open ]) if post_close : close_script += \"\" . join ([ f \" { command } \\n \" for command in post_close ]) for name , script in (( \"open\" , open_script ), ( \"close\" , close_script )): script_path = contexts ( local_root ) . local_only / f \" { name } .sh\" if script_path . exists (): warning_message = f \" { name . title () } script already exists.\" if not overwrite : warning_message += \" Skipping.\" warnings . warn ( warning_message ) continue else : warning_message += \" Overwriting.\" warnings . warn ( warning_message ) script_path . write_text ( script ) script_path . chmod ( script_path . stat () . st_mode | stat . S_IEXEC )","title":"sync"},{"location":"reference/enderchest/sync/#enderchest.sync.Remote","text":"Bases: NamedTuple Specification of a remote EnderChest installation to sync with using rsync over ssh (other protocols are not explicitly supported). Attributes: Name Type Description host str The address ( e.g. 127.0.0.1) or cname/URL ( e.g. steamdeck.local) of the host you're syncing with. root path The root directory on the remote machine that contains all your minecraft stuff. Explicitly expects that the folder contains: your EnderChest folder; your Multi-MC-style instances folder; your servers. username str , optional The username for logging onto the remote machine. If None is specified on instantiation, it's assumed that you don't need a username to log into the server from this local. alias str A shorthand way to refer to the remote installation. If None is specified on instantiation, this will be the same as the host attribute. remote_folder str The full specification of the remote root, e.g. deck@steamdeck.local:~/minecraft","title":"Remote"},{"location":"reference/enderchest/sync/#enderchest.sync.Remote--notes","text":"This class is not designed to be safe against injection attacks and has none of the protections you'd get out of using, say, the urllib.parse module. Source code in enderchest/sync.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class Remote ( NamedTuple ): \"\"\"Specification of a remote EnderChest installation to sync with using rsync over ssh (other protocols are not explicitly supported). Attributes ---------- host : str The address (_e.g._ 127.0.0.1) or cname/URL (_e.g._ steamdeck.local) of the host you're syncing with. root : path The root directory on the remote machine that contains all your minecraft stuff. Explicitly expects that the folder contains: your EnderChest folder; your Multi-MC-style instances folder; your servers. username : str, optional The username for logging onto the remote machine. If None is specified on instantiation, it's assumed that you don't need a username to log into the server from this local. alias : str A shorthand way to refer to the remote installation. If None is specified on instantiation, this will be the same as the host attribute. remote_folder : str The full specification of the remote root, _e.g._ deck@steamdeck.local:~/minecraft Notes ----- This class is not designed to be safe against injection attacks and has none of the protections you'd get out of using, say, the urllib.parse module. \"\"\" host : str | None # intentionally not in the docstring to use None for local mirror root : str | os . PathLike username : str | None = None alias_ : str | None = None @property def alias ( self ) -> str : return self . alias_ or self . host or Path ( self . root ) . name @property def _encoded_root ( self ) -> str : \"\"\"Shell-script safe version of the root folder. Notes ----- Can't just use shlex.quote directly because it tries to quote \"~\" \"\"\" root_string = str ( self . root ) if root_string == \"~\" : return root_string if root_string . startswith ( \"~/\" ): return \"~/\" + shlex . quote ( root_string [ 2 :]) return shlex . quote ( root_string ) @property def remote_folder ( self ) -> str : if not self . host : # then the \"remote\" is actually local return self . _encoded_root if not self . username : url = shlex . quote ( self . host ) else : url = f \" { self . username } @ { shlex . quote ( self . host ) } \" return f \" { url } : { self . _encoded_root } \" @classmethod def from_string ( cls , oneline_spec : str ) -> \"Remote\" : match oneline_spec . split ( \":\" ): case [ root ]: address : str | None = None case address , * root : root = \":\" . join ( root ) case _ : raise ValueError ( f \"Unable to parse { oneline_spec } into a remote spec\" ) if address is None : username : str | None = None host : str | None = None else : match address . split ( \"@\" ): case [ host ]: username = None case username , host : pass case _ : raise ValueError ( f \"Unable to parse { oneline_spec } into a remote spec\" ) return Remote ( host , root , username )","title":"Notes"},{"location":"reference/enderchest/sync/#enderchest.sync.RemoteSync","text":"A specification of a remote and the commands to run pre- and post- syncing with the remote\" Attributes: Name Type Description remote Remote The remote to sync pre_open list of str Any commands to run before pulling in EnderChest changes from the remote pre_close list of str Any commands to run before pushing EnderChest changes to the remote post_open list of str Any commands to run after pulling in EnderChest changes from the remote post_close list of str Any commands to run after pushing EnderChest changes to the remote Source code in enderchest/sync.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 @dataclass class RemoteSync : \"\"\" A specification of a remote and the commands to run pre- and post- syncing with the remote\" Attributes ---------- remote : Remote The remote to sync pre_open: list of str Any commands to run before pulling in EnderChest changes from the remote pre_close: list of str Any commands to run before pushing EnderChest changes to the remote post_open: list of str Any commands to run after pulling in EnderChest changes from the remote post_close: list of str Any commands to run after pushing EnderChest changes to the remote \"\"\" remote : Remote pre_open : Sequence [ str ] = field ( default_factory = list ) pre_close : Sequence [ str ] = field ( default_factory = list ) post_open : Sequence [ str ] = field ( default_factory = list ) post_close : Sequence [ str ] = field ( default_factory = list )","title":"RemoteSync"},{"location":"reference/enderchest/sync/#enderchest.sync.link_to_other_chests","text":"Generate bash scripts for syncing to EnderChest installations on other computers. These will be saved in your EnderChest/local-only folder under open.sh (for pulling from remotes) and close.sh (for pushing to other remotes) Parameters: Name Type Description Default local_root path The local root directory that contains both the EnderChest directory, instances and servers required *remotes Remotes The remote installations to sync with () local_alias str , optional A shorthand way to refer to the local installation. This is what determines the name of the local settings backup folder inside remote \"other-locals\" folders. If None is specified, this computer's hostname will be used. None overwrite bool , optional By default, if an open/close script exists, this method will leave it alone. To instead overwrite any existing scripts, explicitly pass in the keyword argument overwrite=True False omit_scare_message bool , optional By default, the scripts this method generates are not runnable and tell the user to first open them in a text editor and look them over. If you really really trust this method and the use of it, pass in the keyword argument omit_scare_message=True to omit this safeguard and just make them runnable from the get-go. False pre_open Sequence [ str ] | None Any commands to run before pulling in EnderChest changes from the remotes None pre_close Sequence [ str ] | None Any commands to run before pushing EnderChest changes to the remotes None post_open Sequence [ str ] | None Any commands to run after pulling in EnderChest changes from the remotes None post_close Sequence [ str ] | None Any commands to run after pushing EnderChest changes to the remotes None Returns: Type Description None","title":"link_to_other_chests()"},{"location":"reference/enderchest/sync/#enderchest.sync.link_to_other_chests--warnings","text":"If one of the scripts already exists, this method will emit a warning that generation of a new script is being kipped (if overwrite=True is not specified) or that the old script is being overwritten (if this method is called with overwrite=True).","title":"Warnings"},{"location":"reference/enderchest/sync/#enderchest.sync.link_to_other_chests--notes","text":"This method is designed for flexibility and transparency over robustness and ease of use. That means that you need to open the scripts this function generates and look them over before ou can actually run them. This also gives you a chance add your own tweaks and customizations before embedding the syncing into your automations. The remotes are assumed to be specified in priority order (top priority first), meaning the first remote: will be the first to receive local changes will be the first to try pulling remote changes from Source code in enderchest/sync.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def link_to_other_chests ( local_root : str | os . PathLike , * remotes : Remote | RemoteSync , local_alias : str | None = None , overwrite : bool = False , omit_scare_message : bool = False , pre_open : Sequence [ str ] | None = None , pre_close : Sequence [ str ] | None = None , post_open : Sequence [ str ] | None = None , post_close : Sequence [ str ] | None = None , ) -> None : \"\"\"Generate bash scripts for syncing to EnderChest installations on other computers. These will be saved in your EnderChest/local-only folder under `open.sh` (for pulling from remotes) and `close.sh` (for pushing to other remotes) Parameters ---------- local_root : path The local root directory that contains both the EnderChest directory, instances and servers *remotes : Remotes / RemoteSyncs The remote installations to sync with local_alias : str, optional A shorthand way to refer to the local installation. This is what determines the name of the local settings backup folder inside remote \"other-locals\" folders. If None is specified, this computer's hostname will be used. overwrite : bool, optional By default, if an open/close script exists, this method will leave it alone. To instead overwrite any existing scripts, explicitly pass in the keyword argument overwrite=True omit_scare_message : bool, optional By default, the scripts this method generates are not runnable and tell the user to first open them in a text editor and look them over. If you *really really trust* this method and the use of it, pass in the keyword argument omit_scare_message=True to omit this safeguard and just make them runnable from the get-go. pre_open: list of str, optional Any commands to run before pulling in EnderChest changes from the remotes pre_close: list of str, optional Any commands to run before pushing EnderChest changes to the remotes post_open: list of str, optional Any commands to run after pulling in EnderChest changes from the remotes post_close: list of str, optional Any commands to run after pushing EnderChest changes to the remotes Returns ------- None Warnings -------- If one of the scripts already exists, this method will emit a warning that generation of a new script is being kipped (if overwrite=True is not specified) or that the old script is being overwritten (if this method is called with overwrite=True). Notes ----- - This method is designed for flexibility and transparency over robustness and ease of use. That means that **you need to open the scripts this function generates** and look them over before ou can actually run them. This also gives you a chance add your own tweaks and customizations before embedding the syncing into your automations. - The remotes are assumed to be specified in **priority order** (top priority first), meaning the first remote: - will be the first to receive local changes - will be the first to try pulling remote changes from \"\"\" open_script = HEADER close_script = HEADER if not omit_scare_message : open_script += SCARE_MESSAGE close_script += SCARE_MESSAGE open_script += \" \\n \" if pre_open : open_script += \"\" . join ([ f \" { command } \\n \" for command in pre_open ]) if pre_close : close_script += \"\" . join ([ f \" { command } \\n \" for command in pre_close ]) for remote in remotes : yeet , yoink = _build_rsync_scripts ( local_root , local_alias or socket . gethostname (), remote ) close_script += \" \\n \" + yeet open_script += \"{ \\n \" + \" \\n \" . join ( yoink . split ( \" \\n \" )[: - 1 ]) + \" \\n } || \" open_script += \"\"\"{ echo \"Could not pull changes from any remote EnderChests.\" echo \"Are you outside your local network?\" exit 1 } \"\"\" if post_open : open_script += \"\" . join ([ f \" { command } \\n \" for command in post_open ]) if post_close : close_script += \"\" . join ([ f \" { command } \\n \" for command in post_close ]) for name , script in (( \"open\" , open_script ), ( \"close\" , close_script )): script_path = contexts ( local_root ) . local_only / f \" { name } .sh\" if script_path . exists (): warning_message = f \" { name . title () } script already exists.\" if not overwrite : warning_message += \" Skipping.\" warnings . warn ( warning_message ) continue else : warning_message += \" Overwriting.\" warnings . warn ( warning_message ) script_path . write_text ( script ) script_path . chmod ( script_path . stat () . st_mode | stat . S_IEXEC )","title":"Notes"}]}